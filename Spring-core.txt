< --------------------------- 좋은 객체 지향 프로그래밍이란? --------------------------- >
* 다형성의 본질
	> 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
	> 다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야함
	> 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다. --> 가장 큰 본질

* 의존하다. : 내가 상대방을 알고있다.

* 스프링과 객체 지향
	> 다형성이 가장 중요하며, 스프링은 이를 극대화해서 이용할 수 있게함
	> Spring의 IoC(제어의역전), DI(의존관계 주입)은 다형성을 활용함, 따라서 역할과 구현을 편리하게 나눌 수 있도록 지원함





< --------------------------- 좋은 객체 지향 설계의 5가지 원칙(SOLID) --------------------------- >
1. SRP(Single Responsibility Principle) 단일 책임 원칙
	> 한 클래스는 하나의 책임만 가져야 한다.
	> 하나의 책임이라는 것은 모호함
		> 클 수도 작을수도
		> 문맥과 상황에 따라 다르다.
	> 중요한 기준은 변경이다.
		> 변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른것(UI변경, 객체의 생성과 사용을 분리)

2. OCP(Open-Closed Principle) 계방-폐쇄 원칙
	> 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
	> 다형성을 활용하면 가능해짐
	> 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능 구현 -- 확장
	> 지금까지 배운 역할과 구현의 분리 생각하면 답이 나옴

	> 문제점
		> MemberService 클라이언트가 구현 클래스를 직접 선택
		> MemberService m = new MemoryMemberRepository(); // 기존코드
		> MemberService m = new JdbcMemberRepository(); // 변경코드
		> 구현 객체를 변경하려면 클라이언트 코드 변경 필요
		> 다형성을 이용했지만 OCP 원칙을 지킬 수 없다.
		> 어떻게 해결?
			> 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요(Spring이 해줌)

3. LSP(Liskov subsitution principle) 리스코프 치환 원칙
	> 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
	> 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원히기 위한 원칙,
	  인터페이스를 구현한 구현체는 믿고 사용하려면 필요

	> 단순히 컴파일 성공을 넘어서는 이야이
		ex) 자동차 인터페이스에서 악셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP위반


4. ISP(Interface Segregation Principle) 인터페이스 분리 원칙
	> 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
	> 자동차 인터페이스 -> 운전, 정비 인터페이스로 분리
	> 사용자 클라이언트 -> 운전자, 정비사 클라이언트로 분리
	> 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
	> 인터페이스가 명확해지고, 대체 가능성이 높아짐

5. DIP(Depnedency Inversion Principle) 의존관계 역전 원칙
	> 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
	> 쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
	> 앞에서 이야기한 역할(ROLE)에 의존하게 해야 한다는 것과 같음, 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경가능함
	  구현체에 의존하게 되면 변경이 아주 어려워진다.

	> OCP에서 설명한 MemberService는 인터페이스에 의존하지만 동시에 구현 클래스도 의존한다.
	> MemberService 클라이언트가 구현 클래스를 직접 선택
		> MemberRepository m = new MemoryMemberRepository();
	> 이는 DIP 위반

* 정리
	> 객체 지향의 핵심은 다형성
	> 다형성 만으로는 쉽게 부품을 갈아 끼우듯 개발할 수 없다.
	> 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
	> 다형성 만으로는 OCP, DIP를 지킬 수 없다.
	> 따라서 무엇인가 더 필요하다. ----> Spring





< --------------------------- 객체 지향 설계와 스프링 --------------------------- >
* 스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원
	> DI(Dependency Injection) : 의존관계, 의존성 주입
	> DI 컨테이너 제공

* 클라이언트 코드의 변경없이 기능 확장
* 쉽게 부품을 교체하듯이 개발

* 순수하게 자바로 OCP, DIP원칙들을 지키면서 개발을 해보면, 결국 스프링 프레임워크를 만들게됨(더 정확히 DI 컨테이너)

* 정리
	> 모든 설계에 역할과 구현을 분리하자.
	> 어플리케이션 설계도 공연을 설계하듯 배역만 만들고, 배우는 언제든지 유연하게 변경할 수 있도록 만드는것이 좋은 객체 지향 설계
	> 이상적으로는 모든 설계에 인터페이스를 부여하자
		> 인터페이스를 먼저 만들게 되면 구현체에 대한 선택을 최대한 미룰 수 있음

* 실무적인 고민을 해보자
	> 인터페이스를 도입하면 추상화라는 비용이 발생한다.
		> 코드만 가지고 인터페이스를 보면 구현체가 뭔지 한번 더 들여봐야함
* 추천방법
	> 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법이다.





< --------------------------- 비즈니스 요구사항과 설계 --------------------------- >
* 아래와 같은 요구사항이 있다.

* 회원
	> 회원을 가입하고 조회할 수 있다.
	> 회원은 일반과 VIP 두 가지 등급이 있다.
	> 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. (미확정)
		(인터페이스로 일단 구현)
* 주문과 할인 정책
	> 회원은 상품을 주문할 수 있다.
	> 회원 등급에 따라 할인 정책을 적용할 수 있다.
	> 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있다.)
	> 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다.
	  최악의 경우 할인을 적용하지 않을 수 도 있다. (미확정)


* 요구사항에서 회원 데이터, 할인 정책은 지금 결정하기 어려운 부분, 그렇다고 결정될때까지 기다릴 수 는 없다.
  따라서 객체지향 설계 방법을 이용해 만들자





< --------------------------- 회원 도메인 설계 --------------------------- >
* 현재 회원 저장소는 아직 자체 DB를 이용할지 외부 시스템과 연동할지 정해지지 않음
	> 먼저 인터페이스를 우선 만듦 이후 구현체는 (메모리 회원 저장소, DB 회원 저장소, 외부 시스템 연동 회원 저장소)로 나뉨
	> 하지만 자체 DB로 할지 외부 시스템 연동을 할지 정해지지 않음
	> 따라서 메모리 회원 저장소를 이용하는데 이는 자바 코드로 회원 객체를 넣다 뺐다 할 수 있는 것을 만들이 일단 개발 진행(실행, 테스트 모두 가능)
	  (후에 변경 가능)

* 개념적 그림은 회원 도메인 협력관계, 회원 클래스 다이어그램, 회원 객체 다이어그램 이렇게 그림이 총 3개가 만들어진다.
	> 회원 도메인 협력관계 : 기획자들도 볼 수 있는 그림
	> 회원 클래스 다이어그램 : 도메인 협력관계를 바탕으로 개발자들이 만듦
	> 회원 객체 다이어그램 : 실제 서버를 실행하지 않고 클래스들만 분석해서 볼 수 있음
	  (다만 구현체(메모리 멤버 레포, 디비 레포)들은 동적으로 결정된다, 따라서 객체 다이어그램이 따로 존재함
	   이는 실제 new로 연결된 인스턴스들 끼리의 참조를 보여줌)





< --------------------------- 회원 도메인 개발 --------------------------- >

* 등급을 위한 Grade enum 클래스 정의
* ID, 이름, 등급을 가진 Member 엔티티 정의
* 멤버를 저장하고, id를 통해 멤버를 찾는 인터페이스 정의 : MemberRepository
* MemberRepository를 구현하는 구현체인 MemoryMemberRepository를 정의
* 회원가입, 회원조회 서비스를 가진 서비스 회원 서비스 인터페이스 정의 : MemberService
* MemberService를 구현하는 구현체인 MemberServiceImpl 정의 : 구현체가 하나만 있을경우 관례상 인터페이스명 뒤에 Impl을 붙임





< --------------------------- 회원 도메인 실행과 테스트 --------------------------- >
* 간단한 회원 도메인의 인스턴스간 참조 그림은 회원 객체 다이어그램과 동일하게 된다.
	> 회원 클래스 다이어그램 : 정적인 다이어그램
	> 회원 객체 다이어그램 : 동적인 다이어그램

* 멤버를 만들어 임의로 ID, 이름, 등급을 부여하고 가입을 시킨다.
  이후 findMember 변수로 멤버 서비스의 findMember()메소드를 이용해 가입한 객체를 받아오고
  최종적으로 기존의 member의 이름과, findMember에 저장된 객체의 멤버 이름을 비교하는 로직을 만든다.

public class MemberApp {
    public static void main(String[] args) {
        MemberService memberService = new MemberServiceImpl();
        Member member = new Member(1L, "memberA", Grade.VIP);

        Member findMember = memberService.findMember(1L);
        System.out.println("new member = " + member.getName());
        System.out.println("find Member = " + findMember.getName());
    }
}

* 하지만 어플리케이션 로직으로 main을 이용한 테스트는 좋은 방법이 아님. --> JUnit test를 이용한다.
	> 눈으로 출력된 콘솔의 결과를 보는것이 아님
	> 다른코드를 추가 했을때 오류 나는것도 캐치하기 쉬움
	> 테스트 작성 방법은 필수 (공부하자)

* 회원 도메인은 설계의 문제점이 있다.
	> 만약 다른 저장소로 변경하고자 한다면 OCP원칙을 준수하지 못함
	> 또한 DIP는 잘 지키고 있을까?
	> 즉 의존관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점이 있다.
		> 주문까지 만들고 나서 문제점과 해결 방안을 설명해보자





< --------------------------- 주문과 할인 도메인 설계 --------------------------- >
* 주문과 할인 정책은 다음과 같다.
	> 회원은 상품을 주문할 수 있다.
	> 회원 등급에 따라 할인 정책을 적용할 수 있다.
	> 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있다.)
	> 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다. \
	  최악의 경우 할인을 적용하지 않을 수 도 있다. (미확정)

* 회원의 주문 과정은 아래와 같다.
	1. 주문 생성: 클라이언트는 주문 서비스에 주문 생성을 요청한다.
	2. 회원 조회: 할인을 위해서는 회원 등급이 필요하다. 그래서 주문 서비스는 회원 저장소에서 회원을 조회한다.
	3. 할인 적용: 주문 서비스는 회원 등급에 따른 할인 여부를 할인 정책에 위임한다.
	4. 주문 결과 반환: 주문 서비스는 할인 결과를 포함한 주문 결과를 반환한다

* 할인 정책과 회원 저장소(인터페이스)는 역할과 구현을 분리해서 언제나 유연하게 구현 객체를 조립하고 변경할 수 있게 설계해야한다.

* 클래스 다이어그램은 정적이며 객체 다이어그램은 동적이다.
	> 우리는 할인정책 구현체를 정액 할인 정책(등급 상관없이 일정금액 할인)과 정률 할인 정책(%단위의 할인)
	  2개를 임시로 구현체를 만들것이므로 2개의 주문 도메인 객체 다이어그램이 생성된다.





< --------------------------- 주문과 할인 도메인 개발 --------------------------- >
* 주문과 할인 도메인을 개발해보자

* 우선 할인 정책 인터페이스를 만들어야 함
	> 할인정책 인터페이스는 discount 메소드를 가지는데 이는 할인 대상의 할인 금액을 반환한다.
	> 현재는 정액할인정책만 구현체로 두었고 Grade가 VIP일때 1000원 할인된 가격을 반환한다.

* 정책설정까지 완료되었고 Order 객체를 생성하자
	> Order 객체는 memberId, itemName, itemPrice, discountPrice를 필드로 가진다.
	> 생성자와 기본적인 Getter and Setter를 생성하고 비즈니스 로직 처리를 위한 계산된 할인가격을 구하는 메소드calculatePrice() 생성

* 주문 서비스 인터페이스 를 생성하자
	> createOrder()는 주문을 생성하는 메소드이며 주문 도메인에서 정한 memberId, itemName, itemPrice를 인자로 가진다.
	> 결과값으로 주문결과를 반환한다. (Order객체)

<<핵심 로직>>
* 주문 서비스 구현체 : OrderServiceImpl 구현체 생성 및 구현 메소드createOrder()의 주문 처리 순서
	> 1. 주문생성을 위해서 createOrder()메소드를 구현하고
	> 2. 회원조회를 위해 MemberRepository 변수를 필드로 둔다. : 회원 저장소에서 memberId를 통해 Member를 식별하고 가져온다.
	> 3. 할인적용을 위해 DiscountPolicy 변수를 필드로 둔다. : 할인 정책은 Member 객체와 상품가격을 넘겨주어 할인가격을 가져온다.
		(여기서 OrderService는 할인가격이 정해지는것에 관심이 없다 모든 할인관련은 전적으로 맡김 따라서 단일책임원칙이 성립한다.)
		(추가로 Member 객체를 넘기는것과, Grade값 자체를 넘기는것은 차이가 없으나 프로젝트 상황따라 유동적으로 정한다)
	> 4. 마지막으로 new Order()로 주문객체를 생성하고 생성된 주문결과를 반환해준다.

<< 코드의 주석과 연관해서 공부 >>





< --------------------------- 주문과 할인 도메인 실행과 테스트 --------------------------- >
* main 클래스를 만들자 : OrderApp
	> 임의로 멤버를 생성하고 가입하고
	> 임의로 상품의 주문을 생성하고
	> 결과로 출력하면(toString()) 정상적으로 할인정책률이 적용된다.

* Test 클래스를 만들자
	> 임의로 멤버를 생성하고 가입하고
	> 임의로 상품의 주문을 생성하고
	> 여기서 Assertions를 이용해 정말 할인률이 1000원인지 테스트를 한다.
	> 이렇게 단위테스트를 하고나면 시간이 매우 짧게 소요됨

* 수천개의 단위테스트도 매우 짧은시간에 테스트 할 수 있다.
	> 따라서 테스트는 매우 중요!! 꼭 공부하자
	> 여기서 말하는 단위테스트는 Spring이나 다른 컨테이너의 도움 없이 순수한 자바코드로 작성하고 테스트 하는것을 말한다.

* 이 코드에서 유의할점 MemberService.join()으로 가입할때 사용되는 HashMap과 OrderService.createOrder()시 사용되는 HashMap은 
  서로 다른 MemberRepository의 인스턴스를 2개 가진다 유의하자

* 그렇다면 정액할인률 정책을 정률 할인 정책으로 변경됐을때 정말 객체지향적으로 설계되었을까?
  ( 다형성을 잘 활용하고, 역할과 구현을 잘 분리했다. 그런데 과연 정률 할인 정책으로 깔끔하게 변경할 수 있을까?)





< --------------------------- 새로운 할인 정책 개발 --------------------------- >
* 기획자의 새로운 요구사항
	<기획자>
	서비스 오픈 직전에 할인 정책을 지금처럼 고정 금액 할인이 아니라 좀 더 합리적인 주문
	금액당 할인하는 정률% 할인으로 변경하고 싶어요. 예를 들어서 기존 정책은 VIP가 10000원을 주문하든
	20000원을 주문하든 항상 1000원을 할인했는데, 이번에 새로 나온 정책은 10%로 지정해두면 고객이
	10000원 주문시 1000원을 할인해주고, 20000원 주문시에 2000원을 할인해주는 거에요!


	<개발자>
	객체지향설계 원칙을 준수 했으므로 가능할거라 생각

* 따라서 정말 객체지향설계 원칙을 잘 준수했는지 확인해봐야함
	> 기존에 DiscountPolicy를 구현하는 FixDiscountPolicy가 존재하므로 RateDiscountPolicy만 추가로 개발하면 됨


* RateDiscountPolicy 구현
	> DiscountPolicy를 구현하므로 discount()메소드를 구현해야함
	> 등급이 VIP등급이면 현재 가격에서 10%를 할인하는 로직 구현
	> 모든 로직은 테스트가 중요하지만 특히나 할인율을 결정하는 로직은 테스트가 매우 중요 (command + shift + T 누르면 테스트 클래스 작성됨)

* 테스트 코드 작성 : RateDiscountPolicyTest
	> 테스트의 목적은 VIP등급이면 정말 10%로의 할인이 되는지 확인해야함
	> 따라서 @Test 어노테션 뿐 아니라 테스트의 이름을 정하는 @DisplayName("[TEST NAME]")을 같이 이용한다.ㄴ

	> 임의로 VIP등급의 멤버를 생성하고 RateDiscountPolicy.discount()메소드로 멤버를 넘겨준다
	> 이후 Assertions.assertThat(할인금액).isEqualTo(예상금액)을 이용해 검증한다.

* 테스트 코드는 성공 테스트도 중요하지만 실패 테스트도 매우 중요하다.
	> 새로운 실패 테스트의 이름은 @DisplayName("VIP가 아니면 할인이 적용되지 않아야 한다.")
	> 기존의 성공 테스트에서 등급을 BASIC으로 두고 실행하면 테스트 오류 발생 --> 정상 동작
		> 이때의 테스트 메시지는 아래와 같다.
			> Expected :1000
			> Actual   :0		>> 기대한 값은 1000원이지만 실제값은 0원이라는 오류 출력

	> 혹은 Assertions.assertThat(할인금액).isEqualTo(0)으로 두어 VIP등급이 아니면 0원이다를 검증할 수 도 있다.

* static import
	> 자바 클래스의 static 메소드는 클래스에 대한 인스턴스의 생성없이 메소드를 사용할 수 있습니다.
	> 기존에는 assertThat을 사용하기 위해 클래스명.메소드로 이용했지만 static import를 하면 메소드의 이름으로만 사용할 수 있다.

> import static org.assertj.core.api.Assertions.*;


* 실무에서의 할인정책 로직은 쉽지 않다. (특히 돈 관련 된 로직은 매우 많은 테스트를 가짐)
	> 다만 위와 같은 상황은 설계과 잘 되어있기 때문에 쉽게 테스트 할 수 있음 
	  (단일 책임 원칙이 잘 지켜져서 할인과 관련된 부분은 할인 부분만 테스트하므로)

* 이제 RateDiscountPolicy를 실제 적용을 해보자





< --------------------------- 새로운 할인 정책 적용과 문제점 --------------------------- >
* 새로운 할인정책을 적용하기 위해 OrderServiceImpl의 코드를 수정한다.
	> private final DiscountPolicy discountPolicy = new RateDiscountPolicy();		// 새로운 할인정책 : 정률할인정책 적용

<문제점>
* 할인정책을 변경하려면 클라이언트인 OrederServiceImpl의 코드를 고쳐야한다.
	> 역할과 구현 충실히 분리 O
	> 다형성 활용, 인터페이스와 구현 객체 분리 O
	> OCP, DIP 같은 객체지향 설계 원칙을 준수? X
		> DIP :  OrderServiceImple은 DiscountPolicy인터페이스만 의존하는것이 아니라 구현체인 Fix, RateDiscountPolicy도 동시에 의존함
		  따라서 DIP를 위반함
	
		> OCP : 변경하지 않고 확장할 수 있을것 같지만 기능을 확장해서 변경하려면 클라이언트(OrderServiceImpl)의 코드에 직접적으로 영향을준다
		  따라서 OCP를 위반함

* 이것을 해결하기 위해 인터페이스에만 의존하도록 설계하면
	> private DiscountPolicy discounPolicy; (final은 객체를 생성해야 작성가능)
	> 위와 같이 작성하면 인터페이스만 의존하지만 NullPointException이 발생한다.

* 결국 이것을 해결하기 위해선 누군가가 클라이언트(OrderServiceImpl)에 DiscountPolicy의 구현 객체를 대신 생성하고 주입해야함





< --------------------------- 관심사의 분리 --------------------------- >
* 애플리케이션을 로미오와 줄리엣 공연으로 보자
* 우리는 지금까지 로미오 역할(인터페이스)을 하는 디카프리오(구현체)가
  줄리엣 역할(인터페이스)을 하는 여자 주인공(구현체)를 직접 초빙하고 있다.

* 즉 디카프리오가 공연과 여자 주인공을 공연에 초빙하는 다양한 책임을 가지게 된다.

* 관심사를 분리하자
	> 배우는 본인의 역할인 배역 수행에만 집중 해야함
	> 따라서 디카프리오는 어떤 상대역이와도 똑같이 공연해야함
	> 공연구성, 담당배우 섭외, 역할 맞는 배우 지정과 같은 책임은 별도의 공연기획자가 담당해야한다.
	> 따라서 공연 기획자를 만들어서 배우와 기획자의 책임을 분리해야함

* 애플리케이션의 전체 동작 방식을 구성(config)하기 위해, 구현 객체를 생성하고, 연결하는 책임을
  가지는 별도의 설정 클래스를 만들어야함
	> 어플리케이션 전반에 대한 운영을 책임진다.

* AppConfig 만들기
	> 현재 만들어진 서비스들을 생성하고 반환해준다. 다만 생성자 주입을 이용해 서비스 구현체에 필요한 의존성을 주입한다.
	> 이렇게 AppConfig가 만들어지면 서비스 구현체는 기존에 new를 통해 의존성을 생성하는 코드가 사라지고 오로지 인터페이스에만 의존하게 된다.
	> 즉 DIP가 성립된다.

<AppConfig>
        // 애플리케이션 전체를 설정하고 구성함
        // 구현 객체를 생성하고, 연결하는 책임을 가짐
        public class AppConfig {
        
            // memberService를 만들어보자
            public MemberService memberService() {
                return new MemberServiceImpl(new MemoryMemberRepository());
            }
        
            public OrderService orderService() {
                return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy());
            }
        
        }
        
<MemberServiceImpl>
        public class MemberServiceImpl implements MemberService {
        
            private final MemberRepository memberRepository;
            // AppConfig를 통해 레포지토리의 구현체를 참조하고, 인터페이스에만 의존함
            // 어떤 레포지토리가 들어올지 모르고, 상관쓰지 않아도 됨
            public MemberServiceImpl(MemberRepository memberRepository) {
                this.memberRepository = memberRepository;
            }
        
            @Override
            public void join(Member member) {
                memberRepository.save(member);
            }
        
            @Override
            public Member findMember(Long memberId) {
                return memberRepository.findById(memberId);
            }
        }
        


	> 즉, AppConfig는 애플리케이션의 실제 동작에 필요한 구현 객체를 생성함
	> 또한, AppConfig는 생성한 객체 인스턴스의 참조(레퍼런스)를 생성자를 통해서 주입(연결)해준다.
	  (OrderServiceImpl도 동일하게 설계)

* 결국 설계 변경을 통해 MemberServiceImpl은 MemoryMemberRepository를 의존하지 않는다.
  (OrderServiceImpl은 MemoryMemberRepository, FixDiscountPolicy를 의존하지 않음)

	> 단지 MemberRepository 인터페이스만 의존한다.
	> 또한 서비스 구현체 입장에서 생성자를 통해 어떤 구현 객체가 들어오는지(주입)는 알 수 없다.
	> 생성자를 통해 어떤 구현 객체를 주입될지는 오직 외부(AppConfig)에서 결정된다.
	> 서비스 구현체들은 이제부터 의존관계에 대한 고민은 외부에 맡기고 실행에만 집중할 수 있다.(관심사 밖)

* AppConfig가 객체의 생성과 연결을 담당하게 됨
	> DIP 완성 : MemberServiceImpl은 MemberRepository인 추상에만 의존, 구체 클래스 몰라도됨.
	> 관심사의 분리 : 객체를 생성하고 연결하는 역할과 실행하는 역할이 명확히 분리됨.

* 세부적으로 AppConfig는 MemoryMemberRepository객체를 생성하고 그 참조값을 MemberServiceImpl 객체를 생성하면서 생성자로 전달함
	> 클라이언트(MemberServiceImpl)입장에서 의존관계를 마치 외부에서 주입하는것 같음
	> 우리는 이를 DI(Dependency Injection) 의존관계, 의존성 주입이라고 말함

* OrderServiceImpl도 동일하다 다만 DiscountPolicy 구현체를 하나 더 생성하는것의 차이만 있고 나머지는 동일


* MeberApp 수정 : 기존에 묵시적 기본생성자를 사용하던 코드들에서 오류가 나므로 수정을 요함
	> 직접적으로 new를 이용해 MemberServiceImpl객체를 생성하고 MemberServiceImpl에서 MemoryMemberRepository를 생성함
	  (순차적으로 생성되는 모양)
	  하지만 이제는 AppConfig.memberService()메소드를 이용해 MemberServiceImpl객체를 MemberService인터페이스 형식으로 받아온다.
	  (이 방법은 AppConfig에서 순차적 생성이 아닌 전부 결정해준다.)

	> 나머지 로직은 동일함

* OrderApp 수정 : 이 또한 위와 동일하게 묵시적 생성자를 사용하던 코드에서 오류가 발생
	> MemberService, OrderService의 구현체들을 AppConfig를 이용해 생성하고 주입 받는다.
	> AppConfig에선 어떤 저장소, 할인정책을 할지 완성시켜놓고 한번에 서비스객체로 주입해준다.

* 기존 테스트 코드도 수정 요함 : 기본생성자의 사용으로 인해 오류 발생 
	> AppConfig를 이용해 테스트 동작 전에 서비스 객체를 참조시켜야함
	> 따라서 @BeforeEach를 이용 : 이는 테스트가 실행되기전에 무조건 실행되며 이를 통해 서비스 객체를 할당하고 이후 테스트가 실행됨
		> 여기서는 AppConfig를 이용해 의존성 주입 및 서비스 객체를 필드에 대입한다.

* 모든 관심사를 분리 : DIP를 지켜줌
	> AppConfig를 통해서 관심사를 확실하게 분리했다.
	> AppConfig는 공연 기획자다.
	> AppConfig는 구체 클래스를 선택한다. 배역에 맞는 담당 배우를 선택한다. 애플리케이션이 어떻게
	  동작해야 할지 전체 구성을 책임진다.
	> 이제 각 배우들은 담당 기능을 실행하는 책임만 지면 된다.
	> OrderServiceImpl 은 기능을 실행하는 책임만 지면 된다. : 개발할때도 인터페이스만 보고 개발하면 됨(구체클래스가 어떨지 고민X)

* 다음 시간에는 AppConfig의 문제점과 더 나은 방향으로의 리팩터링을 배워보자





< --------------------------- AppConfig 리팩터링 --------------------------- >
* 현재 AppConfig를 보면 "중복"이 있고, "역할"에 따른 "구현"이 잘 안보인다. : 설정(구성)정보에선 이렇게 한눈에 보이는것이 중요하다.
* 따라서 아래와 같이 변경함
public class AppConfig {
        
            // 멤버 서비스 역할
            public MemberService memberService() {
                return new MemberServiceImpl(memberRepository());
            }
        
            // 저장소 역할 : 저장소 변경시 아래 코드만 변경하면 된다.
            private MemberRepository memberRepository() {
                return new MemoryMemberRepository();
            }
        
            // 주문 서비스 역할
            public OrderService orderService() {
                return new OrderServiceImpl(memberRepository(), discountPolicy());
            }
        
            // 할인 정책 역할 : 정책 변경시 아래 코드만 변경하면 됨
            public DiscountPolicy discountPolicy() {
                return new FixDiscountPolicy();
            }
        
        }

* 위 방식의 큰 장점은 각 메소드 명을 통해 역할이 전부 드러나고, 각 서비스에 대한 구현과 주입되는 저장소, 정책은 다른 메소드가 담당하므로
  변경 시 정책, 저장소 코드만 변경하면 됨
	> 이렇게 해서 설계에 대한 그림이 구성정보에 그대로 드러남 (역할이 나오고, 역할에 대한 구현이 한눈에 들어옴)

* 이렇게 하게 되면 후에 new MemoryMemberRepository() 이 부분이 중복 제거되었다. 이제 MemoryMemberRepository 를
  다른 구현체로 변경할 때 한 부분만 변경하면 된다. DiscountPolicy도 변경되었을때 한 부분만 변경하면 된다.

* 즉 AppConfig를보면 역할과 구현클래스가 한눈에 들어오며, 애플리케이션 전체 구성이 어떻게 되어있는지 빠르게 파악할 수 있다.


* 다음 시간에 정액할인정책을 정률할인정책으로 변경해보자





< --------------------------- 새로운 구조와 할인 정책 적용 --------------------------- >
* 이전시간에 만든 새로운 구조에서 새로운 할인 정책을 적용해보자 (RateDiscountPolicy)
* AppConfig 구조가 등장하면서 AppConfig만 변경하면 된다.
	> AppConfig의 등장으로 애플리케이션이 크게 사용 영역과, 객체를 생성하고 구성(Configuration)하는 영역으로 분리됨

* 따라서 할인정책을 변경하게되면 AppConfig즉 구성영역의 코드만 변경되고, 사용영역의 코드는 전혀 변경될 필요가 없다.
	> FixDiscountPolicy -> RateDiscountPolicy 변경시 구성영역만 영향받고, 사용 영역 영향 X
	> 이제 할인 정책을 변경해도, 애플리케이션의 구성 역할을 담당하는 AppConfig만 변경하면 된다. 
	  클라이언트 코드인 OrderServiceImpl 를 포함해서 사용 영역의 어떤 코드도 변경할 필요가 없다
	> 만약 AppConfig를 xml로 작성하면 정말 자바코드 변경없이 사용할 수 있다.

* 이렇게 되면서 DIP, OCP가 지켜졌다. FixDiscount -> RateDiscount 변경 시
	> OrderServiceImpl에서 클라이언트 코드는 추상화에 의존하고 있다. : DIP
	> 정책을 확장했지만 구성영역만 코드가 변경하면 되고 클라이언트 코드는 손댈 필요가 없다.
	  따라서 확장에는 열려있지만 변경에는 닫혀있다. : OCP

* 다음시간에는 지금까지 배운것을 정리해보자





< --------------------------- 전체 흐름 정리 --------------------------- >
* 새로운 할인 정책을 개발
	> 다형성 덕분에 새로운 정률 할인 정책 코드를 추가로 개발하는 것 자체는 아무 문제가 없음

* 하지만 새로운 할인 정책 적용에서 문제점이 있다.
	> 1. 클라이언트 코드인 주문서비스 구현체(OrderServiceImpl)도 함께 변경해야함 -> OCP위반
	> 2. 주문서비스 클라이언트가 인터페이스(DiscountPolicy)뿐 아니라 구체 클래스(FixDiscountPolicy도 함꼐 의존함) -> DIP위반

* 따라서 관심사를 분리함
	> 애플리케이션을 하나의 공연으로 봄
	> 기존에는 클라이언트가 의존하는 서버구현 객체를 직접 생성하고 실행함
		> 남자 배우가 공연뿐 아니라 배우 초빙역할도 담당함
	> 공연 구성, 배우 섭외등을 지정하는 별도의 공연기획자 필요
	> 공연 기획자인 AppConfig가 등장함
	> AppConfig는 애플리케이션의 전체 동작 방식을 구성(Config)하기 위해, 구현 객체를 생성하고 연결하는 책임을 가짐
	> 따라서 클라이언트 객체는 자신의 역할을 실행하는 것만 집중, 권한이 줄어듬(책임이 명확해짐)

* AppConfig 리팩터링
	> 구성 정보에서 역할과 구현을 명확하게 분리
	> 역할이 잘 들어남
	> 중복 제거

* 새로운 구조와 할인 정책 적용
	> 정액 할인 정책 -> 정률 할인 정책으로 변경
	> AppConfig의 등장으로 애플리케이션이 사용 영역과 객체를 생성하고 구성하는 영역으로 분리됨
	> 할인정책을 변경해도 AppConfig에 구성영역만 변경하면 되고, 사용 영역은 변경할 필요가 없어짐, 따라서 클라이언트 코드인
	  OrderServiceImpl도 변경하지 않음






< --------------------------- 좋은 객체 지향 설계의 5가지 원칙의 적용 --------------------------- >
* 여기서는 3가지 (SRP, OCP, DIP)가 적용 된다.

* SRP 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 한다.
	> 클라이언트 객체는 직접 구현 객체를 생성하고, 연결, 실행하는 다양한 책임을 가졌지만
	> SRP를 따르며 관심사를 분리함
	> 구현 객체를 생성하고 연결하는 책임은 AppConfig가 담당
	> 클라이언트 객체는 실행하는 책임만 담당

* DIP 의존 관계 역전 원칙 : 추상화에 의존해야지, 구현체에 의존하면 안된다.
	> 의존성 주입(DI)은 이 원칙을 따르는 방법 중 하나
	> 새로운 할인 정책 적용시 클라이언트 코드도 변경됨 : 추상화 인터페이스와 구체화 구현 클래스도 같이 의존하고 있었기 때문
	> 따라서 클라이언트 코드가 추상화만 의존하도록 했으나 클라이언트는 인터페이스 만으로 아무것도 할 수 없음(NullPointExceptino)
	> AppConfig가 FixDiscountPolicy 객체 인스턴스를 클라이언트 코드 대신 생성해 클라이언트 코드에 의존관계를 주입함 따라서 DIP 지켜짐

* OCP 개방 폐쇄 원칙 : 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
	> 다형성 사용하고 클라이언트가 DIP를 지킴 : 이렇게 되면 OCP가 적용될 가능성이 생김
	> 애플리케이션을 사용 영역과 구성 영역으로 나눔
	> AppConfig가 의존 관계를 FixDiscountPolicy -> RateDiscountPolicy로 변경해서 클라이언트 코드에 주입하므로 클라리언트 코드는 변경하지 않아도됨
	> "소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀있다."
































































