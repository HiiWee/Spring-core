< --------------------------- 좋은 객체 지향 프로그래밍이란? --------------------------- >
* 다형성의 본질
	> 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
	> 다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야함
	> 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다. --> 가장 큰 본질

* 의존하다. : 내가 상대방을 알고있다.

* 스프링과 객체 지향
	> 다형성이 가장 중요하며, 스프링은 이를 극대화해서 이용할 수 있게함
	> Spring의 IoC(제어의역전), DI(의존관계 주입)은 다형성을 활용함, 따라서 역할과 구현을 편리하게 나눌 수 있도록 지원함





< --------------------------- 좋은 객체 지향 설계의 5가지 원칙(SOLID) --------------------------- >
1. SRP(Single Responsibility Principle) 단일 책임 원칙
	> 한 클래스는 하나의 책임만 가져야 한다.
	> 하나의 책임이라는 것은 모호함
		> 클 수도 작을수도
		> 문맥과 상황에 따라 다르다.
	> 중요한 기준은 변경이다.
		> 변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른것(UI변경, 객체의 생성과 사용을 분리)

2. OCP(Open-Closed Principle) 계방-폐쇄 원칙
	> 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
	> 다형성을 활용하면 가능해짐
	> 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능 구현 -- 확장
	> 지금까지 배운 역할과 구현의 분리 생각하면 답이 나옴

	> 문제점
		> MemberService 클라이언트가 구현 클래스를 직접 선택
		> MemberService m = new MemoryMemberRepository(); // 기존코드
		> MemberService m = new JdbcMemberRepository(); // 변경코드
		> 구현 객체를 변경하려면 클라이언트 코드 변경 필요
		> 다형성을 이용했지만 OCP 원칙을 지킬 수 없다.
		> 어떻게 해결?
			> 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요(Spring이 해줌)

3. LSP(Liskov subsitution principle) 리스코프 치환 원칙
	> 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
	> 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원히기 위한 원칙,
	  인터페이스를 구현한 구현체는 믿고 사용하려면 필요

	> 단순히 컴파일 성공을 넘어서는 이야이
		ex) 자동차 인터페이스에서 악셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP위반


4. ISP(Interface Segregation Principle) 인터페이스 분리 원칙
	> 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
	> 자동차 인터페이스 -> 운전, 정비 인터페이스로 분리
	> 사용자 클라이언트 -> 운전자, 정비사 클라이언트로 분리
	> 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
	> 인터페이스가 명확해지고, 대체 가능성이 높아짐

5. DIP(Depnedency Inversion Principle) 의존관계 역전 원칙
	> 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
	> 쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
	> 앞에서 이야기한 역할(ROLE)에 의존하게 해야 한다는 것과 같음, 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경가능함
	  구현체에 의존하게 되면 변경이 아주 어려워진다.

	> OCP에서 설명한 MemberService는 인터페이스에 의존하지만 동시에 구현 클래스도 의존한다.
	> MemberService 클라이언트가 구현 클래스를 직접 선택
		> MemberRepository m = new MemoryMemberRepository();
	> 이는 DIP 위반

* 정리
	> 객체 지향의 핵심은 다형성
	> 다형성 만으로는 쉽게 부품을 갈아 끼우듯 개발할 수 없다.
	> 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
	> 다형성 만으로는 OCP, DIP를 지킬 수 없다.
	> 따라서 무엇인가 더 필요하다. ----> Spring





< --------------------------- 객체 지향 설계와 스프링 --------------------------- >
* 스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원
	> DI(Dependency Injection) : 의존관계, 의존성 주입
	> DI 컨테이너 제공

* 클라이언트 코드의 변경없이 기능 확장
* 쉽게 부품을 교체하듯이 개발

* 순수하게 자바로 OCP, DIP원칙들을 지키면서 개발을 해보면, 결국 스프링 프레임워크를 만들게됨(더 정확히 DI 컨테이너)

* 정리
	> 모든 설계에 역할과 구현을 분리하자.
	> 어플리케이션 설계도 공연을 설계하듯 배역만 만들고, 배우는 언제든지 유연하게 변경할 수 있도록 만드는것이 좋은 객체 지향 설계
	> 이상적으로는 모든 설계에 인터페이스를 부여하자
		> 인터페이스를 먼저 만들게 되면 구현체에 대한 선택을 최대한 미룰 수 있음

* 실무적인 고민을 해보자
	> 인터페이스를 도입하면 추상화라는 비용이 발생한다.
		> 코드만 가지고 인터페이스를 보면 구현체가 뭔지 한번 더 들여봐야함
* 추천방법
	> 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법이다.





< --------------------------- 비즈니스 요구사항과 설계 --------------------------- >
* 아래와 같은 요구사항이 있다.

* 회원
	> 회원을 가입하고 조회할 수 있다.
	> 회원은 일반과 VIP 두 가지 등급이 있다.
	> 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. (미확정)
		(인터페이스로 일단 구현)
* 주문과 할인 정책
	> 회원은 상품을 주문할 수 있다.
	> 회원 등급에 따라 할인 정책을 적용할 수 있다.
	> 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있다.)
	> 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다.
	  최악의 경우 할인을 적용하지 않을 수 도 있다. (미확정)


* 요구사항에서 회원 데이터, 할인 정책은 지금 결정하기 어려운 부분, 그렇다고 결정될때까지 기다릴 수 는 없다.
  따라서 객체지향 설계 방법을 이용해 만들자





< --------------------------- 회원 도메인 설계 --------------------------- >
* 현재 회원 저장소는 아직 자체 DB를 이용할지 외부 시스템과 연동할지 정해지지 않음
	> 먼저 인터페이스를 우선 만듦 이후 구현체는 (메모리 회원 저장소, DB 회원 저장소, 외부 시스템 연동 회원 저장소)로 나뉨
	> 하지만 자체 DB로 할지 외부 시스템 연동을 할지 정해지지 않음
	> 따라서 메모리 회원 저장소를 이용하는데 이는 자바 코드로 회원 객체를 넣다 뺐다 할 수 있는 것을 만들이 일단 개발 진행(실행, 테스트 모두 가능)
	  (후에 변경 가능)

* 개념적 그림은 회원 도메인 협력관계, 회원 클래스 다이어그램, 회원 객체 다이어그램 이렇게 그림이 총 3개가 만들어진다.
	> 회원 도메인 협력관계 : 기획자들도 볼 수 있는 그림
	> 회원 클래스 다이어그램 : 도메인 협력관계를 바탕으로 개발자들이 만듦
	> 회원 객체 다이어그램 : 실제 서버를 실행하지 않고 클래스들만 분석해서 볼 수 있음
	  (다만 구현체(메모리 멤버 레포, 디비 레포)들은 동적으로 결정된다, 따라서 객체 다이어그램이 따로 존재함
	   이는 실제 new로 연결된 인스턴스들 끼리의 참조를 보여줌)





< --------------------------- 회원 도메인 개발 --------------------------- >

* 등급을 위한 Grade enum 클래스 정의
* ID, 이름, 등급을 가진 Member 엔티티 정의
* 멤버를 저장하고, id를 통해 멤버를 찾는 인터페이스 정의 : MemberRepository
* MemberRepository를 구현하는 구현체인 MemoryMemberRepository를 정의
* 회원가입, 회원조회 서비스를 가진 서비스 회원 서비스 인터페이스 정의 : MemberService
* MemberService를 구현하는 구현체인 MemberServiceImpl 정의 : 구현체가 하나만 있을경우 관례상 인터페이스명 뒤에 Impl을 붙임





< --------------------------- 회원 도메인 실행과 테스트 --------------------------- >
* 간단한 회원 도메인의 인스턴스간 참조 그림은 회원 객체 다이어그램과 동일하게 된다.
	> 회원 클래스 다이어그램 : 정적인 다이어그램
	> 회원 객체 다이어그램 : 동적인 다이어그램

* 멤버를 만들어 임의로 ID, 이름, 등급을 부여하고 가입을 시킨다.
  이후 findMember 변수로 멤버 서비스의 findMember()메소드를 이용해 가입한 객체를 받아오고
  최종적으로 기존의 member의 이름과, findMember에 저장된 객체의 멤버 이름을 비교하는 로직을 만든다.

public class MemberApp {
    public static void main(String[] args) {
        MemberService memberService = new MemberServiceImpl();
        Member member = new Member(1L, "memberA", Grade.VIP);

        Member findMember = memberService.findMember(1L);
        System.out.println("new member = " + member.getName());
        System.out.println("find Member = " + findMember.getName());
    }
}

* 하지만 어플리케이션 로직으로 main을 이용한 테스트는 좋은 방법이 아님. --> JUnit test를 이용한다.
	> 눈으로 출력된 콘솔의 결과를 보는것이 아님
	> 다른코드를 추가 했을때 오류 나는것도 캐치하기 쉬움
	> 테스트 작성 방법은 필수 (공부하자)

* 회원 도메인은 설계의 문제점이 있다.
	> 만약 다른 저장소로 변경하고자 한다면 OCP원칙을 준수하지 못함
	> 또한 DIP는 잘 지키고 있을까?
	> 즉 의존관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점이 있다.
		> 주문까지 만들고 나서 문제점과 해결 방안을 설명해보자





































