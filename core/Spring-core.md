### < --------------------------- 좋은 객체 지향 프로그래밍이란? --------------------------- >
* #### 다형성의 본질
  > * 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
  > * 다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야함
  > * 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다. --> 가장 큰 본질

  **[의존하다]** : 내가 상대방을 알고있다.

* #### 스프링과 객체 지향
  > * 다형성이 가장 중요하며, 스프링은 이를 극대화해서 이용할 수 있게함
  > * Spring의 IoC(제어의역전), DI(의존관계 주입)은 다형성을 활용함, 따라서 역할과 구현을 편리하게 나눌 수 있도록 지원함

<br>
<br>
<br>

### < --------------------------- 좋은 객체 지향 설계의 5가지 원칙(SOLID) --------------------------- >
#### 1. SRP(Single Responsibility Principle) 단일 책임 원칙
> * 한 클래스는 하나의 책임만 가져야 한다.
> * 하나의 책임이라는 것은 모호함
> * 클 수도 작을수도
> * 문맥과 상황에 따라 다르다.
> * 중요한 기준은 변경이다.
> * 변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른것(UI변경, 객체의 생성과 사용을 분리)

#### 2. OCP(Open-Closed Principle) 계방-폐쇄 원칙
> * 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
> * 다형성을 활용하면 가능해짐
> * 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능 구현 -- 확장
> * 지금까지 배운 역할과 구현의 분리 생각하면 답이 나옴

**[문제점]**
> * MemberService 클라이언트가 구현 클래스를 직접 선택
> ``` java
   > MemberService m = new MemoryMemberRepository(); // 기존코드
   > MemberService m = new JdbcMemberRepository(); // 변경코드  
   > ``` 
> * 구현 객체를 변경하려면 클라이언트 코드 변경 필요
> * 다형성을 이용했지만 OCP 원칙을 지킬 수 없다.

**[어떻게 해결?]**
> * 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요(Spring이 해줌)

#### 3. LSP(Liskov subsitution principle) 리스코프 치환 원칙
> * 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
> *  다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원히기 위한 원칙,
     인터페이스를 구현한 구현체는 믿고 사용하려면 필요
> * 단순히 컴파일 성공을 넘어서는 이야기   
    ex) 자동차 인터페이스에서 악셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP위반


#### 4. ISP(Interface Segregation Principle) 인터페이스 분리 원칙
> * 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
> * 자동차 인터페이스 -> 운전, 정비 인터페이스로 분리
> * 사용자 클라이언트 -> 운전자, 정비사 클라이언트로 분리
> * 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
> * 인터페이스가 명확해지고, 대체 가능성이 높아짐

#### 5. DIP(Depnedency Inversion Principle) 의존관계 역전 원칙
> * 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
> * 쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
> * 앞에서 이야기한 역할(ROLE)에 의존하게 해야 한다는 것과 같음, 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경가능함
    구현체에 의존하게 되면 변경이 아주 어려워진다.

> * OCP에서 설명한 `MemberService`는 인터페이스에 의존하지만 동시에 구현 클래스도 의존한다.
> * `MemberService` 클라이언트가 구현 클래스를 직접 선택
> ``` java
   > MemberRepository m = new MemoryMemberRepository();
   > ```
> * 이는 DIP 위반

* #### 정리
  > * 객체 지향의 핵심은 다형성
  > * 다형성 만으로는 쉽게 부품을 갈아 끼우듯 개발할 수 없다.
  > * 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
  > * 다형성 만으로는 OCP, DIP를 지킬 수 없다.
  > * 따라서 무엇인가 더 필요하다. ----> Spring

<br>
<br>
<br>

### < --------------------------- 객체 지향 설계와 스프링 --------------------------- >
* #### 스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원
  > * DI(Dependency Injection) : 의존관계, 의존성 주입
  > * DI 컨테이너 제공

* #### 클라이언트 코드의 변경없이 기능 확장
* #### 쉽게 부품을 교체하듯이 개발

* #### 순수하게 자바로 OCP, DIP원칙들을 지키면서 개발을 해보면, 결국 스프링 프레임워크를 만들게됨(더 정확히 DI 컨테이너)

* #### 정리
  > * 모든 설계에 역할과 구현을 분리하자.
  > * 어플리케이션 설계도 공연을 설계하듯 배역만 만들고, 배우는 언제든지 유연하게 변경할 수 있도록 만드는것이 좋은 객체 지향 설계
  > * 이상적으로는 모든 설계에 인터페이스를 부여하자
  > * 인터페이스를 먼저 만들게 되면 구현체에 대한 선택을 최대한 미룰 수 있음

* #### 실무적인 고민을 해보자
  > * 인터페이스를 도입하면 추상화라는 비용이 발생한다.
  > * 코드만 가지고 인터페이스를 보면 구현체가 뭔지 한번 더 들여봐야함
* #### 추천방법
  > * 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법이다.

<br>
<br>
<br>

### < --------------------------- 비즈니스 요구사항과 설계 --------------------------- >
* #### 아래와 같은 요구사항이 있다.

* #### 회원
  > * 회원을 가입하고 조회할 수 있다.
  > * 회원은 일반과 VIP 두 가지 등급이 있다.
  > * 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. (미확정)   
      (인터페이스로 일단 구현)
* #### 주문과 할인 정책
  > * 회원은 상품을 주문할 수 있다.
  > * 회원 등급에 따라 할인 정책을 적용할 수 있다.
  > * 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있다.)
  > * 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다.
      최악의 경우 할인을 적용하지 않을 수 도 있다. (미확정)


* #### 요구사항에서 회원 데이터, 할인 정책은 지금 결정하기 어려운 부분, 그렇다고 결정될때까지 기다릴 수 는 없다.
  따라서 객체지향 설계 방법을 이용해 만들자

<br>
<br>
<br>

### < --------------------------- 회원 도메인 설계 --------------------------- >
* #### 현재 회원 저장소는 아직 자체 DB를 이용할지 외부 시스템과 연동할지 정해지지 않음
  > * 먼저 인터페이스를 우선 만듦 이후 구현체는 (메모리 회원 저장소, DB 회원 저장소, 외부 시스템 연동 회원 저장소)로 나뉨
  > * 하지만 자체 DB로 할지 외부 시스템 연동을 할지 정해지지 않음
  > * 따라서 메모리 회원 저장소를 이용하는데 이는 자바 코드로 회원 객체를 넣다 뺐다 할 수 있는 것을 만들이 일단 개발 진행(실행, 테스트 모두 가능)   
      (후에 변경 가능)

* #### 개념적 그림은 회원 도메인 협력관계, 회원 클래스 다이어그램, 회원 객체 다이어그램 이렇게 그림이 총 3개가 만들어진다.
  > * 회원 도메인 협력관계 : 기획자들도 볼 수 있는 그림
  > * 회원 클래스 다이어그램 : 도메인 협력관계를 바탕으로 개발자들이 만듦
  > * 회원 객체 다이어그램 : 실제 서버를 실행하지 않고 클래스들만 분석해서 볼 수 있음   
      (다만 구현체(메모리 멤버 레포, 디비 레포)들은 동적으로 결정된다, 따라서 객체 다이어그램이 따로 존재함
      이는 실제 `new`로 연결된 인스턴스들 끼리의 참조를 보여줌)

<br>
<br>
<br>

### < --------------------------- 회원 도메인 개발 --------------------------- >

* #### 등급을 위한 `Grade enum` 클래스 정의
* #### ID, 이름, 등급을 가진 `Member` 엔티티 정의
* #### 멤버를 저장하고, id를 통해 멤버를 찾는 인터페이스 정의 : `MemberRepository`
* #### `MemberRepository를` 구현하는 구현체인 `MemoryMemberRepository`를 정의
* #### 회원가입, 회원조회 서비스를 가진 서비스 회원 서비스 인터페이스 정의 : `MemberService`
* #### `MemberService`를 구현하는 구현체인 `MemberServiceImpl` 정의 : 구현체가 하나만 있을경우 관례상 인터페이스명 뒤에 `Impl`을 붙임

<br>
<br>
<br>

### < --------------------------- 회원 도메인 실행과 테스트 --------------------------- >
* #### 간단한 회원 도메인의 인스턴스간 참조 그림은 회원 객체 다이어그램과 동일하게 된다.
  > * 회원 클래스 다이어그램 : 정적인 다이어그램
  > * 회원 객체 다이어그램 : 동적인 다이어그램

* #### 멤버를 만들어 임의로 ID, 이름, 등급을 부여하고 가입을 시킨다.
  > * 이후 findMember 변수로 멤버 서비스의 findMember()메소드를 이용해 가입한 객체를 받아오고
  > * 최종적으로 기존의 member의 이름과, findMember에 저장된 객체의 멤버 이름을 비교하는 로직을 만든다.

  > ```java
  >  public class MemberApp {
  >     public static void main(String[] args) {
  >         MemberService memberService = new MemberServiceImpl();
  >         Member member = new Member(1L, "memberA", Grade.VIP);
  >  
  >         Member findMember = memberService.findMember(1L);
  >         System.out.println("new member = " + member.getName());
  >         System.out.println("find Member = " + findMember.getName());
  >     }
  >  }
  > ```

* #### 하지만 어플리케이션 로직으로 main을 이용한 테스트는 좋은 방법이 아님. --> `JUnit test`를 이용한다.
  > * 눈으로 출력된 콘솔의 결과를 보는것이 아님
  > * 다른코드를 추가 했을때 오류 나는것도 캐치하기 쉬움
  > * 테스트 작성 방법은 필수 (공부하자)

* #### 회원 도메인은 설계의 문제점이 있다.
  > * 만약 다른 저장소로 변경하고자 한다면 OCP원칙을 준수하지 못함
  > * 또한 DIP는 잘 지키고 있을까?
  > * 즉 의존관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점이 있다.
  > * 주문까지 만들고 나서 문제점과 해결 방안을 설명해보자

<br>
<br>
<br>

### < --------------------------- 주문과 할인 도메인 설계 --------------------------- >
* #### 주문과 할인 정책은 다음과 같다.
  > * 회원은 상품을 주문할 수 있다.
  > * 회원 등급에 따라 할인 정책을 적용할 수 있다.
  > * 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있다.)
  > * 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다. 최악의 경우 할인을 적용하지 않을 수 도 있다. (미확정)

* #### 회원의 주문 과정은 아래와 같다.
  > 1. 주문 생성: 클라이언트는 주문 서비스에 주문 생성을 요청한다.
  > 2. 회원 조회: 할인을 위해서는 회원 등급이 필요하다. 그래서 주문 서비스는 회원 저장소에서 회원을 조회한다.
  > 3. 할인 적용: 주문 서비스는 회원 등급에 따른 할인 여부를 할인 정책에 위임한다.
  > 4. 주문 결과 반환: 주문 서비스는 할인 결과를 포함한 주문 결과를 반환한다

* #### 할인 정책과 회원 저장소(인터페이스)는 역할과 구현을 분리해서 언제나 유연하게 구현 객체를 조립하고 변경할 수 있게 설계해야한다.

* #### 클래스 다이어그램은 정적이며 객체 다이어그램은 동적이다.
  > * 우리는 할인정책 구현체를 정액 할인 정책(등급 상관없이 일정금액 할인)과 정률 할인 정책(%단위의 할인)
      2개를 임시로 구현체를 만들것이므로 2개의 주문 도메인 객체 다이어그램이 생성된다.

<br>
<br>
<br>

### < --------------------------- 주문과 할인 도메인 개발 --------------------------- >
* #### 주문과 할인 도메인을 개발해보자

* #### 우선 할인 정책 인터페이스를 만들어야 함
  > * 할인정책 인터페이스는 `discount` 메소드를 가지는데 이는 할인 대상의 할인 금액을 반환한다.
  > * 현재는 정액할인정책만 구현체로 두었고 `Grade가 VIP`일때 1000원 할인된 가격을 반환한다.

* #### 정책설정까지 완료되었고 `Order` 객체를 생성하자
  > *` Order 객체`는 `memberId`, `itemName`, `itemPrice`, `discountPrice`를 필드로 가진다.
  > * 생성자와 기본적인 Getter and Setter를 생성하고 비즈니스 로직 처리를 위한 계산된 할인가격을 구하는 메소드 `calculatePrice()` 생성

* #### 주문 서비스 인터페이스 를 생성하자
  > * `createOrder()`는 주문을 생성하는 메소드이며 주문 도메인에서 정한 `memberId`, `itemName`, `itemPrice`를 인자로 가진다.
  > * 결과값으로 주문결과를 반환한다. (`Order객체`)

**[핵심 로직]**
* #### 주문 서비스 구현체 : OrderServiceImpl 구현체 생성 및 구현 메소드createOrder()의 주문 처리 순서
  > 1. 주문생성을 위해서 `createOrder()`메소드를 구현하고
  > 2. 회원조회를 위해 `MemberRepository` 변수를 필드로 둔다. : 회원 저장소에서 `memberId`를 통해 `Member`를 식별하고 가져온다.
  > 3. 할인적용을 위해 `DiscountPolicy` 변수를 필드로 둔다. : 할인 정책은 `Member` 객체와 상품가격을 넘겨주어 할인가격을 가져온다.   
       (여기서 `OrderService`는 할인가격이 정해지는것에 관심이 없다 모든 할인관련은 전적으로 맡김 따라서 단일책임원칙이 성립한다.)   
       (추가로 `Member` 객체를 넘기는것과, `Grade`값 자체를 넘기는것은 차이가 없으나 프로젝트 상황따라 유동적으로 정한다)
  > 4. 마지막으로 `new Order()`로 주문객체를 생성하고 생성된 주문결과를 반환해준다.

**[코드의 주석과 연관해서 공부]**

<br>
<br>
<br>

### < --------------------------- 주문과 할인 도메인 실행과 테스트 --------------------------- >
* #### main 클래스를 만들자 : `OrderApp`
  > * 임의로 멤버를 생성하고 가입하고
  > * 임의로 상품의 주문을 생성하고
  > * 결과로 출력하면(```toString()```) 정상적으로 할인정책률이 적용된다.

* #### Test 클래스를 만들자
  > * 임의로 멤버를 생성하고 가입하고
  > * 임의로 상품의 주문을 생성하고
  > * 여기서 `Assertions`를 이용해 정말 할인률이 1000원인지 테스트를 한다.
  > * 이렇게 단위테스트를 하고나면 시간이 매우 짧게 소요됨

* #### 수천개의 단위테스트도 매우 짧은시간에 테스트 할 수 있다.
  > * 따라서 테스트는 매우 중요!! 꼭 공부하자
  > * 여기서 말하는 단위테스트는 Spring이나 다른 컨테이너의 도움 없이 순수한 자바코드로 작성하고 테스트 하는것을 말한다.

* #### 이 코드에서 유의할점 `MemberService.join()`으로 가입할때 사용되는 `HashMap`과 `OrderService.createOrder()`시 사용되는 `HashMap`은 서로 다른 ```MemberRepository```의 인스턴스를 2개 가진다 유의하자.

* 그렇다면 정액할인률 정책을 정률 할인 정책으로 변경됐을때 정말 객체지향적으로 설계되었을까?
  ( 다형성을 잘 활용하고, 역할과 구현을 잘 분리했다. 그런데 과연 정률 할인 정책으로 깔끔하게 변경할 수 있을까?)

<br>
<br>
<br>

### < --------------------------- 새로운 할인 정책 개발 --------------------------- >
* #### 기획자의 새로운 요구사항
**[기획자]**
> 서비스 오픈 직전에 할인 정책을 지금처럼 고정 금액 할인이 아니라   
좀 더 합리적인 주문 금액당 할인하는 `정률% 할인`으로 변경하고 싶어요.   
예를 들어서 기존 정책은 VIP가 10000원을 주문하든 20000원을 주문하든 항상 1000원을 할인했는데,   
이번에 새로 나온 정책은 10%로 지정해두면 고객이 10000원 주문시 1000원을 할인해주고,   
20000원 주문시에 2000원을 할인해주는 거에요!


**<개발자>**
>객체지향설계 원칙을 준수 했으므로 가능할거라 생각

* #### 따라서 정말 객체지향설계 원칙을 잘 준수했는지 확인해봐야함
  > * 기존에 `DiscountPolicy`를 구현하는 `FixDiscountPolicy`가 존재하므로 `RateDiscountPolicy`만 추가로 개발하면 됨


* #### RateDiscountPolicy 구현
  > * `DiscountPolicy`를 구현하므로 `discount()`메소드를 구현해야함
  > * 등급이 `VIP등급`이면 현재 가격에서 `10%`를 할인하는 로직 구현
  > * 모든 로직은 테스트가 중요하지만 특히나 할인율을 결정하는 로직은 테스트가 매우 중요   
      (command + shift + T 누르면 테스트 클래스 작성됨)

* #### 테스트 코드 작성 : `RateDiscountPolicyTest`
  > * 테스트의 목적은 `VIP등급`이면 정말 `10%`로의 할인이 되는지 확인해야함
  > * 따라서 `@Test 어노테션` 뿐 아니라 테스트의 이름을 정하는 `@DisplayName("[TEST NAME]")`을 같이 이용한다.

  > * 임의로 `VIP등급`의 멤버를 생성하고 `RateDiscountPolicy.discount()`메소드로 멤버를 넘겨준다
  > * 이후 `Assertions.assertThat(할인금액).isEqualTo(예상금액)`을 이용해 검증한다.

* #### 테스트 코드는 성공 테스트도 중요하지만 실패 테스트도 매우 중요하다.
  > * 새로운 실패 테스트의 이름은` @DisplayName("VIP가 아니면 할인이 적용되지 않아야 한다.")`
  > * 기존의 성공 테스트에서 등급을 `BASIC`으로 두고 실행하면 테스트 오류 발생 --> 정상 동작
  > * 이때의 테스트 메시지는 아래와 같다.
  > * `Expected :1000`
  > * `Actual   :0`		>> 기대한 값은 1000원이지만 실제값은 0원이라는 오류 출력

  > * 혹은 `Assertions.assertThat(할인금액).isEqualTo(0)`으로 두어 `VIP등급`이 아니면 0원이다를 검증할 수 도 있다.

* #### static import
  > * 자바 클래스의 static 메소드는 클래스에 대한 인스턴스의 생성없이 메소드를 사용할 수 있습니다.
  > * 기존에는 assertThat을 사용하기 위해 클래스명.메소드로 이용했지만 `static import`를 하면 메소드의 이름으로만 사용할 수 있다.

  > * `import static org.assertj.core.api.Assertions.*;`


* #### 실무에서의 할인정책 로직은 쉽지 않다. (특히 돈 관련 된 로직은 매우 많은 테스트를 가짐)
  > * 다만 위와 같은 상황은 설계과 잘 되어있기 때문에 쉽게 테스트 할 수 있음   
      (단일 책임 원칙이 잘 지켜져서 할인과 관련된 부분은 할인 부분만 테스트하므로)

* #### 이제 RateDiscountPolicy를 실제 적용을 해보자

<br>
<br>
<br>

### < --------------------------- 새로운 할인 정책 적용과 문제점 --------------------------- >
* #### 새로운 할인정책을 적용하기 위해 `OrderServiceImpl의` 코드를 수정한다.
  > ```java 
  > private final DiscountPolicy discountPolicy = new RateDiscountPolicy();	
  > // 새로운 할인정책 : 정률할인정책 적용 
  > ```

**[문제점]**
* #### 할인정책을 변경하려면 클라이언트인 OrederServiceImpl의 코드를 고쳐야한다.
  > * 역할과 구현 충실히 분리 O
  > * 다형성 활용, 인터페이스와 구현 객체 분리 O
  > * OCP, DIP 같은 객체지향 설계 원칙을 준수? X
  > * DIP :  OrderServiceImple은 DiscountPolicy인터페이스만 의존하는것이 아니라    
      구현체인 Fix, RateDiscountPolicy도 동시에 의존함 따라서 DIP를 위반함
  > * OCP : 변경하지 않고 확장할 수 있을것 같지만 기능을 확장해서 변경하려면   
      클라이언트(OrderServiceImpl)의 코드에 직접적으로 영향을준다 따라서 OCP를 위반함

* #### 이것을 해결하기 위해 인터페이스에만 의존하도록 설계하면
  > * `private DiscountPolicy discounPolicy;` (final은 객체를 생성해야 작성가능)
  > * 위와 같이 작성하면 인터페이스만 의존하지만 `NullPointException`이 발생한다.

* #### 결국 이것을 해결하기 위해선 누군가가 클라이언트(`OrderServiceImpl`)에 `DiscountPolicy의` 구현 객체를 대신 생성하고 주입해야함

<br>
<br>
<br>

### < --------------------------- 관심사의 분리 --------------------------- >
* #### 애플리케이션을 로미오와 줄리엣 공연으로 보자
* #### 우리는 지금까지 로미오 역할(인터페이스)을 하는 디카프리오(구현체)가 줄리엣 역할(인터페이스)을 하는 여자 주인공(구현체)를 직접 초빙하고 있다.

* #### 즉 디카프리오가 공연과 여자 주인공을 공연에 초빙하는 다양한 책임을 가지게 된다.

* #### 관심사를 분리하자
  > * 배우는 본인의 역할인 배역 수행에만 집중 해야함
  > * 따라서 디카프리오는 어떤 상대역이와도 똑같이 공연해야함
  > * 공연구성, 담당배우 섭외, 역할 맞는 배우 지정과 같은 책임은 별도의 공연기획자가 담당해야한다.
  > * 따라서 공연 기획자를 만들어서 배우와 기획자의 책임을 분리해야함

* #### 애플리케이션의 전체 동작 방식을 구성(config)하기 위해, 구현 객체를 생성하고, 연결하는 책임을 가지는 별도의 설정 클래스를 만들어야함
  > * 어플리케이션 전반에 대한 운영을 책임진다.

* #### `AppConfig` 만들기
  > * 현재 만들어진 서비스들을 생성하고 반환해준다. 다만 생성자 주입을 이용해 서비스 구현체에 필요한 의존성을 주입한다.
  > * 이렇게 `AppConfig`가 만들어지면 서비스 구현체는 기존에 new를 통해 의존성을 생성하는 코드가 사라지고 오로지 인터페이스에만 의존하게 된다.
  > * 즉 DIP가 성립된다.

**[AppConfig]**
```java
        // 애플리케이션 전체를 설정하고 구성함
// 구현 객체를 생성하고, 연결하는 책임을 가짐
public class AppConfig {

    // memberService를 만들어보자
    public MemberService memberService() {
        return new MemberServiceImpl(new MemoryMemberRepository());
    }

    public OrderService orderService() {
        return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy());
    }

}
```

**[MemberServiceImpl]**
```java
        public class MemberServiceImpl implements MemberService {

    private final MemberRepository memberRepository;
    // AppConfig를 통해 레포지토리의 구현체를 참조하고, 인터페이스에만 의존함
    // 어떤 레포지토리가 들어올지 모르고, 상관쓰지 않아도 됨
    public MemberServiceImpl(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    @Override
    public void join(Member member) {
        memberRepository.save(member);
    }

    @Override
    public Member findMember(Long memberId) {
        return memberRepository.findById(memberId);
    }
}
```



> 즉, AppConfig는 애플리케이션의 실제 동작에 필요한 구현 객체를 생성함   
> 또한, AppConfig는 생성한 객체 인스턴스의 참조(레퍼런스)를 생성자를 통해서 주입(연결)해준다.   
(OrderServiceImpl도 동일하게 설계)

* #### 결국 설계 변경을 통해 `MemberServiceImpl`은 `MemoryMemberRepository를` 의존하지 않는다. (`OrderServiceImpl`은 `MemoryMemberRepository`, `FixDiscountPolicy를` 의존하지 않음)

  > * 단지 `MemberRepository` 인터페이스만 의존한다.
  > * 또한 서비스 구현체 입장에서 생성자를 통해 `어떤 구현 객체가 들어오는지(주입)`는 알 수 없다.
  > * 생성자를 통해 어떤 구현 객체를 주입될지는 오직 `외부(AppConfig)에서 결정`된다.
  > * 서비스 구현체들은 이제부터 의존관계에 대한 고민은 외부에 맡기고 `실행에만 집중`할 수 있다.(관심사 밖)

* #### `AppConfig가` 객체의 생성과 연결을 담당하게 됨
  > * DIP 완성 : `MemberServiceImpl은` `MemberRepository인` 추상에만 의존, 구체 클래스 몰라도됨.
  > * 관심사의 분리 : 객체를 생성하고 연결하는 역할과 실행하는 역할이 명확히 분리됨.

* #### 세부적으로 `AppConfig는` `MemoryMemberRepository객체를` 생성하고 그 참조값을 `MemberServiceImpl` 객체를 생성하면서 생성자로 전달함
  > * 클라이언트(`MemberServiceImpl`)입장에서 의존관계를 마치 외부에서 주입하는것 같음
  > * 우리는 이를 `DI(Dependency Injection) 의존관계, 의존성 주입`이라고 말함

* #### `OrderServiceImpl도` 동일하다 다만 `DiscountPolicy` 구현체를 하나 더 생성하는것의 차이만 있고 나머지는 동일


* #### `MeberApp` 수정 : 기존에 묵시적 기본생성자를 사용하던 코드들에서 오류가 나므로 수정을 요함
  > * 직접적으로 new를 이용해 MemberServiceImpl객체를 생성하고 MemberServiceImpl에서 MemoryMemberRepository를 생성함   
      (순차적으로 생성되는 모양)
      하지만 이제는 `AppConfig.memberService()`메소드를 이용해` MemberServiceImpl`객체를 `MemberService인터페이스 형식`으로 받아온다.   
      (이 방법은 `AppConfig에서 순차적 생성이 아닌 전부 결정`해준다.)
  > * 나머지 로직은 동일함

* #### `OrderApp` 수정 : 이 또한 위와 동일하게 묵시적 생성자를 사용하던 코드에서 오류가 발생
  > * MemberService, OrderService의 `구현체`들을 `AppConfig`를 이용해 생성하고 주입 받는다.
  > * AppConfig에선 어떤 저장소, 할인정책을 할지 완성시켜놓고 한번에 서비스객체로 주입해준다.

* #### 기존 테스트 코드도 수정 요함 : 기본생성자의 사용으로 인해 오류 발생
  > * AppConfig를 이용해 테스트 동작 전에 서비스 객체를 참조시켜야함
  > * 따라서 `@BeforeEach`를 이용 : 이는 테스트가 실행되기전에 무조건 실행되며 이를 통해 서비스 객체를 할당하고 이후 테스트가 실행됨
  > * 여기서는 AppConfig를 이용해 `의존성 주입 및 서비스 객체를 필드에 대입`한다.

* #### 모든 관심사를 분리 :` DIP를 지켜줌`
  > * AppConfig를 통해서 관심사를 확실하게 `분리`했다.
  > * AppConfig는 공연 기획자다.
  > * AppConfig는 구체 클래스를 선택한다. 배역에 맞는 담당 배우를 선택한다. 애플리케이션이 어떻게 동작해야 할지 `전체 구성을 책임`진다.
  > * 이제 각 `배우들은 담당 기능을 실행하는 책임`만 지면 된다.
  > * `OrderServiceImpl 은 기능을 실행하는 책임`만 지면 된다. : 개발할때도 `인터페이스`만 보고 개발하면 됨(구체클래스가 어떨지 고민X)

* #### 다음 시간에는 AppConfig의 문제점과 더 나은 방향으로의 리팩터링을 배워보자

<br>
<br>
<br>

### < --------------------------- AppConfig 리팩터링 --------------------------- >
* #### 현재 AppConfig를 보면 "`중복`"이 있고, "`역할`"에 따른 "`구현`"이 잘 안보인다. : 설정(구성)정보에선 이렇게 한눈에 보이는것이 중요하다. 따라서 아래와 같이 변경함
```java
    public class AppConfig {
    // 멤버 서비스 역할
    public MemberService memberService() {
        return new MemberServiceImpl(memberRepository());
    }

    // 저장소 역할 : 저장소 변경시 아래 코드만 변경하면 된다.
    private MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }

    // 주문 서비스 역할
    public OrderService orderService() {
        return new OrderServiceImpl(memberRepository(), discountPolicy());
    }

    // 할인 정책 역할 : 정책 변경시 아래 코드만 변경하면 됨
    public DiscountPolicy discountPolicy() {
        return new FixDiscountPolicy();
    }
}
```

* #### 위 방식의 큰 장점은 각 메소드 명을 통해 역할이 전부 드러나고, 각 서비스에 대한 구현과 주입되는 저장소, 정책은 다른 메소드가 담당하므로 `변경 시 정책, 저장소 코드만 변경하면 됨`
  > * 이렇게 해서 설계에 대한 그림이 구성정보에 그대로 드러남 (`역할이 나오고, 역할에 대한 구현이 한눈에 들어옴`)

* #### 이렇게 하게 되면 후에 `new MemoryMemberRepository() 이 부분이 중복 제거`되었다. 이제 MemberRepository,  DiscountPolicy를 다른 구현체로 변경할 때 한 부분만 변경하면 된다

* #### 즉 `AppConfig를 보면 역할과 구현클래스가 한눈에 들어오며`, `애플리케이션 전체 구성이 어떻게 되어있는지 빠르게 파악`할 수 있다.


* #### 다음 시간에 정액할인정책을 정률할인정책으로 변경해보자

<br>
<br>
<br>

### < --------------------------- 새로운 구조와 할인 정책 적용 --------------------------- >
* #### 이전시간에 만든 새로운 구조에서 새로운 할인 정책을 적용해보자 (`RateDiscountPolicy`)
* #### AppConfig 구조가 등장하면서 AppConfig만 변경하면 된다.
  > * AppConfig의 등장으로 애플리케이션이 크게 `사용 영역`과, 객체를 생성하고 `구성(Configuration)하는 영역`으로 분리됨

* #### 따라서 할인정책을 변경하게되면 `AppConfig즉 구성영역의 코드만 변경`되고, 사용영역의 코드는 전혀 변경될 필요가 없다.
  > * `FixDiscountPolicy -> RateDiscountPolicy` 변경시 구성영역만 영향받고, 사용 영역 영향 X
  > * 이제 할인 정책을 변경해도, 애플리케이션의 구성 역할을 담당하는 `AppConfig만 변경`하면 된다.   
      클라이언트 코드인 OrderServiceImpl 를 포함해서 사용 영역의 어떤 코드도 변경할 필요가 없다
  > * 만약 AppConfig를 xml로 작성하면 정말 자바코드 변경없이 사용할 수 있다.

* #### 이렇게 되면서 DIP, OCP가 지켜졌다. `FixDiscount -> RateDiscount 변경 시`
  > * OrderServiceImpl에서 클라이언트 코드는 추상화에 의존하고 있다. : `DIP`
  > * 정책을 확장했지만 구성영역만 코드가 변경하면 되고 클라이언트 코드는 손댈 필요가 없다.   
      따라서 확장에는 열려있지만 변경에는 닫혀있다. : `OCP`

* #### 다음시간에는 지금까지 배운것을 정리해보자

<br>
<br>
<br>

### < --------------------------- 전체 흐름 정리 --------------------------- >
* #### 새로운 할인 정책을 개발
  > * `다형성` 덕분에 새로운 정률 할인 정책 코드를 추가로 개발하는 것 자체는 아무 문제가 없음

* #### 하지만 새로운 할인 정책 적용에서 `문제점`이 있다.
  > 1. 클라이언트 코드인 주문서비스 구현체(OrderServiceImpl)도 함께 변경해야함 -> `OCP위반`
  > 2. 주문서비스 클라이언트가 인터페이스(DiscountPolicy)뿐 아니라 구체 클래스(FixDiscountPolicy도 함꼐 의존함) -> `DIP위반`

* #### 따라서 관심사를 분리함
  > * 애플리케이션을 하나의 공연으로 봄
  > * 기존에는 클라이언트가 의존하는 서버구현 객체를 직접 생성하고 실행함
  > * 남자 배우가 공연뿐 아니라 배우 초빙역할도 담당함
  > * 공연 구성, 배우 섭외등을 지정하는 별도의 공연기획자 필요
  > * `공연 기획자인 AppConfig`가 등장함
  > * AppConfig는 애플리케이션의 전체 동작 방식을 구성(Config)하기 위해, 구현 객체를 생성하고 연결하는 책임을 가짐
  > * 따라서 클라이언트 객체는 자신의 역할을 실행하는 것만 집중, 권한이 줄어듬(`책임이 명확해짐`)

* #### AppConfig 리팩터링
  > * 구성 정보에서 역할과 구현을 명확하게 분리
  > * 역할이 잘 들어남
  > * 중복 제거

* #### 새로운 구조와 할인 정책 적용
    * `정액 할인 정책 -> 정률 할인 정책`으로 변경
    * AppConfig의 등장으로 `애플리케이션이 사용 영역과 객체를 생성하고 구성하는 영역으로 분리`됨
    * 할인정책을 변경해도 AppConfig에 구성영역만 변경하면 되고, 사용 영역은 변경할 필요가 없어짐,    
      따라서 `클라이언트 코드인 OrderServiceImpl도 변경하지 않음`

<br>
<br>
<br>

### < --------------------------- 좋은 객체 지향 설계의 5가지 원칙의 적용 --------------------------- >
* #### 여기서는 3가지 (`SRP, OCP, DIP`)가 적용 된다.

* #### SRP 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 한다.
  > * 클라이언트 객체는 직접 구현 객체를 생성하고, 연결, 실행하는 다양한 책임을 가졌지만
  > * SRP를 따르며 관심사를 분리함
  > * `구현 객체를 생성하고 연결하는 책임은 AppConfig가 담당`
  > * 클라이언트 객체는 실행하는 책임만 담당

* #### DIP 의존 관계 역전 원칙 : 추상화에 의존해야지, 구현체에 의존하면 안된다.
  > * `의존성 주입(DI)`은 이 원칙을 따르는 방법 중 하나
  > * 새로운 할인 정책 적용시 클라이언트 코드도 변경됨 : 추상화 인터페이스와 구체화 구현 클래스도 같이 의존하고 있었기 때문
  > * 따라서 클라이언트 코드가 추상화만 의존하도록 했으나 클라이언트는 인터페이스 만으로 아무것도 할 수 없음(NullPointExceptino)
  > * `AppConfig`가 FixDiscountPolicy 객체 인스턴스를 클라이언트 코드 대신 생성해 클라이언트 코드에 의존관계를 주입함 따라서 DIP 지켜짐

* #### OCP 개방 폐쇄 원칙 : 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
  > * 다형성 사용하고 클라이언트가 DIP를 지킴 : 이렇게 되면 `OCP가 적용될 가능성`이 생김
  > * 애플리케이션을 `사용 영역과 구성 영역`으로 나눔
  > * AppConfig가 의존 관계를 FixDiscountPolicy -> RateDiscountPolicy로 변경해서 클라이언트 코드에 주입하므로 `클라이언트 코드`는 변경하지 않아도됨
  > * "소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀있다."

<br>
<br>
<br>

### < --------------------------- IoC, DI, 그리고 컨테이너 --------------------------- >
* #### 제어의 역전(Inversion of Control)
  > * Spring에 국한된 단어는 아님, 보통은 `개발자가 원하는데로 객체를 생성하고 호출`하고,    
      그 안에서 다음것을 생성하며 직접 제어하는 스타일로 개발을 한다.
  > * `제어의 역전`은 `내가 호출하는것이 아닌 프레임워크 같은것이 코드를 대신 호출해줌`   
      (제어권이 뒤바뀐다하여 제어의 역전이 나옴)

  > * 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성, 연결, 실행함
      (한마디로 구현 객체가 프로그램의 제어 흐름을 스스로 조종 -> `개발자 입장에서 자연스러운 흐름`)

  > * `AppConfig`가 등장하며 구현 객체는 자신의 로직을 실행하는 역할만 담당하고,` 프로그램의 제어 흐름은 이제 AppConfig가 가져감`   
      (`OrderServiceImpl은` 필요한 인터페이들을 호출하지만 어떤 구현 객체들이 실행될지 `모른다`.)

  > * `프로그램 제어 흐름에 대한 권한은 AppConfig가 모두 가지고 있고` 심지어 OrderServiceImpl도 AppConfig가 생성함
      그리고 AppConfig는 OrderServiceImpl이 아닌 OrderService 인터페이스의 다른 구현 객체들을 생성하고 실행할 수 도 있다.
      OrderServiceImpl은 그런 사실을 모르고 자신의 로직을 실행함

  > * 이렇게 `프로그램의 제어 흐름을 직접 제어하는것이 아닌 외부에서 관리하는 것을 제어의 역전(IoC)라고 한다`.

* #### 프레임워크와 라이브러리를 구분할 때 제어의 역전이 사용됨
  > * 프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크가 맞다 (`JUnit`)
  > * 반면에 `내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아닌 라이브러리다`.
  > * 예를들어 자바 객체를 XML, JSON으로 변경하는것이 있는데 그 때 내가 라이브러리를 직접 불러서 사용 --> `라이브러리`

* #### 의존관계 주입 : DI(Dependency Injection)
  > * OrderServiceImpl은 DiscountPolicy 인터페이스에 의존한다. 실제 어떤 구현 객체가 사용될지는 모른다.
  > * 의존관계는 "`정적인 클래스 의존관계`와, `실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계`" 둘을 분리해서 생각해야 한다.


**[ 정적인 클래스 의존 관계 ]**

> * 클래스가 사용하는` import코드`만 보고 의존관계를 쉽게 판단할 수 있다. 정적인 의존관계는 `애플리케이션을 실행하지 않아도` 분석할 수 있다.
> * 클래스 다이어그램에서 OrderServiceImpl은 MemberRepository, DiscountPolicy에 의존하는것을 알 수 있다.
    그런데 이런 `클래스 의존관계 만으로는 실제 어떤 객체가 OrderServiceImpl에 주입될지 알 수 없다`.   
    (클래스 다이어그램에서 상속, 의존, 인터페이스 구현이던 `화살표 방향으로 의존`하고 있다는 것을 알아두자)


**[ 동적인 객체 인스턴스 의존 관계 ]**

> * 애플리케이션 실행 시점에 `실제 생성된 객체 인스턴스의 참조`가 연결된 의존 관계임
> * `객체 다이어그램`을 보면 알 수 있다.

> * 애플리케이션 실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서   
    클라이언트와 서버의 실제 의존관계가 연결되는 것을 "`의존관계 주입`"이라 한다.
> * `객체 인스턴스를 생성`하고, 그 `참조값(객체)을 전달해서 연결`된다.

> * 의존관계 주입을 사용하면 클라이언트 코드를 `변경하지 않고`, 클라이언트가 호출하는 대상의 타입 `인스턴스를 변경`할 수 있다.
> * 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, `동적인 객체 인스턴스 의존관계를 쉽게 변경`할 수 있다.   
    (정적인 그림인 클래스 다이어그램이 전혀 변경되지 않고, 동적인 그림인 객체 다이어그램만 변경시킴
    정적인 다이어그램 손대지 않는다? `애플리케이션 코드를 손대지 않는다와 동일한 말`)



* #### IoC 컨테이너, DI 컨테이너
  > * AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 `IoC 컨테이너 또는 DI 컨테이너`라고 한다.
  > * 의존관계 주입에 초점을 맞추어 최근에는 주로 `DI 컨테이너`라고 한다.
  > * 혹은 `어샘블러`(어플리케이션 전체에 대한 구성을 조립을 해준다), `오브젝트 팩토리`(오브젝트를 만든다고해서) 등으로 불리기도 함

  > * 이런 역할을 `Spring`이 해줌

<br>
<br>
<br>

### < --------------------------- 스프링으로 전환하기 --------------------------- >
* #### 지금까지의 순수한 자바 코드로 진행한 DI를 스프링으로 전환하자

* #### 애플리케이션의 설정정보는 AppConfig에 두었고 Spring은 이런 설정정보 파일에 `@Configuration`을 적게 되어있다.
* #### AppConfig 각 메소드에 `@Bean`을 적어주면 `Spring 컨테이너`에 등록된다.

* #### MemberApp에서 `ApplicationContext<interface>`을 이용한다.
  > * 스프링은 모든것이 `ApplicationContext`로 시작한다 이것을 곧 `스프링 컨테이너로 봐도 됨`
  > * `new AnnotationConfigApplicationContext(AppConfig.class);`를 이용
  > * AppConfig에 있는 annotation기반 환경 설정정보를 가지고 스프링이 `@Bean`이 붙은것들을 스프링 컨테이너에 객체생성한것을 넣고 관리해준다.

* 따라서 객체를 찾아올때는 AppConfig에서 직접 찾아오는것이 아닌 `스프링 컨테이너`를 통해서 찾아옴
  > * `applicationContext.getBean("memberService", MemberService.class);`
  > * 인자의 첫번째는 이름을 줌(이름은 AppConfig의 메소드의 이름이 디폴트로 등록됨), 두번째 인자는 타입을 정하며 이를 지정해야 반환타입이 맞아짐
      > *` memberService`로 받아오고 실행함

* 실행하게 되면 `Creating shared instance of singleton bean`으로 `@Bean`으로 작성한 메소드들이 스프링 컨테이너에 등록이 되었다는 로그가 나타나며 실행된다.
  (AppConfig도 appConfig로 등록됨)
  > * `key`는 `메소드명`, `value`는 `객체 인스턴스들`로 스때프링컨테이너에 등록, 등록된 빈을 꺼낼는 `이름`이나 `타입`을 주고 꺼냄 나머지는 기존코드와 동일

  > * OrderApp도 동일

**[정리]**
* #### `ApplicationContext를 스프링 컨테이너`라 한다.

* #### 기존에는 개발자가 AppConfig를 이용해 직접 객체 생성, DI했지만 이제부터는 `스프링 컨테이너를 통해서` 사용한다.

* #### 스프링 컨테이너는 `@Configuration`이 붙은 `AppConfig를 설정(구성)정보`로 사용한다. 여기서 `@Bean`이라 적힌 메소드를 모두 호출해서 `반환된 객체를 스프링 컨테이너에 등록`한다. 이렇게 스프링 컨테이너에 등록된 객체를 `스프링 빈`이라 한다.

* #### 스프링 빈은 @Bean이 붙은 `메소드의 명을 스프링 빈의 이름으로 사용`함. `(@Bean(name="")으로 변경`도 가능하지만 `관례(default)를 따르는것이 바람직`

* #### 이전에는 개발자가 필요한 객체를 AppConfig를 사용해 직접 조회 했지만, 이제부터는 `스프링 컨테이너를 통해서 필요한 스프링 빈(객체)을 찾아야 한다. 스프링 빈은 applicationContext.getBean() 메소드`를 사용해서 찾을 수 있다.

* #### 기존에는 개발자가 직접 자바코드로 모든 것을 했다면 이제부터는 `스프링 컨테이너에 객체를 스프링 빈으로 등록`하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경되었다.


* #### 의문 : 코드가 복잡해진것 같은데, `스프링 컨테이너를 사용하면 어떤 장점`이 있을까? 천천히 알아보자


* #### 스프링 컨테이너가 해줄 수 있는것은 어마어마하게 많음
  > * `DIP`, `OCP`, `다형성`등을 버무려서 왜 `Spring Container`가 나오게 되었는지 알아봤다.
  > * AppConfig 같은것을 개발자가 직접 만드는것이 아니라 스프링 컨테이너를 이용해 어떤 프로젝트에도 DI나 등등을 스프링이 편하게 해주도록 하는 `범용 프레임워크`가 생김
  > * 지금까지는 `객체지향원리`와 `다형성`만 가지고는 안되는구나를 알고, `DIP`, `OCP`를 지키기위한 설정이 필요한것을 직접 해본것이고 (AppConfig)
  > * 해본 이것 즉, 기존의 AppConfig보다 스프링 컨테이너가 더 낫다하는데, `뭐가 더 나을지`를 설명할것임

<br>
<br>
<br>

### < --------------------------- 스프링 컨테이너 생성 --------------------------- >
* #### 기존에는 Spring의 핵심원리, 객체지향으로 왜 Spring이 만들어졌는지 배웠고, 이제부터는 진짜 스프링 자체에 대해 설명할것

* #### 스프링 컨테이너가 생성되는 과정
```java
  // 스프링 컨테이너 생성
  ApplicationContext applicationContext = AnnotationConfigApplicationContext(AppConfig.class);
```

> * `ApplicationContext`를 `스프링 컨테이너`라 하고, 이는 `인터페이스`다. (`다형성이 적용`되어있다.)

> * 스프링 컨테이너는 `XML`기반 방식과, `Annotation`기반의 자바 설정 클래스(AppConfig)로 만들 수 있다.

> * `자바 설정 클래스` 기반으로 스프링 컨테이너(ApplicationContext)를 만들어보자.
    > *` new AnnotationConfigApplicationContext(AppConfig.class);`
> * 위 클래스는 `ApplicationContext 인터페이스 구현체`이다. (이 외에도 매우 많은 구현체가 존재)

**[참고]**   
더 정확히는 스프링 컨테이너(안에 사용하는 객체를 담은것))를 부를 때 `BeanFactory`, `ApplicationContext`로 구분해서 이야기한다.(뒤에서 설명)   
BeanFactory를 직접 사용하는 경우는 거의 없으므로, 일반적으로 `ApplicationContext`를 `스프링 컨테이너`라 한다.


**[생성과정]**
1. 스프링 컨테이너 생성
    * 스프링 컨테이너 생성(AppConfig.class) --> 스프링 컨테이너 생성됨(내부에 스프링 빈 저장소가 존재하고 key:빈 이름, value:빈 객쳬)
      > * new AnnotationConfigApplication(AppConfig.class);

    * 구성 정보 활용
      > * 스프링 컨테이너 생성시 구성정보를 지정해주어야 하는데, 여기서는 AppConfig.class를 구성정보로 지정했다.
2. 스프링 빈 등록
    * 스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보를 사용해서 스프링 빈을 등록한다.
      > * 넘겨받은 AppConfig.class 구성 정보를 가지고 @Bean이 붙은 메소드들을 호출해서 빈을 등록한다.
      > * 이때 빈 이름은 key로 가지고, 이름에 대한 값은 new로 생성한 객체를 return한 것을 빈 객체로 사용한다.

      > * Bean 이름(key로 가짐) : 빈 이름은 메소드 이름을 사용하거나 혹은 직접 부여할수 도 있다.( @Bean(name="memberService2) )
      > * 다만 빈 이름은 항상 다른 이름을 부여해야함, 같은 이름을 부여하게 되면 다른 빈이 무시되거나, 덮어버리거나, 설정에 따라 오류발생가능성 높음

3. 스프링 빈 의존관계 설정 - 준비
   > * 스프링 컨테이너는 스프링 빈을 등록한 후 의존관계를 설정한다.
   > * 스프링 컨테이너는 설정 정보를 참고해서 의존관계를 주입(DI)한다.
   > * 단순히 자바 코드를 호출하는 것 같지만, 차이가 있다. 이 차이는 뒤에 싱글톤 컨테이너에서 설명함

**[참고]**
> 스프링은 빈을 생성하고, 의존관계를 주입하는 단계가 나누어져 있다.   
그런데 이렇게 자바 코드로 스프링 빈을 등록하면 생성자를 호출 하면서 의존관계 주입도 한번에 처리된다.   
여기서는 이해를 돕기 위해 개념적으로 나누어 설명했다. 자세한 내용은 외존관계 자동 주입에서 다시 설명함.

**[정리]**
> 스프링 컨테이너를 생성하고, 설정(구성) 정보를 참고해 스프링 빈을 등록하고, 의존관계도 설정함   
다음시간에 스프링 컨테이너에서 데이터를 조회하자.

<br>
<br>
<br>

### < --------------------------- 컨테이너에 등록된 모든 빈 조회 --------------------------- >
* #### 컨테이너에 등록한 빈들이 제대로 등록되었는지 확인(조회) 해보자

* #### 모든 빈 조회 : `String [] beanDefinitionNames = ac.getBeanDefinitionNames();`를 기반으로 조회할 수 있다. (`for Each`)
  > * 배열 타입에서 `beanDeifinitionName`으로 값을 하나씩 꺼내어 담고
  > * `Object bean = ac.getBean(beanDefinitionName);`으로 빈을 꺼낸다. 따로 타입을 지정하지 않아 오브젝트로 반환됨

* #### 위와 같은 방법으로 조회하면 스프링이 내부작업에 사용되는 빈들도 같이 출력되므로 애플리케이션 빈만 출력해보자
  > * `BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName);`으로 빈의 메타데이터 정보를 받아와서
  > * `beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION`인 경우만 출력하게 한다.
  > * 여기서 `ROLE_APPLICATION`은 직접 등록한 애플리케이션 빈을 뜻하는 `상수`고, `ROLE_INFRASTRUCTURE`는 스프링이 `내부에서 사용하는 빈`을 뜻하는 상수다.


**[정리]**
* #### 모든 빈 출력하기
  > * 실행하면 스프링에 등록된 `모든 빈 정보를 출력`
  > * `ac.getDefinitionNames() `: 스프링에 등록된 모든 빈 이름을 조회한다.
  > * `ac.getBean()` : 빈 이름으로 빈 객체(인스턴스)를 조회.

* #### 애플리케이션 빈 출력하기
  > * 스프링이 내부에서 사용하는 빈 제외, 내가 등록한 빈만 출력
  > * 스프링이 내부에서 사용하는 빈은 `getRole()`로 구분 가능
  > * `ROLE_APPLICATION` : 일반적으로 사용자가 정의한 빈
  > * `ROLE_INFRASTRUCTURE` : 스프링이 내부에서 사용하는 빈


* #### 지금까지의 방법은 모든 빈을 조회하기 위한 방법이고 다음 시간에는 스프링 빈을 조회하는 가장 기본적인 방법을 알아보자
<br>
<br>
<br>

### < --------------------------- 스프링 빈 조회 - 기본 --------------------------- >
* #### 스프링 컨테이너에서 스프링 빈을 찾는 가장 기본적인 조회 방법
  > * ac.getBean(빈이름, 타입)
  > * ac.getBean(타입)

* #### 조회 대상 스프링 빈이 없으면 예외 발생
  > * `NoSuchBeanDefinitionException: No bean named 'xxxxx' available`

* #### 테스트
  > * `빈 이름으로 조회` : 빈 이름과 타입을 이용해 ac.getBean()으로 조회 할 수 있다. (Assertions로 검증)

  > * `이름 없이 타입으로만 조회` : 타입만을 가지고 ac.getBean()으로 조회 할 수 있다. (Assertions로 검증)
  > * 위 2개는 인터페이스로 조회함 : 이렇게 조회하면 인터페이스의 구현체가 대상이 됨

  > * `구체 타입으로 조회(인터페이스가 아닌)` : 타입을 인터페이스가 아닌 MeberServiceImpl과 같이 구체 타입으로 조회 할 수 있음 (Assertions로 검증)
  > * AppConfig의 반환 타입이 인터페이스라고 해서 꼭 인터페이스 타입을 이용하지 않아도 된다.
  > * 스프링 빈에 등록된 인스턴스(객체) 타입을 보고 결정하기 때문에 꼭 인터페이스가 아니어도 됨.
  > * 다만 구체적인걸 사용하는것은 좋지 못함 왜? 우리는 역할(인터페이스)에 의존해야하고 구현(구현체)에 의존하면 안되기때문.   
      (가끔 사용하다 보면 이상적으로 돌아가지 못할 때 필요 ㅎㅎ)

  > * `빈 이름으로 조회 불가능 테스트(실패테스트)` : 존재하지 않는 빈을 조회하면 NoSuchBeanDefinitionException이 발생함을 이용해 검증할 수 있다.
  > * 이는 org.junit.jupiter.api.Assertions을 이용한다 상단의 Assertions와 다른 클래스
  > * assertThrows(예외정보, 로직);	(예외가 던져지면 성공)
  > * 우리가 발생할거라 예상한 예외가 두번째 인자의 로직에서 발생하게 되면 테스트가 성공한다는 의미이다.
  > * 여기서 람다식이 사용됨(람다 공부하자)


* #### 이렇게 기본적인 조회는 간단하다.
* #### 다음시간에는 만약에 동일 타입이 2개가 있으면 어떻게 될지 알아보자.
<br>
<br>
<br>

### < --------------------------- 스프링 빈 조회 - 동일한 타입이 둘 이상 --------------------------- >
* #### 스프링 빈을 조회시 같은 타입의 스프링 빈이 둘 이상이면 오류가 발생한다. 이때는 빈 이름을 지정하면 해결됨
  > * `ac.getBeansOfType()` 을 사용하면 해당 타입의 모든 빈을 조회할 수 있음.

* #### ApplicationContextSameBeanFindTest 테스트 클래스를 만들어보자
  > * AppConfig는 현재 중복되는 빈이 없으므로 임의로 클래스내의 `static Config클래스`를 만든다. (클래스안에 클래스는 `현재 클래스`안에서만 사용가능)

**[ TEST ]**
1. 타입 조회시 같은 타입이 둘 이상 있으면 중복 오류 발생
   > * assertThrow()로 ac.getBean(MemberRepository.class)를 꺼낼떄 `NoUniqueBeanDefinitionException`이 발생하면 테스트 성공 로직 작성

2. 타입으로 조회시 같은 타입이 둘 이상 있으면, 빈 이름을 지정하면 된다.
   > * ac.getBean(name, type); 옵션으로 특정 빈의 이름을 지정하면 `NoUniqueBeanDefinitionException` 방지가능 이후 assertThat으로 MemberRepository의 구현체가 맞는지 확인하는 로직 작성

3. 특정 타입을 모두 조회하기
   > * ac.getBeansOfType(type)을 넘기게 되면 Map형식으로 타입에 해당되는 모든 빈을 반환 받는다. key는 Bean의 이름, value는 타입이 된다.
   > * assertThat으로 반환받은 타입의 크기가 2임을 확인하는 로직 작성
   > * 한번에 조회 하는 방법은 Autowired로 자동으로 의존관계를 주입할때 이러한 기능들이 자동으로 적용된다.


* #### 다음 시간에는 상속 관계에서의 조회가 어떻게 되는지 알아보자 (중요)
<br>
<br>
<br>

### < --------------------------- 스프링 빈 조회 - 상속 관계 --------------------------- >
* #### 스프링에선 `부모 타입`으로 조회하면, `자식 타입`도 함께 조회한다.(대원칙)
* #### 그래서 모든 자바 객체의 최고 부모인 `Object 타입`으로 조회하면, `모든 스프링 빈을 조회`한다.
  > * pdf의 상속관계 예시를 보면 부모타입도 포함하여 하위 자식들 모두를 조회한다.

**[TEST]**
>static 클래스로 TestConfig생성 : Rate, FixDiscountPolicy로 빈 생성

1. 부모 타입으로 조회시, 자식이 둘 이상 있으면, `중복 오류` 발생
2. 부모 타입으로 조회시, 자식이 둘 이상 있으면, `빈 이름`을 지정하면 된다.
3. 특정 하위 타입으로 조회(구현체로 하지만 `좋지 않은 방법`)
   > * 그러면 public RateDiscountPolicy 를 반환해도 동일하지만 굳이 DiscountPolicy로 두는 이유는 무엇일까?
   > * `역할`과 `구현`을 항상 쪼개야하는데 public DiscountPolicy를 보고 역할을 보는것임
   > * `구체적인 것으로 해도되지만 역할로 두는것이 좋음` 다른곳에서 DI 할 때도 DiscountPolicy(역할)를 의존하기 떄문이다.
4. 부모 타입으로 모두 조회하기 (인터페이스 타입)
5. 부모 타입으로 모두 조회하기 - Object

* #### 사실 어플리케이션 컨테스트에서 직접 getBean을 할 일이 별로 없다. 후에 스프링 컨테이너가 자동으로 의존관계를 주입하는 걸 사용함
  > OrderService를 개발 할 때 기본 코드만 개발하고, 의존관계 주입에 대한 부분은 명시하지 않음   
  왜냐면 그 부분은 AppConfig에서 적어주고 있다. 또한 스프링 컨테이너를 통해 빈을 조회하는 코드도 없음   
  가끔 순수 자바 어플리케이션에서 스프링 컨테이너를 생성해서 써야할 일 있을때 사용된다.

* #### 부모 타입으로 조회할때 자식이 어디까지 조회되는지 잘 이해해야 후에 자동 의존 관계 주입에서 문제없이 잘 해결할 수 있다.
<br>
<br>
<br>

### < --------------------------- BeanFactory와 ApplicationContext --------------------------- >
* #### BeanFactory
  > * 스프링 컨테이너의 `최상위 인터페이스`다.
  > * 스프링 빈을 `관리`하고 `조회`하는 역할을 담당한다.
  > * `getBean()`을 제공한다.
  > * 지금까지 우리가 사용했던 `대부분의 기능`은 BeanFactory가 제공하는 기능이다.

* #### ApplicationContext
  > * BeanFactory의 기능을 모두 `상속`받아서 제공한다.
  > * 빈을 관리하고 검색하는 기능을 BeanFactory가 제공해주는데, 그러면 둘의 `차이가 뭘까?`
  > * `애플리케이션을 개발할 때`는 빈은 관리하고 조회하는 기능은 물론이고, `수 많은 부가기능이 필요`하다.

* #### ApplicationContext가 제공하는(상속받은) `부가기능` (BeanFactory말고도)
    * `메시지 소스를 활용한 국제화 기능(MessageSource <<interface>> )`
        * 예를 들어서 한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력
          <br><br>
    * `환경 변수 (EnvironmentCapable <<interface>> )`
        * 로컬, 개발, 운영 등을 구분해서 처리
        * 개발은 크게 3가지의 개발환경이 있다.
            1. `로컬` : 현재 내 PC에서 개발하는 환경
            2. `테스트 서버` : 테스트 서버에 띄워두고 테스트 할 수 있는 환경
            3. `운영 환경` : 실제 프로덕션에 나가는 환경
            4. 추가로 `스테이징환경` : 운영과 가장 밀접한(비슷한) 환경 등이 있다.
               <br><br>
    * `애플리케이션 이벤트(ApplicationEventPublisher <<interface>> )`
        * 애플리케이션 내에서 특정 이벤트를 발행하고 구독하는 모델을 편리하게 지원
          <br><br>
    * `편리한 리소스 조회(ResourceLoader <<interface>> )`
        * 파일, 클래스패스, 외부 등에서 리소스를 추상화하여 편리하게 조회할 수 있게함


* #### 정리
  > * ApplicationContext는 BeanFactory의 기능을 `상속`받는다.
  > * ApplicationContext는 `빈 관리기능 + 편리한 부가 기능`을 제공한다.
  > * BeanFactory를 직접 사용할 일은 거의 없다. 주로 부가기능이 포함된 `ApplicationContext를 사용`한다.
  > * BeanFactory나 ApplicationContext를 `스프링 컨테이너`라 한다. (우리는 ApplicationContext만 사용한다고 보면된다.)

<br>
<br>
<br>

### < --------------------------- 다양한 설정 형식 지원 - 자바 코드, XML --------------------------- >
* #### 스프링 컨테이너는 다양한 형식의 설정 정보를 받아들일 수 있게 `유연하게 설계`되어 있다.
  > * `자바코드`, `XML`, `Groovy`, `임의로 설정`도 가능

* #### ApplicationContext << interface >>를 구현한 것들을 보면
  > * `AnnotationConfigApplicationContext(자바코드를 설정정보로 사용)`
  > * `GenericXmlApplicationContext(XML문서를 설정정보로 사용)`
  > * 혹은 `임의로 구현`하여 만들 수 있음 : XxxApplicationContext

* #### 애노테이션 기반 자바 코드 설정 사용
  > * 지금까지 사용한것
  > * `new AnnotationConfigApplicationContext(AppConfig.class)`
  > * `AnnotationConfigApplicationContex`t 클래스를 사용하면서 `자바 코드`로된 설정 정보를 넘기면 된다.

* #### XML 기반 설정 사용
  > * 최근 스프링 부트의 사용으로 XML기반의 설정은 잘 사용하지 않음,    
      많은 레거시 프로젝트 들이 XML로 되어 있고  또 XML을 사용하면 컴파일 없이 빈 설정 정보를 변경할 수 있는 장점도 있다.
  > * `GenericXmlApplicationContext`를 사용하면서 xml 설정 파일을 넘기면 된다.

* #### 자바 코드가 아닌 파일은 `resources`아래에 둔다 xml도 마찬가지 (appConfig.xml)
  > * 이렇게 되면 `classPath`에서 자동으로 appConfig.xml을 읽어온다. 따로 import없이

* #### xml 기반의 appConfig.xml 스프링 설정 정보와 자바 코드로 된 AppConfig.java 설정 정보를 비교해보면 거의 비슷하다는 것을 알 수 있다.
* #### xml 기반으로 설정하는 것은 최근에 잘 사용하지 않으므로 이정도로 마무리 하고, 필요하면 `스프링 공식 레퍼런스` 문서를 확인하자

* #### 여기서 배우고자 하는건 스프링은 자바 코드 뿐만아니라 다양한 방법으로 설정 파일을 만드는것을 지원해준다는 것이다.
  > * 스프링이 얼마나 유연하게 설정들을 할 수 있는지 알 수 있음

<br>
<br>
<br>

### < --------------------------- 스프링 빈 설정 메타 정보 - BeanDefinition --------------------------- >
* #### 스프링이 xml, 자바코드, 임의설정과 같이 다양한 설정 형식을 지원할 수 있는 이유?
  > * 중심에` BeanDefinition이라는 추상화`가 있다. (`빈 정보에 대한 것 자체를 추상화 시킴`)

* #### 이는 곧 `역할`과 `구현`을 개념적으로 나눈 것이다.
  > * `XML`을 읽어서 BeanDefinition을 만들면 된다.
  > * `자바 코드`를 읽어서 BeanDefinition을 만들면 된다.
  > * 스프링 컨테이너 입장에선 자바 코드인지, XML인지 몰라도 된다. `오직 BeanDefinition만 알면 된다`.

* ####  BeanDefinition을 빈 설정 메타정보라고 한다.
  > * `@Bean`, `<bean>`당 각각 하나씩 `메타 정보`가 생성된다.
* #### 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다.

* #### 결국 BeanDefinition이라는 역할을 구현하고 있는것이 자바 설정파일, XML설정파일, 임의설정파일 된다.
  > * (스프링 컨테이너는 BeanDefinition을 의존하고 있다(추상화를 의존) 따라서 위와 같은 상황이 가능하다.)


**[코드 레벨로 좀 더 깊게 들어가보자]**
* #### AnnotationConfigApplicationContext는 AnnotatedBeanDefinitionReader를 의존하는데 이를 사용해서 AppConfig.class를 읽고, BeanDefinition를 생성한다 마치 메타데이터 처럼 읽는다. 그리고 빈의 메타데이터를 담는다.

* #### GenericXmlApplicationContext도 마찬가지로 내부에 XmlBeanDefinitionReader 를 의존하고, 이를 사용해서 appConfig.xml 설정 정보를 읽고 BeanDefinition 을 생성한다

* #### 새로운 형식의 설정 정보가 추가되면, XxxBeanDefinitionReader를 만들어서 BeanDefinition을 생성하면 된다.
  > * 임의의 형식을 만들 수 있음 (JSON 등)


**[정리]**
* #### BeanDefinition을 직접 생성해서 스프링 컨테이너에 등록할 수 도 있다.(하지만 BeanDefinition을 직접 정의하거나 사용할 일은 거의 없다)
* #### 스프링이 다양한 형태의 설정 정보를 BeanDefinition으로 추상화해서 사용하는 것 정도만 이해하자.
* #### 가끔 스프링 코드, 스프링 관련 오픈 소스의 코드에서 BeanDefinition이 보이는데 이때 이러한 메커니즘을 떠올리면 된다.
  > (BeanDefiniton을 직접 프로그래밍 하는 경우도 있다.)

* #### 스프링이 빈을 등록하는 방식은 크게 봤을때 2가지가 존재(어노테이션, xml, 임의 설정의 상위 방식)
    1. 직접 스프링 빈을 등록하는 방법 : `XML Config`
    2. 우회하여 Factory Method를 이용하여 스프링 빈을 등록하는 방법 : `Java Config`
       <br><br>

* #### 추가로 Annotation이 아닌 GenericXmlApplicationContext로 만들어서 BeanDefinition을 출력해보면 Annotation 방식과는 다른점을 알 수있다.
  > * Bean에 대한 클래스가 다 드러남(Java Config는 NULL)
  > * FactoryBean, Method가 Null값 : xml은 직접 스프링 빈을 등록하므로   
      (Java Config는 factoryBeanName:appConfig, factoryMethodName=... 으로 존재)

<br>
<br>
<br>

### < --------------------------- 웹 애플리케이션과 싱글톤 --------------------------- >
* #### 스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생했다.
* #### 대부분의 스프링 애플리케이션은 웹 애플리케이션이다. 물론 웹이 아닌 애플리케이션 개발도 얼마든지 개발할 수 있다.
* #### 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다.

* #### 클라이언트 A,B,C가 순서대로 memberService를 요청한다고 DI컨테이너(AppConfig)는 총 3개의 MemberServiceImpl 객체를 반환 해준다.
  > * 이렇게 되면 어떤 문제가 발생할까? 웹애플리케이션은 고객이 계속 요청을 하는데 요청때마다 객체를 만들어야 하는것이 문제가 된다.

* #### 실제로 Spring이 없는 순수한 DI 컨테이너 테스트를 통해 확인해보자 (SingletonTest.java)
  > * 테스트 결과로 알 수 있는 것은 우리가 만들었던 스프링 없는 순수한 DI 컨테이너인 AppConfig는 요청을 할 때마다 객체를 새로 생성한다.
  > * 고객 트래픽이 초당 100이 나오면 초당 100개의 객체가 생성되고 소멸된다. --> 메모리 낭비 극심
  > * 해결 방안은 해당 객체가 딱 `1개만 생성`되고, `공유`하도록 설계하면 된다. --> `싱글톤 패턴`

<br>
<br>
<br>

###< --------------------------- 싱글톤 패턴 --------------------------- >
* #### 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴이다.
* #### 그래서 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 한다.
  > * `private 생성자`를 사용해서 외부에서 임의로 `new 키워드`를 사용하지 못하도록 막아야 한다.

* #### Singleton pattern 예제 코드 분석 `[test/hello/core/singleton/SingletonService.java]`
  > * `static 영역`에 객체 instance를 하나 생성해서 올려둠. >> 실행시 JVM 메모리에
  > * 객체 인스턴스가 필요하면 오직 `getInstance() 메소드`를 통해서만 조회할 수 있다.   
      (여기서 메서드를 호출하면 항상 같은 인스턴스 반환)
  > * 오직 1개의 객체 인스턴스만 존재해야 하므로, 생성자를 `private`으로 두어
      외부에서 new키워드로 객체 인스턴스가 생성되는 것을 `막는다`.

* #### Singleton pattern Test 예제 코드 분석 `[test/hello/colr/singleton/SingletonServiceTest.java]`
  > * `private`으로 new 키워드를 막아두었다.
  > * 호출할 때 마다 `같은` 객체 인스턴스를 반환하는 것을 알 수 있다.   
      (현재 구현한 싱글톤 패턴은 객체를 미리 생성해두는 가장 단순하고 안전한 방식)

* #### 싱글톤 패턴을 적용하면 이미 만들어진 객체를 공유하여 효율적으로 사용하지만 수많은 문제점을 가진다.
  > * 싱글톤 패턴을 구현하는 `코드 자체가 많이 들어감`
  > * 의존관계상 클라이언트가 `구체 클래스에 의존`한다.(`구체클래스.getInstance()`) --> 즉 `DIP`를 위반함   
      (하지만 `Config파일을 거치게 되면` DIP를 지킬 수 있다.)
  > * 클라이언트가 구체 클래스에 의존해서 `OCP 원칙`을 `위반`할 가능성이 높음
  > * `테스트` 하기 어렵다.   
      (객체를 `지정`해서 가져오고, 인스턴스를 `미리 생성`하므로)
  > * 내부 속성을 변경 및 초기화 하기 어렵다.
  > * `private 생성자`를 사용하므로 자식 클래스를 만들기 어렵다.
  > * 결과적으로 `유연성`이 떨어짐
  > * `안티패턴`으로 불리기도 한다.   
      (많이 사용되는 패턴이지만 비효율적이거나 비생산적인 패턴을 의미한다)

* #### 스프링 프레임워크는 이런 문제점을 전부 해결함 즉 싱글톤이 가진 `단점`을 `제거`하고, 객체를 싱글톤으로 관리해준다.
  > * 스프링 컨테이너는 `싱글톤 컨테이너`라고도 불림 싱글톤 컨테이너의 역할을 알아보자

<br>
<br>
<br>

### < --------------------------- 싱글톤 컨테이너(스프링 컨테이너) --------------------------- >
* #### 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하며, 객체 인스턴스를 싱글톤(1개만 생성)으로 관리한다.
* #### 지금까지 학습한 스프링 빈이 바로 싱글톤으로 관리되는 빈이다.

**[ 싱글톤 컨테이너 ]**
* #### 스프링 컨테이너는 싱글턴 패턴을 `적용하지 않아도`, 객체 인스턴스를 싱글톤으로 관리한다.
  > * 이전에 설명한 컨테이너 생성 과정을 자세히 보면 컨테이너는 객체를 하나만 생성해서 관리함(50p 참조)

* #### 스프링 컨테이너는 싱글톤 컨테이너 `역할`을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 `싱글톤 레지스트리`라 한다.

* #### 스프링 컨테이너의 이런 기능 덕분에 싱글턴 패턴의 `모든 단점을 해결`하면서 객체를 싱글톤으로 유지할 수 있다.
  > * 싱글톤 패턴을 위한 `지저분한 코드`가 들어가지 않아도 된다.
  > * `DIP`, `OCP`, `테스트`,` private 생성자`로부터 자유롭게 싱글톤을 사용할 수 있다.

* #### 스프링 컨테이너를 사용하는 테스트 코드 예제
  > * `MemberService` 타입 객체를 2번 `getBean()해도 두 참조값이 같음`, 즉 객체를 한번만 생성하고 `재사용` 하는것을 알 수 있다.
  > * 그렇다고 해서 MemberServiceImpl 클래스를 살펴보면 싱글톤 패턴과 관련된 코드가 `하나도 존재하지 않음`

* #### 싱글톤 컨테이너 적용 후
  > * 스프링 컨테이너 덕분에 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 `공유`해서 효율적으로 재사용 할 수 있다.

  **[참고]**
  > * 스프링의 기본 빈 등록 방식은 싱글톤이지만, 싱글톤 방식만 지원하는 것은 아니다. 요청할 때 마다 새로운 객체를 생성해서 반환하는 기능도 제공한다.
      자세한 내용은 후의 빈 스코프에서 설명
  > * 특별한 기능 이용시 사용 : 요청할 때 마다 새로 꺼내거나, HttpRequest life Cycle에 맞춰 빈 라이프 사이클을 맞추거나, 고객이 들어올때 만들고 나갈때 죽이는 사이트
      혹은 HttpSession과 같은 라이프 사이클을 맞추거나 할 때 사용된다.

<br>
<br>
<br>

### < --------------------------- 싱글톤 방식의 주의점 --------------------------- >
* #### 싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 인스턴스를 공유함 따라서 싱글톤 객체는 상태를 `유지(stateful)`하게 설계하면 안된다.

* #### `무상태(stateless)로 설계`해야 한다!
  > * 특정 클라이언트에 `의존적인 필드`가 있으면 안된다. (`특정 클라이언트를 필요로 하는 필드가 있으면 안된다`)
  > * 특정 클라이언트가 `값을 변경할 수 있는 필드`가 있으면 안된다!
  > * 가급적 `읽기만 가능`해야 한다.
  > * 필드 대신에 `자바에서 공유되지 않는`, `지역변수`, `파라미터`, `ThreadLocal`등을 사용해야 한다.

* #### 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다. (물론 싱글톤 빈에)

* #### SingletonStateServiceTest (영한님은 StatefulServiceTest)에 `stateful`, `stateless`한 테스트를 2개 만들고 테스트하자 (코드 참조)

**[StatefulService]**
> * 우선 StatefulService는 특정 클라이언트에 의존적이고 값을 변경할 수 있는 필드인 `price`가 존재한다.
> * 이는 특정 메소드가 실행되었을때 공유 필드인 int price에 값이 `저장`되는데 이를 `stateful`하다고 말 할 수 있다.
> * 이를 해결하기 위해 `stateless`하게 변경해야 한다.

**[StatelessService]**
> * StatelessService는 주문을 했을때 공유 필드에 값을 저장하는 것이 아닌 사용자가 주문한 값을 `바로 반환`해준다.
> * 따라서 요청이 들어올때마다 즉시 즉시 값을 반환하므로 클라이언트는 `자신이 주문한 값`을 바로 확인할 수 있다.
> * `공유 필드에 저장되지 않았으므로` stateful하지 않게 된다.

**[정리]**
* #### 단순한 설명을 위해 실제 쓰레드는 사용하지 않음

* #### ThreadA가 사용자 A코드를 호출하고 ThreadB가 사용자B 코드를 호출할 때 StatefulService의 price필드는 공유되는 필드가 되며, 특정 클라이언트가 값을 변경한다.

* #### 사용자A의 주문금액은 10000원 이지만, 20000원이라는 결과가 나온다.

* #### `공유 필드는 정말정말 조심해야한다`. 스프링 빈은 항상 무상태(stateless)로 설계하자 (실무에서는 이런경우가 종종 발생한다. 이로인해 정말 해결하기 어려운 큰 문제들이 터진다. 잘 알고 있자)

<br>
<br>
<br>

### < --------------------------- @Configuration과 싱글톤 --------------------------- >
* #### 지금까지 싱글톤은 객체를 하나만 생성해서 공유해서 사용하는것으로 알고있다 하지만!!
  >AppConfig를 보면 memberService, orderService 빈을 만드는 코드는 동일한 memberRepository 메소드를 호출하며 2개의 new MemoryMemberReposiory()를 호출한다.   
  결과적으로 2개의 객체가 생성되면서 싱글톤이 깨지는 것 처럼 보인다. 스프링 컨테이너는 이 문제를 어떻게 해결할까?   
  이럴 경우에는 과연 Spring은 어떤 방식으로 싱글톤을 유지할까? --> 이렇게 고민이 될때는 테스트 코드를 이용한다.

* #### configurationTest 결과
  > * 실제로 MemberServiceImpl과 OrderServiceImpl에 모두 getMemberRepository를 임의로 만들어
  > * 객체가 같은지 비교하면 `같은 객체`임을 확인할 수 있다.
  > * 즉, memberRepository 인스턴스는 모두 `같은 인스턴스가 공유되어 사용`된다.
  > * 하지만 AppConfig의 자바 코드는 각 3번의 new MemoryMemberRepository를 호출해서 각각 다른 인스턴스가 생성되어야 하는데?
  > * 실험을 통해 알아보자

* #### AppConfig에 호출 코드 남기기
  > * 스프링 컨테이너가 스프링 빈을 생성할 때 memberRepository()는 총 `3번이 실행될 것으로 예상`됨
    1. 스프링 빈에 등록하기 위해 @Bean이 붙어있는 memberRepository() 호출
    2. memberService() 로직에서 memberRepository() 호출
    3. orderService() 로직에서 memberRepository() 호출

  > * 실제 출력 결과 : 모두 1번씩 호출된다. 왜?
    1. call AppConfig.memberService
    2. call AppConfig.memberRepository
    3. call AppConfig.orderService

<br>
<br>
<br>

### < --------------------------- @Configuration과 바이트코드 조작의 마법 --------------------------- >
* #### 스프링 컨테이너는 싱글톤 레지스트리다. (스프링이 직접  싱글턴 객체를 만들고 관리하는 기능을 제공하는 것을 의미한다.)
* #### 따라서 스프링 빈이 싱글톤이 되도록 보장해주어야 함.
* #### 하지만 스프링이 자바 코드까지 어떻게 하기는 어려움 --> 자바 코드를 보면 분명 3번 호출되어야 하는 것이 맞다.
* #### 따라서 스프링은 클래스의 바이트코드를 조작하는 라이브러리를 사용
* #### `모든 비밀은 @Configuration을 적용한 AppConfig에 있다.`

* #### ConfigurationDeep Test
  > * AppConfig또한 AnnotationConfigApplicationContext에 파라미터로 넘긴 값이므로 `스프링 빈으로 등록`된다.
  > * AppConfig를 getBean해 bean.getClass()로 클래스정보를 출력하면 class hello.core.AppConfig$$EnhancerBySpring`CGLIB`$$bd479d70 형태로 출력된다.
  > * 예상 출력은 다음과 같다. : class hello.core.AppConfig 하지만, `xxxCGLIB`가 붙으며 복잡해진 클래스 정보가 출력된다.
  > * 이는 `CGLIB`라는 `바이트코드 조작 라이브러리`를 이용해 `AppConfig를 상속받은 임의의 클래스를 스프링 빈으로 등록`했기 때문

  > * 임의의 다른 클래스가 아래와같이 CGLIB의 기술로 싱글톤이 보장되도록 해준다.
```java
  @Bean
public MemberRepository memberRepository() {
        if (memoryMemberRepository가 이미 스프링 컨테이너에 등록되어 있으면?) {
            return 스프링 컨테이너에서 찾아서 반환;
        } else { //스프링 컨테이너에 없으면
            [기존 로직을 호출해서 MemoryMemberRepository를 생성하고 스프링 컨테이너에 등록]
            return 반환
        }
}

```

> * 즉 @Bean이 붙은 메소드마다 스프링 빈이 이미 존재하면 존재하는 빈을 반환, 없으면 생성해서 스프링 빈으로 등록하고 반환한다.
> * 이 덕분에 싱글톤이 보장된다.

> * 참고로 AppConfig@CGLIB는 `AppConfig의 자식 타입`이므로 AppConfig타입으로 조회할 수 있다.


* #### @Configuration없이 @Bean만 적용하면?
  > * 출력 결과를 통해서 AppConfig가 CGLIB 기술 없이 `순수한 AppConfig로 스프링 빈에 등록`된 것을 확인할 수 있다.
  > * 또한 MemberRepository가 초기 예상대로 총 `3번 호출`된다.
  > * 인스턴스도 각각 다른 MemoryMemberRepository 인스턴스를 가지므로 `싱글톤이 지켜지지 않는다`.   
      (왜냐하면 각각 실행되는 memberRepository()는 일반적인 `new로 객체가 생성되는것과 동일`하므로 스프링 컨테이너에 등록되지 않기 때문이다.)   
      (따라서 각 `Service에 주입된 저장소들은 스프링 빈이 아니라 직접 new하여 구현체를 의존하는것과 동일한 상황`이 된다.)   
      (만약 @Configuration을 없이 사용하고 싶다면 `@Autowired`를 사용하면 됨)


**[ 정리 ]**
* #### @Bean만 사용해도 스프링 빈으로 등록되지만, 싱글톤을 보장하지 않는다.
  > * memberRepository()처럼 의존관계 주입이 필요해서 메소드를 직접 호출할 때 싱글톤을 보장하지 않는다.
* #### 스프링 설정 정보는 항상 @Configuration을 사용하자.

<br>
<br>
<br>

### < --------------------------- 컴포넌트 스캔과 의존관계 자동 주입 시작하기 --------------------------- >
* #### @Bean, XML로 등록해야할 스프링 빈이 많아질 수 록 일일이 등록하기 힘들어짐 --> 누락하는 문제 발생 가능성 높아짐
* #### 따라서 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다.
* #### 또한 의존관계도 자동으로 주입하는 @Autowired라는 기능도 제공한다.

* #### 기존의 AppConfig를 유지하기 위해 `AutoAppConfig`를 새로 생성한다.
  > * 내부에는 @Bean으로 등록한 클래스는 하나도 없고 단지 `@Configuration`과 `@ComponentScan`만 붙여준다.
  > * 기존에 만들어져 있고 `@Configuration`이 붙은 설정 정보도 자동으로 등록된다.
  > * 따라서 `excludeFilters`를 이용해 `어노테이션 설정정보는 컴포넌트 스캔 대상에서 제외`한다. (이를 하지 않으면 빈이 중복될 수 있다.)

* #### 컴포넌트 스캔은 이름 그대로 @Component 어노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다.
  > * `@Configuration`의 소스코드도 `@Component`가 붙어있으므로 스캔의 대상이 될 수 있어서 `제외`했다.

* #### @Component 붙여주기
  > * 기존의 AppConfig에 Bean으로 등록한 클래스들에 `@Component`를 붙여준다.
  > * 과거에는 @Bean으로 직접 설정정보도 작성했지만 의존관계도 같이 명시해줬다.
  > * 하지만 지금은 설정 정보 자체가 없으므로 `의존관계도 클래스안에서 해결`해야 한다.

* #### Autowired의 역할
  > * ComponentScan을 하며 @Component객체를 생성할때 `알맞은 의존관계를 자동으로 주입`해준다.
  > * 여기선 MemberServiceImpl, OrderServiceImpl의 `생성자`에 @Autowired를 붙여준다.
  > * 생성자에서 `여러 의존관계`도 한번에 주입받을 수 있다.
  > * 실제로 테스트를 하여 로그를 확인하면 컴포넌트 스캔이 잘 동작함을 알 수 있음 (AutoAppConfigTest)

* #### 컴포넌트 스캔과 자동 의존관계 주입의 동작
  **[@ComponentScan]**
  > * `@ComponentScan`은 `@Component`가 붙은 모든 클래스를 스프링 빈으로 등록한다.
  > * 이때 스프링 빈의 `기본 이름`은 클래스명을 사용하되 맨 앞글자만 소문자를 사용한다.
  > * `빈 이름 기본 전략` : MemberServiceImpl 클래스 -> memberServiceImpl
  > * 혹은 빈이름을 직접 지정하고 싶다면
  > * `@Component("memberService2")`와 같은 방식으로 지정이 가능하다.

  **[@Autowired 의존관계 자동 주입]**
  > * `생성자`에 @Autowired를 지정하면, 스프링 컨테이너가 `자동`으로 해당 스프링 빈을 찾아서 주입함
  > * 이때 기본 조회 전략은 타입이 같은 빈을 찾아서 주입한다. (따라서 `같은 타입의 빈이 2개이상 존재하면 충돌` 오류발생)
  > * `getBean(MemberRepository.class)와 동일`하다고 이해하면 된다.

  > * `생성자에 파라미터가 많아도 자동으로 주입`함

<br>
<br>
<br>

### < --------------------------- 탐색 위치와 기본 스캔 대상 --------------------------- >
* #### 모든 자바 클래스를 컴포넌트 스캔하면 시간이 오래걸리므로 필요한 위치부터 탐색하게 설정할 수 있다.
  > * @Component(이곳에 설정)
  > * `basePackages` : 탐색할 패키지의 시작위치 결정, 이 패키지를 포함해 하위 패키지 모두 탐색 `{"",""}`로 여러 시작위치를 정할 수 있다.
  > * `basePackageClasses` : 지정한 클래스의 패키지를 탐색 시작 위치로 지정
  > * 만약 지정하지 않으면 `@ComponentScan이 붙은 설정 정보 클래스의 패키지`가 시작 위치가 된다.


* #### 영한님이 권장하는 방법
  > * `패키지 위치를 지정하지 않는 방법` : 설정 정보 클래스의 위치를 프로젝트 최상단에 둔다(`스프링 부트`도 이 방법을 기본으로 제공한다)
  > * `com.hello, com.hello.service, com.hello.repository`와 같이 프로젝트 구조가 있으면 com.hello가 프로젝트 루트이므로, 이곳에 설정 정보를 둔다
  > * 이후 @ComponentScan을 달고 패키지 지정을 생략하면 이곳부터 하위 패키지까지 탐색함

  > * 또한 프로젝트 `메인 설정 정보`는 프로젝트를 대표하는 정보이므로 `시작 루트에 위치하는것이 바람직`하다.
  > * 부트 사용시 Spring Boot의 대표 시작 정보인 `@SpringBootApplication`을 프로젝트 시작 루트 위치에 두는것이 관례(그리고 설정 안에 바로 `@ComponentScan`이 들어있다.)


* #### 컴포넌트 스캔 기본 대상
  > * 컴포넌트 스캔은 @Component뿐 아니라 아래의 내용도 추가로 대상에 포함

  > * `@Component` 컴포넌트 스캔에서 사용
  > * `@Controller` 스프링 MVC 컨트롤러에서 사용
  > * `@Service` 스프링 비즈니스 로직에서 사용
  > * `@Repository` 스프링 데이터 접근 계층에서 사용
  > * `@Configuration` 스프링 설정 정보에서 사용   
      (해당 클래스들의 설정 정보를 보면 `@Component를` 포함하고 있다)

  **[참고]** : 사실 어노테이션에는 `상속관계가 없다`. 따라서 어노테이션이 특정 어노테이션을 들고 있는 것을 인식할 수 있는것은
  자바 언어가 지원하는 기능이 아닌, `스프링이 지원하는 기능`이다.


* #### 컴포넌트 스캔의 용도 뿐 아니라 다음 어노테이션이 있으면 스프링은 부가 기능을 수행한다.
  > * `@Controller` 스프링 `MVC 컨트롤러`로 인식
  > * `@Repository` 스프링 `데이터 접근 계층`으로 인식, 데이터 계층의 예외를 스프링 예외로 변환   
      (데이터 계층의 예외를 스프링의 `추상화된 예외로 변경`해줌 : 특정DB의 예외가 터지면 서비스 계층까지 올라옴    
      --> DB를 변경하면 예외 자체가 `변경`됨   
      --> Repository계층의 A디비에서 B디비로 변경되어 `다른 예외`가 올라오면 서비스 계층, 다른계층의 코드가 흔들림    
      --> 이런것들을 방지하기위해 스프링이 예외를 추상화해 반환함)

  > * `@Configuration` 스프링 설정 정보로 인식하고, 스프링 빈이 `싱글톤을 유지하도록 추가 처리`한다.
      > *` @Service` 특별한 처리를 하지 않음, 대신 개발자들이 `핵심 비즈니스 로직`이 여기에 있다는 비즈니스 계층을 인식하는데 도움이 된다.

  **[참고] :** useDefaultFilters 옵션은 기본으로 켜져있는데, 옵션을 끄면 기본 스캔 대상들이 제외된다.


* #### 헷갈릴 만한 사항 정리
  > * `ApplicationContext`가 바로 `스프링 자체`, ApplicationContext를 이용해 `특정 클래스 정보를 받아야 @ComponentScan이 가능`해짐   
      @ComponentScan의 결과로 스프링빈을 스프링 컨테이너에 등록해야하는데, ApplicationContext가 없으면 등록할 `스프링 컨테이너 자체가 존재하지 않아짐`   
      쉽게 이야기해 ApplicationContext가 본인의 스프링 컨테이너에 등록할 빈을 찾기위해 `@ComponentScan을 실행`한다고 이해하면 된다.

  > * 현재 core 프로젝트에 스프링 부트의 어플리케이션인 CoreApplication 내부에 `@SpringBootApplication`이 `프로젝트에 미치는 영향`은 없을까?
  > * 단순히 코드만 존재하고 사용하지 않아옴, CoreApplication을 동작하기 위해선 해당 클래스의 `main()을 호출`하거나 또는 테스트에서 `@SpringBootTest를 이용`해
      부트와 통합하는 테스트를 진행해야 함
  > * CoreApplication을 사용하면 부트가 내부에서 생성하는 ApplicationContext를 사용한다. `우리는 직접 스프링 코어인 ApplicationContext를 생성해 사용`했으므로
      영향을 받는 부분은 없다.

  > * `exclude`로 제외한 `@Configuration`이 있다. AutoAppconfig또한 마찬가지로 @Configuration 붙어있는데 exclude 안당하고 어떻게 돌아갈까?
  > * `new Annotation....(AutoAppConfig.class);`에 넣어주기 때문

  > * `@SpringBootAnnotation`은 `@ComponentScan`이 내부 코드에 들어가 있으므로 최상단에 위치해야함 그렇다면 CoreApplication은 어떻게 빈 등록이 될까?
      내부에 `run메소드`로 `CoreApplication.class`를 넘겨주는데 부트가 이를가지고 `자동으로 해당 클래스를 빈으로 등록`


* #### Spring core vs Spring Boot 사용
  **[Spring core]**
  > * new AnnotationConfigApplicationContext(AutoAppConfig.class);
    1. ApplicationContext(스프링 컨테이너) 생성
    2. AutoAppConfig를 스프링 빈으로 등록
    3. AutoAppConfig에 @ComponentScan을 찾고 @Component(@Controller, @Repository, @Service, @Configuration 포함)이 붙은 클래스를 스프링 컨테이너 빈으로 등록


**[Spring Boot]**
* 상황 1-1. @SpringBotApplication이 붙어있는 class의 `메인함수에서 실행`
* 상황 1-2. @SpringBootTest `테스트 실행` -> @SpringBootApplication 어노테이션을 찾아감

2. 스프링부트 내부에서 `자동으로` ApplicationContext(스프링 컨테이너)를 생성

3. @SpringBootApplication에는 `@ComponentScan이 포함`되어 있음.   
   -> @Component(및 다른 스캔되는 어노테이션)이 달려있는 클래스를 스프링 컨테이너 빈으로 등록   
   (@Configuration도 @Component가 내부적으로 포함되어 있으므로 달려있는 설정 클래스도 빈으로 컨테이너에 `등록`, 이 때 만약 @Bean이 있으면 이 또한 컨테이너에 빈으로 `등록`된다.)

<br>
<br>
<br>

### < --------------------------- 필터 --------------------------- >

* #### `includeFilters` : 컴포넌트 스캔 대상을 추가로 지정한다.
* #### `excludeFilters` : 컴포넌트 스캔에서 제외할 대상을 지정한다.

**[TEST]**
* #### 사용자 임의의 어노테이션 만들기
    * > Annotation 파일을 만들고 기본적으로 3가지의 어노테이션을 붙여야 커스텀 어노테이션이 된다.
        * `@Target(ElementType.TYPE)` : 해당 어노테이션이 사용되는 위치를 결정함(여기서는 TYPE을 이용)
            * ElementType.TYPE은 클래스 / 인터페이스 / 열거 타입(enum)을 뜻한다.
        * `@Retention(RetentinoPolicy.RUNTIME)` : Reflection을 사용하여 컴파일 이후에도 JVM에 의해 계속 참조가 가능함
        * `@Documented` : JavaDoc 생성 시 Document에 포함되도록 함

* #### 컴포넌트 스캔 대상에 추가하고, 제외할 어노테이션 2개를 생성한다.
    * > 각각 MyIncludeComponent, MyExcludeComponent로 생성

* #### 테스트를 위한 임의의 빈 클래스 2개 생성
    * > BeanA, BeanB생성 BeanA는 @MyIncludeComponent를, BeanB는 @MyExcludeComponent 어노테이션을 붙인다.

* #### ComponentFilterAppConfigTest
  > * 내부에 필터를 적용할 config 파일, ComponentFilterAppConfig를 static으로 선언하고,
  > * 설정 파일임을 알리기 위해 @Configuration을 붙인다.
  > * 또한 빈 생성을 위한 @ComponentScan도 붙이지만 내부에 include, excludeFilters에 커스텀 어노테이션을 알맞게 적용한다.
  > ```java
    > @Configuration    // 컴포넌트 스캔도 사용하며 동시에 @Bean으로 수동 등록도 함께 사용하는 경우가 있어서 적음(없어도 정상 동작)
    > @ComponentScan(
    >         includeFilters = Filter(type = FilterType.ANNOTATION, classes = MyIncludeComponent.class),
    >         excludeFilters = Filter(type = FilterType.ANNOTATION, classes = MyExcludeComponent.class)
    > )
    > static class ComponentFilterAppConfig {
    > }
    > ```
  > * 이후 ac.getBean("beanA", BeanA.class); 로직이 null이 아님을 증명하고
  > * ac.getBean("beanB", BeanB.class); 로직이 null임을 증명하는 테스트를 작성하게 되면
  > * 아래와 같은 사항을 검증 할 수 있다.
  >> 1. includeFilters 에 MyIncludeComponent 애노테이션을 추가해서 BeanA가 스프링 빈에 등록된다.
  >> 2. excludeFilters 에 MyExcludeComponent 애노테이션을 추가해서 BeanB는 스프링 빈에 등록되지 않는다.


* #### FilterType의 옵션 5가지
    1. `ANNOTATION` : 기본값, 어노태이션을 인식해서 동작한다.
        * ex) org.example.SomeAnnotation
    2. `ASSIGNABLE_TYPE` : 지정한 타입과 자식 타입을 인식해서 동작함   
       (어노테이션이 아닌 클래스를 직접 지정할 수 있다.)
        * ex) org.example.SomeClass
    3. `ASPECTJ` : AspectJ 패턴 사용
        * org.example..*Service+
    4. `REGEX` : 정규 표현식
        * org\.example\.Default.*
    5. `CUSTOM`: TypeFilter 이라는 인터페이스를 구현해서 처리
        * org.example.MyTypeFilter

<br><br>

* 만약 BeanA도 빼고 싶으면 다음과 같이 추가하면 된다.
```java
    @ComponentScan(
        includeFilters = {
                @Filter(type = FilterType.ANNOTATION, classes =
                        MyIncludeComponent.class),
        },
        excludeFilters = {
                @Filter(type = FilterType.ANNOTATION, classes =
                        MyExcludeComponent.class),
                @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = BeanA.class)
        }

```

**[참고]**
> @Component의 기능이면 충분하므로, includeFilters를 사용할 일은 거의 없다. excludeFilters는 여러가지 이유로   
> 간혹 사용할 때가 있지만 많지는 않음.   
> 특히 최근 스프링 부트는 컴포넌트 스캔을 기본으로 제공해주는데, 옵션을 변경하면서 사용하기 보다는   
> `스프링의 기본 설정에 최대한 맞추어 사용하는 것을 권장한다.`

<br>
<br>
<br>

### < --------------------------- 중복 등록과 충돌 --------------------------- >
* 컴포넌트 스캔에서 같은 빈 이름을 등록하면 어떻게 될까? 다음과 같이 두가지의 상황이 존재한다.
    1. 자동 빈 등록 vs 자동 빈 등록
    2. 수동 빈 등록 vs 자동 빈 등록

* #### 자동 빈 등록 vs 자동 빈 등록
    * 컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록되는데, 이름이 같은 경우 스프링은 오류를 발생시킴
        * `ConflictingBeanDefinitionException` 예외 발생

* #### 수동 빈 등록 vs 자동 빈 등록
    * 임의로 AutoAppConfig에 @Bean을 이용해 수동 등록할 빈을 생성한다. (memoryMemberRepository)
    * 이후 AutoAppConfigTest를 실행하면 Overriding bean definition for bean 'memoryMemberRepository' with a different definition: replacing
    * 메시지의 의미는 수동 빈이 자동 빈을 `오버라이딩` 했다 왜? 수동 빈 등록이 `우선권`을 가지므로
      > 개발자가 의도한 상황보다는 실무에선 여러 설정들이 꼬여서 위와같이 오버라이딩 되는 경우가 대부분이다.   
      그렇게 되면 정말 잡기 어려운 버그가 발생됨(`애매한 버그`)   
      최근 스프링 부트는 수동 빈 등록과 자동 빈 등록이 충돌나면 오류가 발생하도록 기본 값을 바꾸었다.

* #### 수동 빈 등록, 자동 빈 오류시 스프링 부트 에러
    > * Consider renaming one of the beans or enabling overriding by setting 
        `spring.main.allow-bean-definition-overriding=true`   
    > * 실제 CoreApplication을 실행해보면 볼 수 있다.

    > resources/ 아래에 `application.properties`에 spring.main.allow-bean-definition-overriding=true 설정하면
    기존의 스프링 처럼 수동 빈이 오버라이딩 된다.
    >> @SpringBootApplication은 내부에 @ComponentScan을 가지고 있음, 따라서 이곳의 필터는 아무 설정도 없으므로
    AppConfig의 bean들이 수동으로 등록되어 오버라이딩 된다.
    <br><br>
      `call AppConfig.memberRepository`   
      `call AppConfig.memberService`   
      `call AppConfig.orderService`

* #### 왜 스프링 부트는 이런 결정을 내렸을까?
  * 문제가 하도 많이 일어나서
    > 개발은 명확하지 않은것은 하면 안된다.   
    여러명의 개발자가 동시 개발하므로 애매한 상황을 만들면 안된다.
  
  * 예를들어 두 가지의 경우가 있다고 해보자
    1. 코드가 줄어들고 이뻐지는 방향, 하지만 약간 불명확한 부분이 생김
    2. 코드의 중복이 있지만 명확하고 한눈에 들어옴
    > 이럴떄는 명확한것을 선택하는것이 대부분의 경우에서 낫다. 어설픈 추상화, 우선순위가 있으면
    이런 곳에서 발생하는 버그가 정말 잡기 힘든 버그가 된다. (명확하게 하거나 빨리 오류를 발생시키거나)

<br>
<br>
<br>

### < --------------------------- 다양한 의존관계 주입 방법 --------------------------- >
* ### 의존관계 주입은 크게 4가지 방법이 있다.
  * 생성자 주입
  * 수정자 주입(setter 주입)
  * 필드 주입
  * 일반 메서드 주입
<br><br>
* ### 생성자 주입
  * 이름 그대로 생성자를 통해서 의존 관계를 주입받는 방법.
  * 지금까지 우리가 진행한 방법임
  * 특징
    * 생성자 호출시점에 딱 `1번만 호출되는 것이 보장`된다.
      * 따라서 첫 호출때 세팅하고 이후에 값을 변경하지 못하게 할 수 있다는 장점이 있다.
    * **불변(딱 1번만 호출), 필수** 의존관계에 사용   
    **[불편 의존관계]**
      * 개발에서 불변은 매우 중요 : 좋은 개발 습관은 제약이 있는것(한계점, 제약) 다 열어두면 무엇을 수정해야할지 모름
      * 어느 누구도 OrderServiceImpl내 의존객체들을 첫 호출 이후로 수정할 수 있는 방법이 없다.
    * 불변 의존관계로 설정하면 필드들은 값이 꼭 있어야 하므로 final로 선언   
    (**[필수 의존관계]** 생성자 파라미터로 인자가 반드시 들어와야 함, 따라서 인자로 들어오는 객체는 스프링 빈이어야 한다.)
        ```java
        // OrderServiceImpl's Fields
        // 2.회원조회를 위한 필드 선언
        private final MemberRepository memberRepository;
        // 3. 할인적용을 위한 필드 선언
        private final DiscountPolicy discountPolicy;
        ```
    **[중요 사항]**
    * 생성자가 딱 1개만 있으면 @Autowired를 생략해도 자동 주입 된다. 물론 스프링 빈에만 해당한다.
      * @Bean 혹은 @ComponentScan으로 등록해도 마찬가지다
<br><br>
* ### 수정자(Setter) 주입
  > Setter주입을 하기 위해 임시로 final키워드를 제거한다*.
  * setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법   
    (파라미터에 명시된 타입을 가지고 해당 타입으로 받을 수 있는 빈을 조회함)
  * 특징
    * **선택, 변경** 가능성이 있는 의존관계에 사용  
      * **[선택 가능성]**
        * 생성자 주입은 필수 값이지만, 수정자는 특정 의존성이 주입이 되지 않아도 사용할 수 있다.   
          (선택적으로 의존성 주입)
        * 선택적으로 주입하기 위해선 `@Autowired(required = false)`옵션을 주면 된다.   
      * **[변경 가능성]**
        * 중간에 인스턴스를 변경하고 싶으면 외부에서 강제로 호출할 수 있음(그럴일은 거의 없지만)
    * 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법
    <br><br>
  * 스프링 컨테이너는 크게 두가지 `Life Cycle`이 존재
    * 스프링 빈을 모두 등록
    * 의존관계를 자동으로 주입(@Autowired)
      <br><br>
  * 생성자 주입은 객체가 생성되고 빈을 등록하면서 주입도 `동시에` 이루어진다.
    * 객체를 생성할때 생성자가 실행되고 @Autowired를 발견한 스프링이 동시에 의존성도 주입하기 떄문이다.
      <br><br>
  * 반면에 수정자 주입은 `객체 생성이 먼저`되고(스프링 빈 모두 등록) 이후 `의존관계를 자동으로 주입`하는 단계로 나뉜다.
    * 수정자 주입시 주입되는 순서는 보장되지 않음(생성자 주입만 순서가 보장됨)
      <br><br>
  * 또한 이렇게 수정자를 이용하면 생성자가 필요 없어짐
  
<br><br>
  
**[참고]** : @Autowired의 기본 동작은 주입할 대상이 없으면 오류가 발생한다. 주입할 대상이 없어도 동작하게 하려면
`@Autowired(required = false)`로 지정하면된다.`(선택 가능성)`

**[참고]** : 자바빈 프로퍼티, 자바에서는 과거부터 필드의 값을 직접 변경하지 않고, setXxx, getXxx라는 메소드를 
통해서 값을 읽거나 수정하는 규칙을 만들었는데, 그것이 자바빈 프로퍼티 규약이다.

* ### 필드 주입
  * 이름 그대로 필드에 바로 주입하는 방법이다.
  * 특징
    * 코드가 간결해서 많은 개발자들을 유혹하지만 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점 존재.   
      (스프링 없이 순수한 자바코드로 테스트 할 수 없음 : 생성자, 수정자가 없으므로 필드에 값 주입 불가)
    * DI 프레임워크가 없으면 아무것도 할 수 없다. (생성자, 수정자가 없으므로 순수 자바코드로 주입 할 방법 없음)
    * 사용하지 말자!
    * 필드 주입이 사용되는 특수한 상황
      * 애플리케이션의 실제 코드와 관계 없는 테스트 코드
      * 스프링 설정을 목적으로 하는 @Configuration 같은 곳에서만 특별한 용도로 사용

<br><br>
**[참고]:** 순수한 자바 테스트 코드에는 당연히 @Autowired가 동작하지 않는다. `@SpringBootTest`처럼 스프링
컨테이너를 테스트에 통합한 경우에만 가능하다.

**[참고]:** 다음 코드와 같이 `@Bean`에서 파라미터에 의존관계는 자동 주입된다. 수동 등록시 자동 등록된 빈의
의존관계가 필요할 때 문제를 해결할 수 있다.
```java
@Bean
OrderService orderService(MemberRepository memberRepoisitory, DiscountPolicy
        discountPolicy) {
        new OrderServiceImpl(memberRepository, discountPolicy)
        }
```

* ### 일반 메소드 주입
  * 일반 메소드를 통해서 주입 받을 수 있다.
  * 특징
    * 한번에 여러 필드를 주입 받을 수 있다.
    * 일반적으로 잘 사용하지 않는다.(생성자, 수정자 주입으로 해결할 수 있으므로)
```java
@Component
public class OrderServiceImpl implements OrderService { 
    
  private MemberRepository memberRepository;
  private DiscountPolicy discountPolicy;
  
  @Autowired
  public void init(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
    this.memberRepository = memberRepository;
    this.discountPolicy = discountPolicy;
  }
}
```
**[참고]:** 당연한 이야기지만 의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 빈이어야 동작한다.
스프링 빈이 아닌 `Member`같은 클래스에서 `@Autowired` 코드를 적용해도 아무 기능도 동작하지 않는다.

<br>
<br>
<br>

### < --------------------------- 옵션 처리 --------------------------- >
* 주입할 스프링 빈이 없어도 동작해야 할 때가 있다.
* 다만 `@Autowired`만 사용하면 `required`옵션의 기본값이 `true`로 되어있어 자동 주입 대상이 없으면 오류가 발생한다.

* 자동 주입 대상을 옵션으로 처리하는 방법은 아래와 같음
  * `@Autowired(require=false)` : 자동 주입할 대상이 없으면 수정자 메소드 자체가 `호출 안됨`
  * `org.springframework.lang.@Nullable` : 자동 주입할 대상이 없으면 `null`이 입력된다.
  * `Optional<>` : `Java8`의 문법(공부하자) 자동 주입할 대상이 없으면 `Optional.empty`가 입력된다.

* 자세한 사항은 test.java.hello.core.autowired.AutowiredTest의 `AutowiredOption` 테스트를 확인해보자
  * 여기서 사용되는 Member는 `스프링 빈`이 아니다 : 따라서 스프링을 이용해 자동 주입을 하려하면 당연히도 객체가 존재하지 않는다.
  
**[참고]** : `@Nullable`, `Optional`은 스프링 전반에 걸쳐서 지원된다. 예를들어 생성자 자동 주입에서 특정 필드에만 사용해도
된다.

<br>
<br>
<br>

### < --------------------------- 생성자 주입을 선택해라! --------------------------- >
* 과거에는 수정자 주입과 필드 주입을 많이 사용했지만, 최근에는 스프링을 포함한 DI프레임워크 대부분이 생성자 주입을 권장함
이유는 아래와 같다.

**[불변의 장점]**
* 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다.   
  오히려 대부분의 의존관계는 애플리케이션 종료 전까지 변하면 안된다.(불변해야함)
* 수정자 주입을 사용하면, setXxx 메소드를 public으로 열어두어야 한다.
* 누군가 실수로 변경할 수 도 있고, 변경하면 안되는 메서드를 열어두는 것은 좋은 설계 방법이 아니다.
* 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이후에 호출되는 일이 없다. 따라서 불변하게 설계할 수 있다.


**[누락의 문제]**
* 수정자 의존관계에서 프레임워크 없이 순수한 자바 코드를 단위 테스트 하는 경우에 문제가 발생

```java
public class OrderServiceImpl implements OrderService {
  private MemberRepository memberRepository;
  private DiscountPolicy discountPolicy;
  
  @Autowired
  public void setMemberRepository(MemberRepository memberRepository) {
    this.memberRepository = memberRepository;
  }
  
  @Autowired
  public void setDiscountPolicy(DiscountPolicy discountPolicy) {
    this.discountPolicy = discountPolicy;
  }
//...
}
```
* @Autowired가 프레임워크 안에서 동작할 때는 의존관계가 없으면 오류나지만, 지금은 순수한 자바 코드로만 단위테스트를 수행
한다고 가정한다.   
아래와 같이 테스트를 수행하면 런타임 에러인 NPE(NullPointException)문제가 발생한다.
```java
@Test
void createOrder() {
  OrderServiceImpl orderService = new OrderServiceImpl();
  orderService.createOrder(1L, "itemA", 10000);
}
```
* OrderServiceImpl은 내부적으로 MemberRepository, DiscountPolicy의 의존관계를 가지는데 주입이 누락됐기 때문

> 위와 같은 문제를 생성자 주입을 이용하게 되면 제일 깔끔한 컴파일 오류가 발생한다.   
  또한 IDE에서 바로 어떤 값을 필수로 주입해야 하는지 알 수 있다.

* 아래의 테스트는 생성자 주입을 이용했을때 순수한 자바로 손쉽게 단위테스트를 작성할 수 있음을 보여준다.
```java
    @Test
    void createOrder() {
        // 테스트를 위한 더미 MemberRepository 객체를 생성한다.
        MemoryMemberRepository memberRepository = new MemoryMemberRepository();
        // 테스트를 위한 임의의 Member를 등록한다.
        memberRepository.save(new Member(1L, "name", Grade.VIP));

        // 생성자 주입을 이용해 OrderServiceImpl 객체를 생성함 여기서 new OrderServiceImp();를 이용하면 컴파일 오류 발생
        OrderServiceImpl orderService = new OrderServiceImpl(memberRepository, new FixDiscountPolicy());
        Order order = orderService.createOrder(1L, "itemA", 10000);

        // 검증
        assertThat(order.getDiscountPrice()).isEqualTo(1000);
    }
```

**[final 키워드를 사용가능]**
* 생성자 주입을 사용하면 필드에 `final`키워드를 사용할 수 있다. 그래서 생성자에 혹시라도 값이 설정되지 않게되면
  컴파일 시점에서 알려주어 막아준다.

```java
@Component
public class OrderServiceImpl implements OrderService {
  private final MemberRepository memberRepository;
  private final DiscountPolicy discountPolicy;
@Autowired
public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
  this.memberRepository = memberRepository;
  // this.discountPolicy = discountPolicy; 생략
}
//...
}
```
> 필수 필드인 discountPolicy의 값이 누락되었으므로 컴파일 오류가 발생함   
> (컴파일 오류는 가장 빠르고 좋은 오류)

**[참고]** : 수정자 주입을 포함한 나머지 주입 방식은 모두 생성자 이후에 호출되므로, 필드에 final 키워드를 사용 불가함
오직 생성자 주입 방식만 `final` 키워드를 사용할 수 있다.

**[정리]**
* 생성자 주입 방식은 프레임워크에 의존하지 않고, `순수한 자바 언어`의 특징을 잘 살리는 방법이다.
* 기본으로 생성자 주입을 사용하되, 필수 값이 아닌 경우에는 수정자 주입 방식을 `옵션`으로 부여하면 된다.(`동시 사용 가능`)
* 항상 생성자 주입을 선택하자! 그리고 가끔 옵션이 필요할 경우 수정자 주입을 선택하자. 필드 주입은 지양하는것이 좋다.

<br>
<br>
<br>

### < --------------------------- 롬복과 최신 트랜드 --------------------------- >
* 실제 개발은 대부분이 불변이고, final키워드를 필드에 많이 사용한다.
* lombok을 이용하면 생성자를 작성하고, 주입 받은 값을 대입받고 심지어 getter, setter등 간소화 할 수 있는 라이브러리가 존재한다.



* 롬복 라이브러리 사용
<br><br>
**[기존 코드]**
  ```java
  @Component
  public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;
    
    @Autowired
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
      this.memberRepository = memberRepository;
      this.discountPolicy = discountPolicy;
    }
  }
  ```
  > 여기서 @Autowired는 생성자가 1개뿐이므로 생략가능하다 또한 lombok을 이용하면 아래 코드 처럼 생성자도 생략할 수 있다.
  > @RequiredArgsConstructor

* 롬복 라이브러리가 제공하는 @RequiredArgsContructor를 사용하면 `final`이 붙은 필드를 모아서 생성자를 자동으로 만들어준다.   
  (코드에선 보이지 않지만 실제 호출 가능함)
<br><br>
**[최종 결과]**
  ```java
  @Component
  @RequiredArgsConstructor
  public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;
  }
  ```
  > 이전의 코드와 완전히 동일하며, 롬복이 자바의 애노테이션 프로세서라는 기능을 이용해서 컴파일 시점에 코드를
  > 자동으로 생성해준다. 실제 class를 열어보면 생성자 코드가 추가되어 있다.

**[정리]** : 최근에는 생성자를 딱 1개 두고, @Autowired를 생략하는 방법을 주로 이용한다. 여기에 Lombok라이브러리의
`@RequiredArgsConstructor`를 함께 사용하면 기능은 전부 제공되지만, 코드는 깔끔하게 사용가능하다.

**[롬복 라이브러리 적용 방법(Gradle)]**   
`build.gradle`에 라이브러리 및 환경 추가
```java
plugins {
  id 'org.springframework.boot' version '2.3.2.RELEASE'
  id 'io.spring.dependency-management' version '1.0.9.RELEASE'
  id 'java'
}
group = 'hello'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '11'
        
//lombok 설정 추가 시작
configurations {
  compileOnly {
    extendsFrom annotationProcessor
  }
}

//lombok 설정 추가 끝
repositories {
    mavenCentral()
}

dependencies {
implementation 'org.springframework.boot:spring-boot-starter'
  //lombok 라이브러리 추가 시작
  compileOnly 'org.projectlombok:lombok'
  annotationProcessor 'org.projectlombok:lombok'
        
  testCompileOnly 'org.projectlombok:lombok'
  testAnnotationProcessor 'org.projectlombok:lombok'
  //lombok 라이브러리 추가 끝
  
  testImplementation('org.springframework.boot:spring-boot-starter-test') {
    exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
  }
}

test {
  useJUnitPlatform()
}
```
* 롬복 라이브러리 적용하기
  1. Preferences(윈도우 File Settings) plugin lombok 검색 설치 실행 (재시작) 혹은 gradle로 의존성 추가
  2. Preferences Annotation Processors 검색 Enable annotation processing 체크 (재시작)
  3. 임의의 테스트 클래스를 만들고 @Getter, @Setter 확인

<br>
<br>
<br>

### < --------------------------- 조회할 빈이 2개이상 - 문제 --------------------------- >
* `@Autowired`는 타입(Type)으로 조회한다.
* 따라서 아래와 같은 코드와 유사하게 동작한다. (실제로는 더 많은 기능 제공)
  ```java
  ac.getBean(DiscountPolicy.class)
  ```
* 스프링 빈 조회에서도 학습 했듯이 타입으로 조회하면 선택된 빈이 2개 이상일떄 문제가 발생한다.
  * 따라서 기존에 RateDiscountPolicy만 @Component를 붙여 스캔했지만, 다른 타입인 FixDiscountPolicy도   
  @Component를 붙여서 조회할 빈이 2개가 되도록 만든다.

* 이후에 AutoAppConfigTest를 돌리게되면 NoUniqueBeanDefinitionException 예외(오류)가 발생한다. 
  ```java
  NoUniqueBeanDefinitionException: No qualifying bean of type 
  'hello.core.discount.DiscountPolicy' available: expected single matching bean
  but found 2: fixDiscountPolicy,rateDiscountPolicy
  ```
  (기대한 것은 싱글 매칭이지만 실제론 동일 타입 2개의 빈이 발견되었다는 오류)

* 의존관계 자동주입시 하위타입 즉 구체클래스를 지정할 수 도 있지만, 이는 DIP를 위배하고 유연성이 떨어짐   
 또한 이름만 다르고, 완전히 똑같은 타입의 스프링 빈이 2개 있을때 해결되지 않는다.

* 스프링 빈을 수동등록해도 되지만, 의존관계 자동주입(@Autowired)에서 해결하는 여러 방법이 존재한다.

<br>
<br>
<br>

### < --------------------------- @Autowired 필드 명, @Qualifier, @Primary --------------------------- >
* 동일한 타입의 스프링 빈이 2개 이상 조회될 떄 해결방법
  * @Autowired 필드, 파라미터 명 매칭방법
  * @Qualifier -> @Qualifier끼리 매 -> 빈 이름 매칭
  * @Primary 사용

1. **@Autowired 필드 명 매칭**
  * `@Autowired`는 타입 매칭을 시도하고, 이 떄 여러 빈이 있으면 필드이름, 파라미터 이름으로 빈 이름을 추가 매칭한다.   
    (생성자 주입시 생성자의 파라미터 이름으로 구분하게 된다.)
  * **필드 명 매칭은 먼저 타입 매칭을 시도하고, 그 결과에 여러 빈이 있을때 추가로 동작하는 기능이다.**

  * @Autowired 매칭 정리
    1. 타입 매칭
    2. 타입 매칭의 결과가 2개 이상일 때 필드명, 파라미터 명으로 빈 이름 매칭
<br><br>
2. **@Qualifier 사용**
    * `@Qualifier`는 추가 구분자를 붙여주는 방법이다. 주입 시 추가적인 방법을 제공하는 것이지 `빈 이름을 변경하는것은 아니다.`

    * 빈 등록시 @Qualifier를 붙여준다.
      ```java
      @Component
      @Qualifier("mainDiscountPolicy")
      public class RateDiscountPolicy implements DiscountPolicy {}
      ```
      ```java
      @Component
      @Qualifier("fixDiscountPolicy")
      public class FixDiscountPolicy implements DiscountPolicy {}
      ```

    * 생성자 자동 주입 예시
      ```java
      @Autowired
      public OrderServiceImpl(MemberRepository memberRepository, 
                        @Qualifier("mainDiscountPolicy") DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
      }

      ```
    * 수정자 자동 주입 예시
      ```java
      @Autowired
      public void setDiscountPolicy(@Qualifier("mainDiscountPolicy") DiscountPolicy discountPolicy) {
          this.discountPolicy = discountPolicy;
      }
      ```
      **[참고]** : `@Qualifier`로 주입할 때 `@Qualifier("mainDiscountPolicy")` 를 못찾으면
      mainDiscountPolicy라는 이름의 스프링 빈을 추가로 찾는다.    
      하지만 경험상 @Qualifier 는 @Qualifier 를 찾는 용도로만 사용하는게 명확하고 좋다.
    
    * 또한 수동으로 빈을 직접 등록할 때도 @Qualifier를 동일하게 사용할 수 있다.
      ```java
      @Bean
      @Qualifier("mainDiscountPolicy")
      public DiscountPolicy discountPolicy() {
        return new ...;
      }
      ```
      
    * **@Qualifier와 Lombok의 @RequiredArgsConstructor 같이 사용하기**
      * java/main/에 `lombok.config` 생성
      * `lombok.copyableAnnotations += org.springframework.beans.factory.annotation.Qualifier` 작성
      * 재 빌드 후 아래와 같이 @Qualifier를 이용하면 사용할 수 있다.
      ```java
      @Component
      // final이 붙은 필드를 가지고 매개인자가 있는 생성자를 자동으로 만들어준다. 또한 생성자가 1개면 @Autowired도 생략가능
      @RequiredArgsConstructor
      public class OrderServiceImpl implements OrderService {
          private final MemberRepository memberRepository;
          // 롬복의 @RequiredArgsConstructor와 @Qualifier 같이 사용하기
          @Qualifier("mainDiscountPolicy")
          private final DiscountPolicy discountPolicy;
      ```
      > Qualifier를 지우고 필드 이름을 mainDiscountPoilicy로 변경하는 것도 방법
3. @Primary 사용
    * `@Primary`는 우선순위를 정하는 방법, @Autowired 시에 여러 빈이 매칭되면 `@Primary`가 우선권을 가짐.   
      (편하긴 하지만 한계점을 가진다.)

    * rateDiscountPolicy가 우선권을 가져야 한다면 아래와 같이 이용 가능하다.
   ```java
   @Component
   @Primary
   public class RateDiscountPolicy implements DiscountPolicy {}
   
   @Component
   public class FixDiscountPolicy implements DiscountPolicy {}
   ```
   > 이렇게 되면 생성자, 수정자는 수정할 코드가 없이 @Primary가 지정된 RateDiscountPolicy의 객체를 자동으로
   > 주입받을 수 있다.

    * 여기까지 보면 @Primary 와 @Qualifier 중에 어떤 것을 사용하면 좋을지 고민이 될 것이다.   
      @Qualifier 의 단점은 주입 받을 때 다음과 같이 `모든 코드에` @Qualifier 를 붙여주어야 한다는 점이다.   
      반면에 @Primary 를 사용하면 이렇게 @Qualifier 를 `붙일 필요가 없다`.
<br><br>
    * **@Primary, @Qualifier 활용**
      > 코드에서 자주 사용하는 메인 데이터베이스의 커넥션을 획득하는 스프링 빈이 있고,   
       코드에서 특별한 기능으로 가끔 사용하는 서브 데이터베이스의 커넥션을 획득하는 스프링 빈이 있다고 생각해보자.   
       메인 데이터베이스의 커넥션을 획득하는 스프링 빈은 @Primary 를 적용해서 조회하는 곳에서   
       @Qualifier 지정 없이 편리하게 조회하고, 서브 데이터베이스 커넥션 빈을 획득할 때는   
       @Qualifier 를 지정해서 명시적으로 획득 하는 방식으로 사용하면 코드를 깔끔하게 유지할 수 있다.   
       물론 이때 메인 데이터베이스의 스프링 빈을 등록할 때 @Qualifier 를 지정해주는 것은 상관없다.

      * 즉 공통적으로 많이 사용되는 부분은 @Primary를 이용해 Default로 이용하면 편리하고,   
      많이 사용되지 않는 서브 데이터베이스와 같은것들은 사용할때만 @Qualifier로 특정지어서 사용할 수 있다.   
      다만 메인 데이터베이스의 스프링 빈을 등록할때 @Qualifier를 같이 지정해도 상관은 없다.
<br><br>
      * **@Primary와 @Qualifier의 우선순위**
        * `@Primary`는 기본값 처럼 동작하고 `@Qualifier`는 좀 더 섬세하기 동작한다.   
          이런경우 스프링은 자동보다 수동이, 넓은 범위의 선택권 보다는 좁은 범위의 선택권이 우선 순위가 높다.   
          따라서 여기서도 `@Qualifier`가 우선순위가 높다.

      * 롬복에서는 우선 주입을 원하는 구체 클래스에 @Primary를 붙이고 사용하면 된다.

<br>
<br>
<br>

### < --------------------------- Annotation 직접 만들기 --------------------------- >
* `@Qualifier("mainDiscountPolicy)` 이렇게 문자를 적으면 컴파일시 타입 체크가 안된다.   
  따라서 다음과 같은 애노테이션을 만들어서 문제를 해결 할 수 있다.
  ```java
  @Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE})
  @Retention(RetentionPolicy.RUNTIME)
  @Documented
  @Qualifier("mainDiscountPolicy")
    public @interface MainDiscountPolicy {
  }
  ```
  ```java
  //생성자 자동 주입
  @Autowired
  public OrderServiceImpl(MemberRepository memberRepository,
  @MainDiscountPolicy DiscountPolicy discountPolicy) {
    this.memberRepository = memberRepository;
    this.discountPolicy = discountPolicy;
  }
  //수정자 자동 주입
  @Autowired
  public void setDiscountPolicy(@MainDiscountPolicy DiscountPolicy
  discountPolicy) {
    this.discountPolicy = discountPolicy;
  }  
  ```

  
* 미리 정의 해놓은 @MainDiscountPolicy를 이용하면 내부적으로 @Qualifier("mainDiscountPolicy)가 있으므로 동일하게 사용 가능하다.
* 또한 여러곳에서 사용할 때 오류 확률을 줄여주고, 추가로 이름 변경이 필요할 때 한곳에서 변경하면 해결된다는 장점도 가진다.

**[정리]** : 애노테이션은 상속이라는 개념이 없다. 이렇게 여러 애노테이션을 모아서 사용하는 기능은 스프링이 제공해주는 기능이다.   
@Qualifier 뿐만 아니라 다른 애노테이션들도 함꼐 조합해 사용 가능하다.   
또한 @Autowired도 재 정의 할 수 있지만, 스프링이 제공하는 기능을 뚜렷한 목적없이 무분별하게 재정의 하는 행위는   
유지보수에 더욱 혼란만 가중 시킬 수 있으니 유의하자.


**[알아두기]**    
1. @Qualifier 자체에   @Target, @Retention, @Documented 어노테이션이 있으니 생략해도 괜찮지 않을까?
  > 자바 애노테이션은 언어적으로 내부의 애노테이션이 포함되어도 그 부분이 적용되지 않음.   
    하지만, 스프링이 일부 포함된 애노테이션을 추가로 읽어서 가능하게 도와주는 것이다.
    자바 애노테이션은 자바 언어가 컴파일 되는 시점에 적용되는 부분이 있고, 스프링을 사용하며 적용하는 부분이 존재.   
    여기서 위의 애노테이션들은 자바 언어가 컴파일 할 때 사용하는 애노테이션이므로 내부에 포함해도(@Qualifier안에)
    적용이 되지 않는다.
2. @RequiredArgsConstructor와 커스텀 애노테이션(@MainDiscountPolicy) 같이 이용하기
  > 이전에 @Qualifier와 @RequiredArgsConstructor를 같이 이용하기 위해서 lombok.config에 설정을 추가했다.   
    @MainDiscountPolicy는 새로운 어노테이션을 만든것이므로 같이 이용하기 위해선   
    lombok.copyableannotations 설정을 추가해야한다.   
    `lombok.copyableannotations += hello.core.annotation.MainDiscountPolicy`
3. 커스텀 애노테이션의 권상 사항
   > 애노테이션을 만들면 코드로 추적할 수 있다는 장점이 있다. 하지만 대부분의 문제들은 커스텀 애노테이션 없이   
   @Qualifier, @Primary등 만 사용해도 문제를 해결 할 수 있다.   
   커스텀 애노테이션이 많으면 그것 자체가 부담이 될 수 있으므로 정말 중요하다고 판단되는 곳에 아주 일부에 한해서   
   부분적으로 적용하는 것을 권장한다.

<br>
<br>
<br>

### < --------------------------- 조회한 빈이 모두 필요할 때, List, Map --------------------------- >
* 의도적으로 해당 타입의 스프링 빈이 전부 필요한 경우도 존재
  * 할인 서비스를 제공할 때, 클라이언트(고객)가 할인의 종류(Rate, Fix)를 선택할 수 있다고 가정
  * 스프링을 사용하면 소위 Strategy pattern을 간단하게 구현할 수 있다.
```java
    static class DiscountService {
        private final Map<String, DiscountPolicy> policyMap;
        private final List<DiscountPolicy> policies;

        @Autowired  // 컬렉션 객체들도 자동주입이 가능하다. 일반적으로 Map은 key값으로 빈의 이름을, value로 객체를 삽입한다.
        public DiscountService(Map<String, DiscountPolicy> policyMap, List<DiscountPolicy> policies) {
            this.policyMap = policyMap;
            this.policies = policies;
            System.out.println("policyMap = " + policyMap);
            System.out.println("policies = " + policies);
        }

        // Member객체와 가격, 정책코드를 넘겨주고 Map에서 알맞은 정책 코드를 이용해 실제 할인율을 넘겨주는 로직
        public int discount(Member member, int price, String discountCode) {
            DiscountPolicy discountPolicy = policyMap.get(discountCode);

            System.out.println("discountCode = " + discountCode);
            System.out.println("discountPolicy = " + discountPolicy);

            return discountPolicy.discount(member, price);
        }
    }
```
> 할인정책서비스를 구현 Map을 이용해 모든 정책을 담아놓고 필요한 정책을 받아와서 실제 할인률을 계산하는 discount 메소드를 가짐
```java
public class AllBeanTest {
    @Test
    @DisplayName("해당 타입의 스프링 빈이 다 필요한 경우 : 클라리언트가 할인의 종류를 선택(fix, rate")
    void findAllBean() {
        // DiscountPolicy의 스프링 빈을 이용하기 위해 AutoAppConfig도 스프링 빈으로 등록
        ApplicationContext ac = new AnnotationConfigApplicationContext(AutoAppConfig.class, DiscountService.class);
        DiscountService discountService = ac.getBean(DiscountService.class);
        Member member = new Member(1L, "userA", Grade.VIP);
        // 임의의 멤버, 가격과 정책코드를 넘겨 실제 할인가를 받아옴
        int discountPrice = discountService.discount(member, 10000, "fixDiscountPolicy");

        // fix정책은 무조건 1000원 할인임을 검증
        assertThat(discountPrice).isEqualTo(1000);
        assertThat(discountService).isInstanceOf(DiscountService.class);

        // rate정책은 10%할인율이 적용됨을 검증
        discountPrice = discountService.discount(member, 20000, "rateDiscountPolicy");
        assertThat(discountPrice).isEqualTo(2000);
    }
}
```
> 고객이 할인 정책을 직접 선택해서 실제 할인률을 받아와 검증하는 테스트

* **[로직 분석]**
  * DiscountService는 `Map`으로 `모든 DiscountPolicy`를 주입 받음(fixDiscountPolicy, rateDiscountPolicy)
  * `discount()` 메서드는 discountCode로 "fix, rateDiscountPolicy"중 하나가 넘어오면 Map에서 알맞은 `스프링 빈`을
  찾아서 실행한다.
<br><br>
* **[주입 분석]**
  * `Map<String, DiscountPolicy>` Map의 키에 스프링 빈의 이름을 넣어주면 값으로 `DiscountPolicy`값으로 조회한 모든
  스프링 빈을 담아준다.
  * `List<DiscountPolicy>`는 DiscountPolicy타입으로 조회환 모든 스프링 빈을 담음.
  * 해당하는 타입의 스프링 빈이 없다면, `빈 컬렉션`이나 `Map`을 주입한다.
<br><br>

* **[참고 - 스프링 컨테이너를 생성하면서 스프링 빈 등록하기]**
  * 스프링 컨테이너는 생성자에 클래스 정보를 받음, 여기에 클래스 정보를 넘기면 해당 클래스가 스프링 빈으로 자동 등록된다.
  * `new AnntationConfigApplicationContext(AutoAppConfig.class, DiscountService.class);`
    * 위 코드는 2가지로 이해할 수 있다.
      1. new AnnotationConfigApplicationContext();를 통해 스프링 컨테이너를 생성
      2. AutoAppConfig.class, DiscountService.class를 파라미터로 넘기면서 해당 클래스를 자동으로 스프링 빈으로 등록
  <br><br>
  * 정리하게 되면 스프링 컨테이너를 자동생성과 동시에, 해당 컨테이너에 AutoAppConfig, DiscountService를 스프링 빈으로
  자동 등록한다.
  * 또한 내부에 ComponentScan이나 Configuration을 만나면 스캔을하며 빈을 자동 등록하거나 @Bean을 이용해 수동 빈 등록도
  진행하게 된다.

<br>
<br>
<br>

### < --------------------------- 자동, 수동의 올바른 실무 운영 기준 --------------------------- >
* pdf 파일 참조

* 간단정리   
  * 편리한 자동 기능을 기본으로 사용하자   
  * 직접 등록하는 기술 지원 객체는 수동 등록
    * 데이터베이스 커넥션, 트랜잭션 설정, 공통 로그 처리 같은 부분에서 주로 사용. 공통으로 사용하는 외부 라이브러리를 연동할 때도 사용
  * 다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민해보자   





















































