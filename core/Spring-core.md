### < --------------------------- 좋은 객체 지향 프로그래밍이란? --------------------------- >
* #### 다형성의 본질
  > * 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
  > * 다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야함
  > * 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다. --> 가장 큰 본질

  **[의존하다]** : 내가 상대방을 알고있다.

* #### 스프링과 객체 지향
  > * 다형성이 가장 중요하며, 스프링은 이를 극대화해서 이용할 수 있게함
  > * Spring의 IoC(제어의역전), DI(의존관계 주입)은 다형성을 활용함, 따라서 역할과 구현을 편리하게 나눌 수 있도록 지원함

<br>
<br>
<br>

### < --------------------------- 좋은 객체 지향 설계의 5가지 원칙(SOLID) --------------------------- >
#### 1. SRP(Single Responsibility Principle) 단일 책임 원칙
> * 한 클래스는 하나의 책임만 가져야 한다.
> * 하나의 책임이라는 것은 모호함
> * 클 수도 작을수도
> * 문맥과 상황에 따라 다르다.
> * 중요한 기준은 변경이다.
> * 변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른것(UI변경, 객체의 생성과 사용을 분리)

#### 2. OCP(Open-Closed Principle) 계방-폐쇄 원칙
> * 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
> * 다형성을 활용하면 가능해짐
> * 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능 구현 -- 확장
> * 지금까지 배운 역할과 구현의 분리 생각하면 답이 나옴

**[문제점]**
> * MemberService 클라이언트가 구현 클래스를 직접 선택
> ``` java
   > MemberService m = new MemoryMemberRepository(); // 기존코드
   > MemberService m = new JdbcMemberRepository(); // 변경코드  
   > ``` 
> * 구현 객체를 변경하려면 클라이언트 코드 변경 필요
> * 다형성을 이용했지만 OCP 원칙을 지킬 수 없다.

**[어떻게 해결?]**
> * 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요(Spring이 해줌)

#### 3. LSP(Liskov subsitution principle) 리스코프 치환 원칙
> * 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
> *  다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원히기 위한 원칙,
     인터페이스를 구현한 구현체는 믿고 사용하려면 필요
> * 단순히 컴파일 성공을 넘어서는 이야기   
    ex) 자동차 인터페이스에서 악셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP위반


#### 4. ISP(Interface Segregation Principle) 인터페이스 분리 원칙
> * 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
> * 자동차 인터페이스 -> 운전, 정비 인터페이스로 분리
> * 사용자 클라이언트 -> 운전자, 정비사 클라이언트로 분리
> * 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
> * 인터페이스가 명확해지고, 대체 가능성이 높아짐

#### 5. DIP(Depnedency Inversion Principle) 의존관계 역전 원칙
> * 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
> * 쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
> * 앞에서 이야기한 역할(ROLE)에 의존하게 해야 한다는 것과 같음, 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경가능함
    구현체에 의존하게 되면 변경이 아주 어려워진다.

> * OCP에서 설명한 `MemberService`는 인터페이스에 의존하지만 동시에 구현 클래스도 의존한다.
> * `MemberService` 클라이언트가 구현 클래스를 직접 선택
> ``` java
   > MemberRepository m = new MemoryMemberRepository();
   > ```
> * 이는 DIP 위반

* #### 정리
  > * 객체 지향의 핵심은 다형성
  > * 다형성 만으로는 쉽게 부품을 갈아 끼우듯 개발할 수 없다.
  > * 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
  > * 다형성 만으로는 OCP, DIP를 지킬 수 없다.
  > * 따라서 무엇인가 더 필요하다. ----> Spring

<br>
<br>
<br>

### < --------------------------- 객체 지향 설계와 스프링 --------------------------- >
* #### 스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원
  > * DI(Dependency Injection) : 의존관계, 의존성 주입
  > * DI 컨테이너 제공

* #### 클라이언트 코드의 변경없이 기능 확장
* #### 쉽게 부품을 교체하듯이 개발

* #### 순수하게 자바로 OCP, DIP원칙들을 지키면서 개발을 해보면, 결국 스프링 프레임워크를 만들게됨(더 정확히 DI 컨테이너)

* #### 정리
  > * 모든 설계에 역할과 구현을 분리하자.
  > * 어플리케이션 설계도 공연을 설계하듯 배역만 만들고, 배우는 언제든지 유연하게 변경할 수 있도록 만드는것이 좋은 객체 지향 설계
  > * 이상적으로는 모든 설계에 인터페이스를 부여하자
  > * 인터페이스를 먼저 만들게 되면 구현체에 대한 선택을 최대한 미룰 수 있음

* #### 실무적인 고민을 해보자
  > * 인터페이스를 도입하면 추상화라는 비용이 발생한다.
  > * 코드만 가지고 인터페이스를 보면 구현체가 뭔지 한번 더 들여봐야함
* #### 추천방법
  > * 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법이다.

<br>
<br>
<br>

### < --------------------------- 비즈니스 요구사항과 설계 --------------------------- >
* #### 아래와 같은 요구사항이 있다.

* #### 회원
  > * 회원을 가입하고 조회할 수 있다.
  > * 회원은 일반과 VIP 두 가지 등급이 있다.
  > * 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. (미확정)   
      (인터페이스로 일단 구현)
* #### 주문과 할인 정책
  > * 회원은 상품을 주문할 수 있다.
  > * 회원 등급에 따라 할인 정책을 적용할 수 있다.
  > * 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있다.)
  > * 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다.
      최악의 경우 할인을 적용하지 않을 수 도 있다. (미확정)


* #### 요구사항에서 회원 데이터, 할인 정책은 지금 결정하기 어려운 부분, 그렇다고 결정될때까지 기다릴 수 는 없다.
  따라서 객체지향 설계 방법을 이용해 만들자

<br>
<br>
<br>

### < --------------------------- 회원 도메인 설계 --------------------------- >
* #### 현재 회원 저장소는 아직 자체 DB를 이용할지 외부 시스템과 연동할지 정해지지 않음
  > * 먼저 인터페이스를 우선 만듦 이후 구현체는 (메모리 회원 저장소, DB 회원 저장소, 외부 시스템 연동 회원 저장소)로 나뉨
  > * 하지만 자체 DB로 할지 외부 시스템 연동을 할지 정해지지 않음
  > * 따라서 메모리 회원 저장소를 이용하는데 이는 자바 코드로 회원 객체를 넣다 뺐다 할 수 있는 것을 만들이 일단 개발 진행(실행, 테스트 모두 가능)   
      (후에 변경 가능)

* #### 개념적 그림은 회원 도메인 협력관계, 회원 클래스 다이어그램, 회원 객체 다이어그램 이렇게 그림이 총 3개가 만들어진다.
  > * 회원 도메인 협력관계 : 기획자들도 볼 수 있는 그림
  > * 회원 클래스 다이어그램 : 도메인 협력관계를 바탕으로 개발자들이 만듦
  > * 회원 객체 다이어그램 : 실제 서버를 실행하지 않고 클래스들만 분석해서 볼 수 있음   
      (다만 구현체(메모리 멤버 레포, 디비 레포)들은 동적으로 결정된다, 따라서 객체 다이어그램이 따로 존재함
      이는 실제 `new`로 연결된 인스턴스들 끼리의 참조를 보여줌)

<br>
<br>
<br>

### < --------------------------- 회원 도메인 개발 --------------------------- >

* #### 등급을 위한 `Grade enum` 클래스 정의
* #### ID, 이름, 등급을 가진 `Member` 엔티티 정의
* #### 멤버를 저장하고, id를 통해 멤버를 찾는 인터페이스 정의 : `MemberRepository`
* #### `MemberRepository를` 구현하는 구현체인 `MemoryMemberRepository`를 정의
* #### 회원가입, 회원조회 서비스를 가진 서비스 회원 서비스 인터페이스 정의 : `MemberService`
* #### `MemberService`를 구현하는 구현체인 `MemberServiceImpl` 정의 : 구현체가 하나만 있을경우 관례상 인터페이스명 뒤에 `Impl`을 붙임

<br>
<br>
<br>

### < --------------------------- 회원 도메인 실행과 테스트 --------------------------- >
* #### 간단한 회원 도메인의 인스턴스간 참조 그림은 회원 객체 다이어그램과 동일하게 된다.
  > * 회원 클래스 다이어그램 : 정적인 다이어그램
  > * 회원 객체 다이어그램 : 동적인 다이어그램

* #### 멤버를 만들어 임의로 ID, 이름, 등급을 부여하고 가입을 시킨다.
  > * 이후 findMember 변수로 멤버 서비스의 findMember()메소드를 이용해 가입한 객체를 받아오고
  > * 최종적으로 기존의 member의 이름과, findMember에 저장된 객체의 멤버 이름을 비교하는 로직을 만든다.

  > ```java
  >  public class MemberApp {
  >     public static void main(String[] args) {
  >         MemberService memberService = new MemberServiceImpl();
  >         Member member = new Member(1L, "memberA", Grade.VIP);
  >  
  >         Member findMember = memberService.findMember(1L);
  >         System.out.println("new member = " + member.getName());
  >         System.out.println("find Member = " + findMember.getName());
  >     }
  >  }
  > ```

* #### 하지만 어플리케이션 로직으로 main을 이용한 테스트는 좋은 방법이 아님. --> `JUnit test`를 이용한다.
  > * 눈으로 출력된 콘솔의 결과를 보는것이 아님
  > * 다른코드를 추가 했을때 오류 나는것도 캐치하기 쉬움
  > * 테스트 작성 방법은 필수 (공부하자)

* #### 회원 도메인은 설계의 문제점이 있다.
  > * 만약 다른 저장소로 변경하고자 한다면 OCP원칙을 준수하지 못함
  > * 또한 DIP는 잘 지키고 있을까?
  > * 즉 의존관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점이 있다.
  > * 주문까지 만들고 나서 문제점과 해결 방안을 설명해보자

<br>
<br>
<br>

### < --------------------------- 주문과 할인 도메인 설계 --------------------------- >
* #### 주문과 할인 정책은 다음과 같다.
  > * 회원은 상품을 주문할 수 있다.
  > * 회원 등급에 따라 할인 정책을 적용할 수 있다.
  > * 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있다.)
  > * 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다. 최악의 경우 할인을 적용하지 않을 수 도 있다. (미확정)

* #### 회원의 주문 과정은 아래와 같다.
  > 1. 주문 생성: 클라이언트는 주문 서비스에 주문 생성을 요청한다.
  > 2. 회원 조회: 할인을 위해서는 회원 등급이 필요하다. 그래서 주문 서비스는 회원 저장소에서 회원을 조회한다.
  > 3. 할인 적용: 주문 서비스는 회원 등급에 따른 할인 여부를 할인 정책에 위임한다.
  > 4. 주문 결과 반환: 주문 서비스는 할인 결과를 포함한 주문 결과를 반환한다

* #### 할인 정책과 회원 저장소(인터페이스)는 역할과 구현을 분리해서 언제나 유연하게 구현 객체를 조립하고 변경할 수 있게 설계해야한다.

* #### 클래스 다이어그램은 정적이며 객체 다이어그램은 동적이다.
  > * 우리는 할인정책 구현체를 정액 할인 정책(등급 상관없이 일정금액 할인)과 정률 할인 정책(%단위의 할인)
      2개를 임시로 구현체를 만들것이므로 2개의 주문 도메인 객체 다이어그램이 생성된다.

<br>
<br>
<br>

### < --------------------------- 주문과 할인 도메인 개발 --------------------------- >
* #### 주문과 할인 도메인을 개발해보자

* #### 우선 할인 정책 인터페이스를 만들어야 함
  > * 할인정책 인터페이스는 `discount` 메소드를 가지는데 이는 할인 대상의 할인 금액을 반환한다.
  > * 현재는 정액할인정책만 구현체로 두었고 `Grade가 VIP`일때 1000원 할인된 가격을 반환한다.

* #### 정책설정까지 완료되었고 `Order` 객체를 생성하자
  > *` Order 객체`는 `memberId`, `itemName`, `itemPrice`, `discountPrice`를 필드로 가진다.
  > * 생성자와 기본적인 Getter and Setter를 생성하고 비즈니스 로직 처리를 위한 계산된 할인가격을 구하는 메소드 `calculatePrice()` 생성

* #### 주문 서비스 인터페이스 를 생성하자
  > * `createOrder()`는 주문을 생성하는 메소드이며 주문 도메인에서 정한 `memberId`, `itemName`, `itemPrice`를 인자로 가진다.
  > * 결과값으로 주문결과를 반환한다. (`Order객체`)

**[핵심 로직]**
* #### 주문 서비스 구현체 : OrderServiceImpl 구현체 생성 및 구현 메소드createOrder()의 주문 처리 순서
  > 1. 주문생성을 위해서 `createOrder()`메소드를 구현하고
  > 2. 회원조회를 위해 `MemberRepository` 변수를 필드로 둔다. : 회원 저장소에서 `memberId`를 통해 `Member`를 식별하고 가져온다.
  > 3. 할인적용을 위해 `DiscountPolicy` 변수를 필드로 둔다. : 할인 정책은 `Member` 객체와 상품가격을 넘겨주어 할인가격을 가져온다.   
       (여기서 `OrderService`는 할인가격이 정해지는것에 관심이 없다 모든 할인관련은 전적으로 맡김 따라서 단일책임원칙이 성립한다.)   
       (추가로 `Member` 객체를 넘기는것과, `Grade`값 자체를 넘기는것은 차이가 없으나 프로젝트 상황따라 유동적으로 정한다)
  > 4. 마지막으로 `new Order()`로 주문객체를 생성하고 생성된 주문결과를 반환해준다.

**[코드의 주석과 연관해서 공부]**

<br>
<br>
<br>

### < --------------------------- 주문과 할인 도메인 실행과 테스트 --------------------------- >
* #### main 클래스를 만들자 : `OrderApp`
  > * 임의로 멤버를 생성하고 가입하고
  > * 임의로 상품의 주문을 생성하고
  > * 결과로 출력하면(```toString()```) 정상적으로 할인정책률이 적용된다.

* #### Test 클래스를 만들자
  > * 임의로 멤버를 생성하고 가입하고
  > * 임의로 상품의 주문을 생성하고
  > * 여기서 `Assertions`를 이용해 정말 할인률이 1000원인지 테스트를 한다.
  > * 이렇게 단위테스트를 하고나면 시간이 매우 짧게 소요됨

* #### 수천개의 단위테스트도 매우 짧은시간에 테스트 할 수 있다.
  > * 따라서 테스트는 매우 중요!! 꼭 공부하자
  > * 여기서 말하는 단위테스트는 Spring이나 다른 컨테이너의 도움 없이 순수한 자바코드로 작성하고 테스트 하는것을 말한다.

* #### 이 코드에서 유의할점 `MemberService.join()`으로 가입할때 사용되는 `HashMap`과 `OrderService.createOrder()`시 사용되는 `HashMap`은 서로 다른 ```MemberRepository```의 인스턴스를 2개 가진다 유의하자.

* 그렇다면 정액할인률 정책을 정률 할인 정책으로 변경됐을때 정말 객체지향적으로 설계되었을까?
  ( 다형성을 잘 활용하고, 역할과 구현을 잘 분리했다. 그런데 과연 정률 할인 정책으로 깔끔하게 변경할 수 있을까?)

<br>
<br>
<br>

### < --------------------------- 새로운 할인 정책 개발 --------------------------- >
* #### 기획자의 새로운 요구사항
**[기획자]**
> 서비스 오픈 직전에 할인 정책을 지금처럼 고정 금액 할인이 아니라   
좀 더 합리적인 주문 금액당 할인하는 `정률% 할인`으로 변경하고 싶어요.   
예를 들어서 기존 정책은 VIP가 10000원을 주문하든 20000원을 주문하든 항상 1000원을 할인했는데,   
이번에 새로 나온 정책은 10%로 지정해두면 고객이 10000원 주문시 1000원을 할인해주고,   
20000원 주문시에 2000원을 할인해주는 거에요!


**<개발자>**
>객체지향설계 원칙을 준수 했으므로 가능할거라 생각

* #### 따라서 정말 객체지향설계 원칙을 잘 준수했는지 확인해봐야함
  > * 기존에 `DiscountPolicy`를 구현하는 `FixDiscountPolicy`가 존재하므로 `RateDiscountPolicy`만 추가로 개발하면 됨


* #### RateDiscountPolicy 구현
  > * `DiscountPolicy`를 구현하므로 `discount()`메소드를 구현해야함
  > * 등급이 `VIP등급`이면 현재 가격에서 `10%`를 할인하는 로직 구현
  > * 모든 로직은 테스트가 중요하지만 특히나 할인율을 결정하는 로직은 테스트가 매우 중요   
      (command + shift + T 누르면 테스트 클래스 작성됨)

* #### 테스트 코드 작성 : `RateDiscountPolicyTest`
  > * 테스트의 목적은 `VIP등급`이면 정말 `10%`로의 할인이 되는지 확인해야함
  > * 따라서 `@Test 어노테션` 뿐 아니라 테스트의 이름을 정하는 `@DisplayName("[TEST NAME]")`을 같이 이용한다.

  > * 임의로 `VIP등급`의 멤버를 생성하고 `RateDiscountPolicy.discount()`메소드로 멤버를 넘겨준다
  > * 이후 `Assertions.assertThat(할인금액).isEqualTo(예상금액)`을 이용해 검증한다.

* #### 테스트 코드는 성공 테스트도 중요하지만 실패 테스트도 매우 중요하다.
  > * 새로운 실패 테스트의 이름은` @DisplayName("VIP가 아니면 할인이 적용되지 않아야 한다.")`
  > * 기존의 성공 테스트에서 등급을 `BASIC`으로 두고 실행하면 테스트 오류 발생 --> 정상 동작
  > * 이때의 테스트 메시지는 아래와 같다.
  > * `Expected :1000`
  > * `Actual   :0`		>> 기대한 값은 1000원이지만 실제값은 0원이라는 오류 출력

  > * 혹은 `Assertions.assertThat(할인금액).isEqualTo(0)`으로 두어 `VIP등급`이 아니면 0원이다를 검증할 수 도 있다.

* #### static import
  > * 자바 클래스의 static 메소드는 클래스에 대한 인스턴스의 생성없이 메소드를 사용할 수 있습니다.
  > * 기존에는 assertThat을 사용하기 위해 클래스명.메소드로 이용했지만 `static import`를 하면 메소드의 이름으로만 사용할 수 있다.

  > * `import static org.assertj.core.api.Assertions.*;`


* #### 실무에서의 할인정책 로직은 쉽지 않다. (특히 돈 관련 된 로직은 매우 많은 테스트를 가짐)
  > * 다만 위와 같은 상황은 설계과 잘 되어있기 때문에 쉽게 테스트 할 수 있음   
      (단일 책임 원칙이 잘 지켜져서 할인과 관련된 부분은 할인 부분만 테스트하므로)

* #### 이제 RateDiscountPolicy를 실제 적용을 해보자

<br>
<br>
<br>

### < --------------------------- 새로운 할인 정책 적용과 문제점 --------------------------- >
* #### 새로운 할인정책을 적용하기 위해 `OrderServiceImpl의` 코드를 수정한다.
  > ```java 
  > private final DiscountPolicy discountPolicy = new RateDiscountPolicy();	
  > // 새로운 할인정책 : 정률할인정책 적용 
  > ```

**[문제점]**
* #### 할인정책을 변경하려면 클라이언트인 OrederServiceImpl의 코드를 고쳐야한다.
  > * 역할과 구현 충실히 분리 O
  > * 다형성 활용, 인터페이스와 구현 객체 분리 O
  > * OCP, DIP 같은 객체지향 설계 원칙을 준수? X
  > * DIP :  OrderServiceImple은 DiscountPolicy인터페이스만 의존하는것이 아니라    
      구현체인 Fix, RateDiscountPolicy도 동시에 의존함 따라서 DIP를 위반함
  > * OCP : 변경하지 않고 확장할 수 있을것 같지만 기능을 확장해서 변경하려면   
      클라이언트(OrderServiceImpl)의 코드에 직접적으로 영향을준다 따라서 OCP를 위반함

* #### 이것을 해결하기 위해 인터페이스에만 의존하도록 설계하면
  > * `private DiscountPolicy discounPolicy;` (final은 객체를 생성해야 작성가능)
  > * 위와 같이 작성하면 인터페이스만 의존하지만 `NullPointException`이 발생한다.

* #### 결국 이것을 해결하기 위해선 누군가가 클라이언트(`OrderServiceImpl`)에 `DiscountPolicy의` 구현 객체를 대신 생성하고 주입해야함

<br>
<br>
<br>

### < --------------------------- 관심사의 분리 --------------------------- >
* #### 애플리케이션을 로미오와 줄리엣 공연으로 보자
* #### 우리는 지금까지 로미오 역할(인터페이스)을 하는 디카프리오(구현체)가 줄리엣 역할(인터페이스)을 하는 여자 주인공(구현체)를 직접 초빙하고 있다.

* #### 즉 디카프리오가 공연과 여자 주인공을 공연에 초빙하는 다양한 책임을 가지게 된다.

* #### 관심사를 분리하자
  > * 배우는 본인의 역할인 배역 수행에만 집중 해야함
  > * 따라서 디카프리오는 어떤 상대역이와도 똑같이 공연해야함
  > * 공연구성, 담당배우 섭외, 역할 맞는 배우 지정과 같은 책임은 별도의 공연기획자가 담당해야한다.
  > * 따라서 공연 기획자를 만들어서 배우와 기획자의 책임을 분리해야함

* #### 애플리케이션의 전체 동작 방식을 구성(config)하기 위해, 구현 객체를 생성하고, 연결하는 책임을 가지는 별도의 설정 클래스를 만들어야함
  > * 어플리케이션 전반에 대한 운영을 책임진다.

* #### `AppConfig` 만들기
  > * 현재 만들어진 서비스들을 생성하고 반환해준다. 다만 생성자 주입을 이용해 서비스 구현체에 필요한 의존성을 주입한다.
  > * 이렇게 `AppConfig`가 만들어지면 서비스 구현체는 기존에 new를 통해 의존성을 생성하는 코드가 사라지고 오로지 인터페이스에만 의존하게 된다.
  > * 즉 DIP가 성립된다.

**[AppConfig]**
```java
        // 애플리케이션 전체를 설정하고 구성함
// 구현 객체를 생성하고, 연결하는 책임을 가짐
public class AppConfig {

    // memberService를 만들어보자
    public MemberService memberService() {
        return new MemberServiceImpl(new MemoryMemberRepository());
    }

    public OrderService orderService() {
        return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy());
    }

}
```

**[MemberServiceImpl]**
```java
        public class MemberServiceImpl implements MemberService {

    private final MemberRepository memberRepository;
    // AppConfig를 통해 레포지토리의 구현체를 참조하고, 인터페이스에만 의존함
    // 어떤 레포지토리가 들어올지 모르고, 상관쓰지 않아도 됨
    public MemberServiceImpl(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    @Override
    public void join(Member member) {
        memberRepository.save(member);
    }

    @Override
    public Member findMember(Long memberId) {
        return memberRepository.findById(memberId);
    }
}
```



> 즉, AppConfig는 애플리케이션의 실제 동작에 필요한 구현 객체를 생성함   
> 또한, AppConfig는 생성한 객체 인스턴스의 참조(레퍼런스)를 생성자를 통해서 주입(연결)해준다.   
(OrderServiceImpl도 동일하게 설계)

* #### 결국 설계 변경을 통해 `MemberServiceImpl`은 `MemoryMemberRepository를` 의존하지 않는다. (`OrderServiceImpl`은 `MemoryMemberRepository`, `FixDiscountPolicy를` 의존하지 않음)

  > * 단지 `MemberRepository` 인터페이스만 의존한다.
  > * 또한 서비스 구현체 입장에서 생성자를 통해 `어떤 구현 객체가 들어오는지(주입)`는 알 수 없다.
  > * 생성자를 통해 어떤 구현 객체를 주입될지는 오직 `외부(AppConfig)에서 결정`된다.
  > * 서비스 구현체들은 이제부터 의존관계에 대한 고민은 외부에 맡기고 `실행에만 집중`할 수 있다.(관심사 밖)

* #### `AppConfig가` 객체의 생성과 연결을 담당하게 됨
  > * DIP 완성 : `MemberServiceImpl은` `MemberRepository인` 추상에만 의존, 구체 클래스 몰라도됨.
  > * 관심사의 분리 : 객체를 생성하고 연결하는 역할과 실행하는 역할이 명확히 분리됨.

* #### 세부적으로 `AppConfig는` `MemoryMemberRepository객체를` 생성하고 그 참조값을 `MemberServiceImpl` 객체를 생성하면서 생성자로 전달함
  > * 클라이언트(`MemberServiceImpl`)입장에서 의존관계를 마치 외부에서 주입하는것 같음
  > * 우리는 이를 `DI(Dependency Injection) 의존관계, 의존성 주입`이라고 말함

* #### `OrderServiceImpl도` 동일하다 다만 `DiscountPolicy` 구현체를 하나 더 생성하는것의 차이만 있고 나머지는 동일


* #### `MeberApp` 수정 : 기존에 묵시적 기본생성자를 사용하던 코드들에서 오류가 나므로 수정을 요함
  > * 직접적으로 new를 이용해 MemberServiceImpl객체를 생성하고 MemberServiceImpl에서 MemoryMemberRepository를 생성함   
      (순차적으로 생성되는 모양)
      하지만 이제는 `AppConfig.memberService()`메소드를 이용해` MemberServiceImpl`객체를 `MemberService인터페이스 형식`으로 받아온다.   
      (이 방법은 `AppConfig에서 순차적 생성이 아닌 전부 결정`해준다.)
  > * 나머지 로직은 동일함

* #### `OrderApp` 수정 : 이 또한 위와 동일하게 묵시적 생성자를 사용하던 코드에서 오류가 발생
  > * MemberService, OrderService의 `구현체`들을 `AppConfig`를 이용해 생성하고 주입 받는다.
  > * AppConfig에선 어떤 저장소, 할인정책을 할지 완성시켜놓고 한번에 서비스객체로 주입해준다.

* #### 기존 테스트 코드도 수정 요함 : 기본생성자의 사용으로 인해 오류 발생
  > * AppConfig를 이용해 테스트 동작 전에 서비스 객체를 참조시켜야함
  > * 따라서 `@BeforeEach`를 이용 : 이는 테스트가 실행되기전에 무조건 실행되며 이를 통해 서비스 객체를 할당하고 이후 테스트가 실행됨
  > * 여기서는 AppConfig를 이용해 `의존성 주입 및 서비스 객체를 필드에 대입`한다.

* #### 모든 관심사를 분리 :` DIP를 지켜줌`
  > * AppConfig를 통해서 관심사를 확실하게 `분리`했다.
  > * AppConfig는 공연 기획자다.
  > * AppConfig는 구체 클래스를 선택한다. 배역에 맞는 담당 배우를 선택한다. 애플리케이션이 어떻게 동작해야 할지 `전체 구성을 책임`진다.
  > * 이제 각 `배우들은 담당 기능을 실행하는 책임`만 지면 된다.
  > * `OrderServiceImpl 은 기능을 실행하는 책임`만 지면 된다. : 개발할때도 `인터페이스`만 보고 개발하면 됨(구체클래스가 어떨지 고민X)

* #### 다음 시간에는 AppConfig의 문제점과 더 나은 방향으로의 리팩터링을 배워보자

<br>
<br>
<br>

### < --------------------------- AppConfig 리팩터링 --------------------------- >
* #### 현재 AppConfig를 보면 "`중복`"이 있고, "`역할`"에 따른 "`구현`"이 잘 안보인다. : 설정(구성)정보에선 이렇게 한눈에 보이는것이 중요하다. 따라서 아래와 같이 변경함
```java
    public class AppConfig {
    // 멤버 서비스 역할
    public MemberService memberService() {
        return new MemberServiceImpl(memberRepository());
    }

    // 저장소 역할 : 저장소 변경시 아래 코드만 변경하면 된다.
    private MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }

    // 주문 서비스 역할
    public OrderService orderService() {
        return new OrderServiceImpl(memberRepository(), discountPolicy());
    }

    // 할인 정책 역할 : 정책 변경시 아래 코드만 변경하면 됨
    public DiscountPolicy discountPolicy() {
        return new FixDiscountPolicy();
    }
}
```

* #### 위 방식의 큰 장점은 각 메소드 명을 통해 역할이 전부 드러나고, 각 서비스에 대한 구현과 주입되는 저장소, 정책은 다른 메소드가 담당하므로 `변경 시 정책, 저장소 코드만 변경하면 됨`
  > * 이렇게 해서 설계에 대한 그림이 구성정보에 그대로 드러남 (`역할이 나오고, 역할에 대한 구현이 한눈에 들어옴`)

* #### 이렇게 하게 되면 후에 `new MemoryMemberRepository() 이 부분이 중복 제거`되었다. 이제 MemberRepository,  DiscountPolicy를 다른 구현체로 변경할 때 한 부분만 변경하면 된다

* #### 즉 `AppConfig를 보면 역할과 구현클래스가 한눈에 들어오며`, `애플리케이션 전체 구성이 어떻게 되어있는지 빠르게 파악`할 수 있다.


* #### 다음 시간에 정액할인정책을 정률할인정책으로 변경해보자

<br>
<br>
<br>

### < --------------------------- 새로운 구조와 할인 정책 적용 --------------------------- >
* #### 이전시간에 만든 새로운 구조에서 새로운 할인 정책을 적용해보자 (`RateDiscountPolicy`)
* #### AppConfig 구조가 등장하면서 AppConfig만 변경하면 된다.
  > * AppConfig의 등장으로 애플리케이션이 크게 `사용 영역`과, 객체를 생성하고 `구성(Configuration)하는 영역`으로 분리됨

* #### 따라서 할인정책을 변경하게되면 `AppConfig즉 구성영역의 코드만 변경`되고, 사용영역의 코드는 전혀 변경될 필요가 없다.
  > * `FixDiscountPolicy -> RateDiscountPolicy` 변경시 구성영역만 영향받고, 사용 영역 영향 X
  > * 이제 할인 정책을 변경해도, 애플리케이션의 구성 역할을 담당하는 `AppConfig만 변경`하면 된다.   
      클라이언트 코드인 OrderServiceImpl 를 포함해서 사용 영역의 어떤 코드도 변경할 필요가 없다
  > * 만약 AppConfig를 xml로 작성하면 정말 자바코드 변경없이 사용할 수 있다.

* #### 이렇게 되면서 DIP, OCP가 지켜졌다. `FixDiscount -> RateDiscount 변경 시`
  > * OrderServiceImpl에서 클라이언트 코드는 추상화에 의존하고 있다. : `DIP`
  > * 정책을 확장했지만 구성영역만 코드가 변경하면 되고 클라이언트 코드는 손댈 필요가 없다.   
      따라서 확장에는 열려있지만 변경에는 닫혀있다. : `OCP`

* #### 다음시간에는 지금까지 배운것을 정리해보자

<br>
<br>
<br>

### < --------------------------- 전체 흐름 정리 --------------------------- >
* #### 새로운 할인 정책을 개발
  > * `다형성` 덕분에 새로운 정률 할인 정책 코드를 추가로 개발하는 것 자체는 아무 문제가 없음

* #### 하지만 새로운 할인 정책 적용에서 `문제점`이 있다.
  > 1. 클라이언트 코드인 주문서비스 구현체(OrderServiceImpl)도 함께 변경해야함 -> `OCP위반`
  > 2. 주문서비스 클라이언트가 인터페이스(DiscountPolicy)뿐 아니라 구체 클래스(FixDiscountPolicy도 함꼐 의존함) -> `DIP위반`

* #### 따라서 관심사를 분리함
  > * 애플리케이션을 하나의 공연으로 봄
  > * 기존에는 클라이언트가 의존하는 서버구현 객체를 직접 생성하고 실행함
  > * 남자 배우가 공연뿐 아니라 배우 초빙역할도 담당함
  > * 공연 구성, 배우 섭외등을 지정하는 별도의 공연기획자 필요
  > * `공연 기획자인 AppConfig`가 등장함
  > * AppConfig는 애플리케이션의 전체 동작 방식을 구성(Config)하기 위해, 구현 객체를 생성하고 연결하는 책임을 가짐
  > * 따라서 클라이언트 객체는 자신의 역할을 실행하는 것만 집중, 권한이 줄어듬(`책임이 명확해짐`)

* #### AppConfig 리팩터링
  > * 구성 정보에서 역할과 구현을 명확하게 분리
  > * 역할이 잘 들어남
  > * 중복 제거

* #### 새로운 구조와 할인 정책 적용
    * `정액 할인 정책 -> 정률 할인 정책`으로 변경
    * AppConfig의 등장으로 `애플리케이션이 사용 영역과 객체를 생성하고 구성하는 영역으로 분리`됨
    * 할인정책을 변경해도 AppConfig에 구성영역만 변경하면 되고, 사용 영역은 변경할 필요가 없어짐,    
      따라서 `클라이언트 코드인 OrderServiceImpl도 변경하지 않음`

<br>
<br>
<br>

### < --------------------------- 좋은 객체 지향 설계의 5가지 원칙의 적용 --------------------------- >
* #### 여기서는 3가지 (`SRP, OCP, DIP`)가 적용 된다.

* #### SRP 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 한다.
  > * 클라이언트 객체는 직접 구현 객체를 생성하고, 연결, 실행하는 다양한 책임을 가졌지만
  > * SRP를 따르며 관심사를 분리함
  > * `구현 객체를 생성하고 연결하는 책임은 AppConfig가 담당`
  > * 클라이언트 객체는 실행하는 책임만 담당

* #### DIP 의존 관계 역전 원칙 : 추상화에 의존해야지, 구현체에 의존하면 안된다.
  > * `의존성 주입(DI)`은 이 원칙을 따르는 방법 중 하나
  > * 새로운 할인 정책 적용시 클라이언트 코드도 변경됨 : 추상화 인터페이스와 구체화 구현 클래스도 같이 의존하고 있었기 때문
  > * 따라서 클라이언트 코드가 추상화만 의존하도록 했으나 클라이언트는 인터페이스 만으로 아무것도 할 수 없음(NullPointExceptino)
  > * `AppConfig`가 FixDiscountPolicy 객체 인스턴스를 클라이언트 코드 대신 생성해 클라이언트 코드에 의존관계를 주입함 따라서 DIP 지켜짐

* #### OCP 개방 폐쇄 원칙 : 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
  > * 다형성 사용하고 클라이언트가 DIP를 지킴 : 이렇게 되면 `OCP가 적용될 가능성`이 생김
  > * 애플리케이션을 `사용 영역과 구성 영역`으로 나눔
  > * AppConfig가 의존 관계를 FixDiscountPolicy -> RateDiscountPolicy로 변경해서 클라이언트 코드에 주입하므로 `클라이언트 코드`는 변경하지 않아도됨
  > * "소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀있다."

<br>
<br>
<br>

### < --------------------------- IoC, DI, 그리고 컨테이너 --------------------------- >
* #### 제어의 역전(Inversion of Control)
  > * Spring에 국한된 단어는 아님, 보통은 `개발자가 원하는데로 객체를 생성하고 호출`하고,    
      그 안에서 다음것을 생성하며 직접 제어하는 스타일로 개발을 한다.
  > * `제어의 역전`은 `내가 호출하는것이 아닌 프레임워크 같은것이 코드를 대신 호출해줌`   
      (제어권이 뒤바뀐다하여 제어의 역전이 나옴)

  > * 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성, 연결, 실행함
      (한마디로 구현 객체가 프로그램의 제어 흐름을 스스로 조종 -> `개발자 입장에서 자연스러운 흐름`)

  > * `AppConfig`가 등장하며 구현 객체는 자신의 로직을 실행하는 역할만 담당하고,` 프로그램의 제어 흐름은 이제 AppConfig가 가져감`   
      (`OrderServiceImpl은` 필요한 인터페이들을 호출하지만 어떤 구현 객체들이 실행될지 `모른다`.)

  > * `프로그램 제어 흐름에 대한 권한은 AppConfig가 모두 가지고 있고` 심지어 OrderServiceImpl도 AppConfig가 생성함
      그리고 AppConfig는 OrderServiceImpl이 아닌 OrderService 인터페이스의 다른 구현 객체들을 생성하고 실행할 수 도 있다.
      OrderServiceImpl은 그런 사실을 모르고 자신의 로직을 실행함

  > * 이렇게 `프로그램의 제어 흐름을 직접 제어하는것이 아닌 외부에서 관리하는 것을 제어의 역전(IoC)라고 한다`.

* #### 프레임워크와 라이브러리를 구분할 때 제어의 역전이 사용됨
  > * 프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크가 맞다 (`JUnit`)
  > * 반면에 `내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아닌 라이브러리다`.
  > * 예를들어 자바 객체를 XML, JSON으로 변경하는것이 있는데 그 때 내가 라이브러리를 직접 불러서 사용 --> `라이브러리`

* #### 의존관계 주입 : DI(Dependency Injection)
  > * OrderServiceImpl은 DiscountPolicy 인터페이스에 의존한다. 실제 어떤 구현 객체가 사용될지는 모른다.
  > * 의존관계는 "`정적인 클래스 의존관계`와, `실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계`" 둘을 분리해서 생각해야 한다.


**[ 정적인 클래스 의존 관계 ]**

> * 클래스가 사용하는` import코드`만 보고 의존관계를 쉽게 판단할 수 있다. 정적인 의존관계는 `애플리케이션을 실행하지 않아도` 분석할 수 있다.
> * 클래스 다이어그램에서 OrderServiceImpl은 MemberRepository, DiscountPolicy에 의존하는것을 알 수 있다.
    그런데 이런 `클래스 의존관계 만으로는 실제 어떤 객체가 OrderServiceImpl에 주입될지 알 수 없다`.   
    (클래스 다이어그램에서 상속, 의존, 인터페이스 구현이던 `화살표 방향으로 의존`하고 있다는 것을 알아두자)


**[ 동적인 객체 인스턴스 의존 관계 ]**

> * 애플리케이션 실행 시점에 `실제 생성된 객체 인스턴스의 참조`가 연결된 의존 관계임
> * `객체 다이어그램`을 보면 알 수 있다.

> * 애플리케이션 실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서   
    클라이언트와 서버의 실제 의존관계가 연결되는 것을 "`의존관계 주입`"이라 한다.
> * `객체 인스턴스를 생성`하고, 그 `참조값(객체)을 전달해서 연결`된다.

> * 의존관계 주입을 사용하면 클라이언트 코드를 `변경하지 않고`, 클라이언트가 호출하는 대상의 타입 `인스턴스를 변경`할 수 있다.
> * 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, `동적인 객체 인스턴스 의존관계를 쉽게 변경`할 수 있다.   
    (정적인 그림인 클래스 다이어그램이 전혀 변경되지 않고, 동적인 그림인 객체 다이어그램만 변경시킴
    정적인 다이어그램 손대지 않는다? `애플리케이션 코드를 손대지 않는다와 동일한 말`)



* #### IoC 컨테이너, DI 컨테이너
  > * AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 `IoC 컨테이너 또는 DI 컨테이너`라고 한다.
  > * 의존관계 주입에 초점을 맞추어 최근에는 주로 `DI 컨테이너`라고 한다.
  > * 혹은 `어샘블러`(어플리케이션 전체에 대한 구성을 조립을 해준다), `오브젝트 팩토리`(오브젝트를 만든다고해서) 등으로 불리기도 함

  > * 이런 역할을 `Spring`이 해줌

<br>
<br>
<br>

### < --------------------------- 스프링으로 전환하기 --------------------------- >
* #### 지금까지의 순수한 자바 코드로 진행한 DI를 스프링으로 전환하자

* #### 애플리케이션의 설정정보는 AppConfig에 두었고 Spring은 이런 설정정보 파일에 `@Configuration`을 적게 되어있다.
* #### AppConfig 각 메소드에 `@Bean`을 적어주면 `Spring 컨테이너`에 등록된다.

* #### MemberApp에서 `ApplicationContext<interface>`을 이용한다.
  > * 스프링은 모든것이 `ApplicationContext`로 시작한다 이것을 곧 `스프링 컨테이너로 봐도 됨`
  > * `new AnnotationConfigApplicationContext(AppConfig.class);`를 이용
  > * AppConfig에 있는 annotation기반 환경 설정정보를 가지고 스프링이 `@Bean`이 붙은것들을 스프링 컨테이너에 객체생성한것을 넣고 관리해준다.

* 따라서 객체를 찾아올때는 AppConfig에서 직접 찾아오는것이 아닌 `스프링 컨테이너`를 통해서 찾아옴
  > * `applicationContext.getBean("memberService", MemberService.class);`
  > * 인자의 첫번째는 이름을 줌(이름은 AppConfig의 메소드의 이름이 디폴트로 등록됨), 두번째 인자는 타입을 정하며 이를 지정해야 반환타입이 맞아짐
      > *` memberService`로 받아오고 실행함

* 실행하게 되면 `Creating shared instance of singleton bean`으로 `@Bean`으로 작성한 메소드들이 스프링 컨테이너에 등록이 되었다는 로그가 나타나며 실행된다.
  (AppConfig도 appConfig로 등록됨)
  > * `key`는 `메소드명`, `value`는 `객체 인스턴스들`로 스때프링컨테이너에 등록, 등록된 빈을 꺼낼는 `이름`이나 `타입`을 주고 꺼냄 나머지는 기존코드와 동일

  > * OrderApp도 동일

**[정리]**
* #### `ApplicationContext를 스프링 컨테이너`라 한다.

* #### 기존에는 개발자가 AppConfig를 이용해 직접 객체 생성, DI했지만 이제부터는 `스프링 컨테이너를 통해서` 사용한다.

* #### 스프링 컨테이너는 `@Configuration`이 붙은 `AppConfig를 설정(구성)정보`로 사용한다. 여기서 `@Bean`이라 적힌 메소드를 모두 호출해서 `반환된 객체를 스프링 컨테이너에 등록`한다. 이렇게 스프링 컨테이너에 등록된 객체를 `스프링 빈`이라 한다.

* #### 스프링 빈은 @Bean이 붙은 `메소드의 명을 스프링 빈의 이름으로 사용`함. `(@Bean(name="")으로 변경`도 가능하지만 `관례(default)를 따르는것이 바람직`

* #### 이전에는 개발자가 필요한 객체를 AppConfig를 사용해 직접 조회 했지만, 이제부터는 `스프링 컨테이너를 통해서 필요한 스프링 빈(객체)을 찾아야 한다. 스프링 빈은 applicationContext.getBean() 메소드`를 사용해서 찾을 수 있다.

* #### 기존에는 개발자가 직접 자바코드로 모든 것을 했다면 이제부터는 `스프링 컨테이너에 객체를 스프링 빈으로 등록`하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경되었다.


* #### 의문 : 코드가 복잡해진것 같은데, `스프링 컨테이너를 사용하면 어떤 장점`이 있을까? 천천히 알아보자


* #### 스프링 컨테이너가 해줄 수 있는것은 어마어마하게 많음
  > * `DIP`, `OCP`, `다형성`등을 버무려서 왜 `Spring Container`가 나오게 되었는지 알아봤다.
  > * AppConfig 같은것을 개발자가 직접 만드는것이 아니라 스프링 컨테이너를 이용해 어떤 프로젝트에도 DI나 등등을 스프링이 편하게 해주도록 하는 `범용 프레임워크`가 생김
  > * 지금까지는 `객체지향원리`와 `다형성`만 가지고는 안되는구나를 알고, `DIP`, `OCP`를 지키기위한 설정이 필요한것을 직접 해본것이고 (AppConfig)
  > * 해본 이것 즉, 기존의 AppConfig보다 스프링 컨테이너가 더 낫다하는데, `뭐가 더 나을지`를 설명할것임

<br>
<br>
<br>

### < --------------------------- 스프링 컨테이너 생성 --------------------------- >
* #### 기존에는 Spring의 핵심원리, 객체지향으로 왜 Spring이 만들어졌는지 배웠고, 이제부터는 진짜 스프링 자체에 대해 설명할것

* #### 스프링 컨테이너가 생성되는 과정
```java
  // 스프링 컨테이너 생성
  ApplicationContext applicationContext = AnnotationConfigApplicationContext(AppConfig.class);
```

> * `ApplicationContext`를 `스프링 컨테이너`라 하고, 이는 `인터페이스`다. (`다형성이 적용`되어있다.)

> * 스프링 컨테이너는 `XML`기반 방식과, `Annotation`기반의 자바 설정 클래스(AppConfig)로 만들 수 있다.

> * `자바 설정 클래스` 기반으로 스프링 컨테이너(ApplicationContext)를 만들어보자.
    > *` new AnnotationConfigApplicationContext(AppConfig.class);`
> * 위 클래스는 `ApplicationContext 인터페이스 구현체`이다. (이 외에도 매우 많은 구현체가 존재)

**[참고]**   
더 정확히는 스프링 컨테이너(안에 사용하는 객체를 담은것))를 부를 때 `BeanFactory`, `ApplicationContext`로 구분해서 이야기한다.(뒤에서 설명)   
BeanFactory를 직접 사용하는 경우는 거의 없으므로, 일반적으로 `ApplicationContext`를 `스프링 컨테이너`라 한다.


**[생성과정]**
1. 스프링 컨테이너 생성
    * 스프링 컨테이너 생성(AppConfig.class) --> 스프링 컨테이너 생성됨(내부에 스프링 빈 저장소가 존재하고 key:빈 이름, value:빈 객쳬)
      > * new AnnotationConfigApplication(AppConfig.class);

    * 구성 정보 활용
      > * 스프링 컨테이너 생성시 구성정보를 지정해주어야 하는데, 여기서는 AppConfig.class를 구성정보로 지정했다.
2. 스프링 빈 등록
    * 스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보를 사용해서 스프링 빈을 등록한다.
      > * 넘겨받은 AppConfig.class 구성 정보를 가지고 @Bean이 붙은 메소드들을 호출해서 빈을 등록한다.
      > * 이때 빈 이름은 key로 가지고, 이름에 대한 값은 new로 생성한 객체를 return한 것을 빈 객체로 사용한다.

      > * Bean 이름(key로 가짐) : 빈 이름은 메소드 이름을 사용하거나 혹은 직접 부여할수 도 있다.( @Bean(name="memberService2) )
      > * 다만 빈 이름은 항상 다른 이름을 부여해야함, 같은 이름을 부여하게 되면 다른 빈이 무시되거나, 덮어버리거나, 설정에 따라 오류발생가능성 높음

3. 스프링 빈 의존관계 설정 - 준비
   > * 스프링 컨테이너는 스프링 빈을 등록한 후 의존관계를 설정한다.
   > * 스프링 컨테이너는 설정 정보를 참고해서 의존관계를 주입(DI)한다.
   > * 단순히 자바 코드를 호출하는 것 같지만, 차이가 있다. 이 차이는 뒤에 싱글톤 컨테이너에서 설명함

**[참고]**
> 스프링은 빈을 생성하고, 의존관계를 주입하는 단계가 나누어져 있다.   
그런데 이렇게 자바 코드로 스프링 빈을 등록하면 생성자를 호출 하면서 의존관계 주입도 한번에 처리된다.   
여기서는 이해를 돕기 위해 개념적으로 나누어 설명했다. 자세한 내용은 외존관계 자동 주입에서 다시 설명함.

**[정리]**
> 스프링 컨테이너를 생성하고, 설정(구성) 정보를 참고해 스프링 빈을 등록하고, 의존관계도 설정함   
다음시간에 스프링 컨테이너에서 데이터를 조회하자.

<br>
<br>
<br>

### < --------------------------- 컨테이너에 등록된 모든 빈 조회 --------------------------- >
* #### 컨테이너에 등록한 빈들이 제대로 등록되었는지 확인(조회) 해보자

* #### 모든 빈 조회 : `String [] beanDefinitionNames = ac.getBeanDefinitionNames();`를 기반으로 조회할 수 있다. (`for Each`)
  > * 배열 타입에서 `beanDeifinitionName`으로 값을 하나씩 꺼내어 담고
  > * `Object bean = ac.getBean(beanDefinitionName);`으로 빈을 꺼낸다. 따로 타입을 지정하지 않아 오브젝트로 반환됨

* #### 위와 같은 방법으로 조회하면 스프링이 내부작업에 사용되는 빈들도 같이 출력되므로 애플리케이션 빈만 출력해보자
  > * `BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName);`으로 빈의 메타데이터 정보를 받아와서
  > * `beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION`인 경우만 출력하게 한다.
  > * 여기서 `ROLE_APPLICATION`은 직접 등록한 애플리케이션 빈을 뜻하는 `상수`고, `ROLE_INFRASTRUCTURE`는 스프링이 `내부에서 사용하는 빈`을 뜻하는 상수다.


**[정리]**
* #### 모든 빈 출력하기
  > * 실행하면 스프링에 등록된 `모든 빈 정보를 출력`
  > * `ac.getDefinitionNames() `: 스프링에 등록된 모든 빈 이름을 조회한다.
  > * `ac.getBean()` : 빈 이름으로 빈 객체(인스턴스)를 조회.

* #### 애플리케이션 빈 출력하기
  > * 스프링이 내부에서 사용하는 빈 제외, 내가 등록한 빈만 출력
  > * 스프링이 내부에서 사용하는 빈은 `getRole()`로 구분 가능
  > * `ROLE_APPLICATION` : 일반적으로 사용자가 정의한 빈
  > * `ROLE_INFRASTRUCTURE` : 스프링이 내부에서 사용하는 빈


* #### 지금까지의 방법은 모든 빈을 조회하기 위한 방법이고 다음 시간에는 스프링 빈을 조회하는 가장 기본적인 방법을 알아보자
<br>
<br>
<br>

### < --------------------------- 스프링 빈 조회 - 기본 --------------------------- >
* #### 스프링 컨테이너에서 스프링 빈을 찾는 가장 기본적인 조회 방법
  > * ac.getBean(빈이름, 타입)
  > * ac.getBean(타입)

* #### 조회 대상 스프링 빈이 없으면 예외 발생
  > * `NoSuchBeanDefinitionException: No bean named 'xxxxx' available`

* #### 테스트
  > * `빈 이름으로 조회` : 빈 이름과 타입을 이용해 ac.getBean()으로 조회 할 수 있다. (Assertions로 검증)

  > * `이름 없이 타입으로만 조회` : 타입만을 가지고 ac.getBean()으로 조회 할 수 있다. (Assertions로 검증)
  > * 위 2개는 인터페이스로 조회함 : 이렇게 조회하면 인터페이스의 구현체가 대상이 됨

  > * `구체 타입으로 조회(인터페이스가 아닌)` : 타입을 인터페이스가 아닌 MeberServiceImpl과 같이 구체 타입으로 조회 할 수 있음 (Assertions로 검증)
  > * AppConfig의 반환 타입이 인터페이스라고 해서 꼭 인터페이스 타입을 이용하지 않아도 된다.
  > * 스프링 빈에 등록된 인스턴스(객체) 타입을 보고 결정하기 때문에 꼭 인터페이스가 아니어도 됨.
  > * 다만 구체적인걸 사용하는것은 좋지 못함 왜? 우리는 역할(인터페이스)에 의존해야하고 구현(구현체)에 의존하면 안되기때문.   
      (가끔 사용하다 보면 이상적으로 돌아가지 못할 때 필요 ㅎㅎ)

  > * `빈 이름으로 조회 불가능 테스트(실패테스트)` : 존재하지 않는 빈을 조회하면 NoSuchBeanDefinitionException이 발생함을 이용해 검증할 수 있다.
  > * 이는 org.junit.jupiter.api.Assertions을 이용한다 상단의 Assertions와 다른 클래스
  > * assertThrows(예외정보, 로직);	(예외가 던져지면 성공)
  > * 우리가 발생할거라 예상한 예외가 두번째 인자의 로직에서 발생하게 되면 테스트가 성공한다는 의미이다.
  > * 여기서 람다식이 사용됨(람다 공부하자)


* #### 이렇게 기본적인 조회는 간단하다.
* #### 다음시간에는 만약에 동일 타입이 2개가 있으면 어떻게 될지 알아보자.
<br>
<br>
<br>

### < --------------------------- 스프링 빈 조회 - 동일한 타입이 둘 이상 --------------------------- >
* #### 스프링 빈을 조회시 같은 타입의 스프링 빈이 둘 이상이면 오류가 발생한다. 이때는 빈 이름을 지정하면 해결됨
  > * `ac.getBeansOfType()` 을 사용하면 해당 타입의 모든 빈을 조회할 수 있음.

* #### ApplicationContextSameBeanFindTest 테스트 클래스를 만들어보자
  > * AppConfig는 현재 중복되는 빈이 없으므로 임의로 클래스내의 `static Config클래스`를 만든다. (클래스안에 클래스는 `현재 클래스`안에서만 사용가능)

**[ TEST ]**
1. 타입 조회시 같은 타입이 둘 이상 있으면 중복 오류 발생
   > * assertThrow()로 ac.getBean(MemberRepository.class)를 꺼낼떄 `NoUniqueBeanDefinitionException`이 발생하면 테스트 성공 로직 작성

2. 타입으로 조회시 같은 타입이 둘 이상 있으면, 빈 이름을 지정하면 된다.
   > * ac.getBean(name, type); 옵션으로 특정 빈의 이름을 지정하면 `NoUniqueBeanDefinitionException` 방지가능 이후 assertThat으로 MemberRepository의 구현체가 맞는지 확인하는 로직 작성

3. 특정 타입을 모두 조회하기
   > * ac.getBeansOfType(type)을 넘기게 되면 Map형식으로 타입에 해당되는 모든 빈을 반환 받는다. key는 Bean의 이름, value는 타입이 된다.
   > * assertThat으로 반환받은 타입의 크기가 2임을 확인하는 로직 작성
   > * 한번에 조회 하는 방법은 Autowired로 자동으로 의존관계를 주입할때 이러한 기능들이 자동으로 적용된다.


* #### 다음 시간에는 상속 관계에서의 조회가 어떻게 되는지 알아보자 (중요)
<br>
<br>
<br>

### < --------------------------- 스프링 빈 조회 - 상속 관계 --------------------------- >
* #### 스프링에선 `부모 타입`으로 조회하면, `자식 타입`도 함께 조회한다.(대원칙)
* #### 그래서 모든 자바 객체의 최고 부모인 `Object 타입`으로 조회하면, `모든 스프링 빈을 조회`한다.
  > * pdf의 상속관계 예시를 보면 부모타입도 포함하여 하위 자식들 모두를 조회한다.

**[TEST]**
>static 클래스로 TestConfig생성 : Rate, FixDiscountPolicy로 빈 생성

1. 부모 타입으로 조회시, 자식이 둘 이상 있으면, `중복 오류` 발생
2. 부모 타입으로 조회시, 자식이 둘 이상 있으면, `빈 이름`을 지정하면 된다.
3. 특정 하위 타입으로 조회(구현체로 하지만 `좋지 않은 방법`)
   > * 그러면 public RateDiscountPolicy 를 반환해도 동일하지만 굳이 DiscountPolicy로 두는 이유는 무엇일까?
   > * `역할`과 `구현`을 항상 쪼개야하는데 public DiscountPolicy를 보고 역할을 보는것임
   > * `구체적인 것으로 해도되지만 역할로 두는것이 좋음` 다른곳에서 DI 할 때도 DiscountPolicy(역할)를 의존하기 떄문이다.
4. 부모 타입으로 모두 조회하기 (인터페이스 타입)
5. 부모 타입으로 모두 조회하기 - Object

* #### 사실 어플리케이션 컨테스트에서 직접 getBean을 할 일이 별로 없다. 후에 스프링 컨테이너가 자동으로 의존관계를 주입하는 걸 사용함
  > OrderService를 개발 할 때 기본 코드만 개발하고, 의존관계 주입에 대한 부분은 명시하지 않음   
  왜냐면 그 부분은 AppConfig에서 적어주고 있다. 또한 스프링 컨테이너를 통해 빈을 조회하는 코드도 없음   
  가끔 순수 자바 어플리케이션에서 스프링 컨테이너를 생성해서 써야할 일 있을때 사용된다.

* #### 부모 타입으로 조회할때 자식이 어디까지 조회되는지 잘 이해해야 후에 자동 의존 관계 주입에서 문제없이 잘 해결할 수 있다.
<br>
<br>
<br>

### < --------------------------- BeanFactory와 ApplicationContext --------------------------- >
* #### BeanFactory
  > * 스프링 컨테이너의 `최상위 인터페이스`다.
  > * 스프링 빈을 `관리`하고 `조회`하는 역할을 담당한다.
  > * `getBean()`을 제공한다.
  > * 지금까지 우리가 사용했던 `대부분의 기능`은 BeanFactory가 제공하는 기능이다.

* #### ApplicationContext
  > * BeanFactory의 기능을 모두 `상속`받아서 제공한다.
  > * 빈을 관리하고 검색하는 기능을 BeanFactory가 제공해주는데, 그러면 둘의 `차이가 뭘까?`
  > * `애플리케이션을 개발할 때`는 빈은 관리하고 조회하는 기능은 물론이고, `수 많은 부가기능이 필요`하다.

* #### ApplicationContext가 제공하는(상속받은) `부가기능` (BeanFactory말고도)
    * `메시지 소스를 활용한 국제화 기능(MessageSource <<interface>> )`
        * 예를 들어서 한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력
          <br><br>
    * `환경 변수 (EnvironmentCapable <<interface>> )`
        * 로컬, 개발, 운영 등을 구분해서 처리
        * 개발은 크게 3가지의 개발환경이 있다.
            1. `로컬` : 현재 내 PC에서 개발하는 환경
            2. `테스트 서버` : 테스트 서버에 띄워두고 테스트 할 수 있는 환경
            3. `운영 환경` : 실제 프로덕션에 나가는 환경
            4. 추가로 `스테이징환경` : 운영과 가장 밀접한(비슷한) 환경 등이 있다.
               <br><br>
    * `애플리케이션 이벤트(ApplicationEventPublisher <<interface>> )`
        * 애플리케이션 내에서 특정 이벤트를 발행하고 구독하는 모델을 편리하게 지원
          <br><br>
    * `편리한 리소스 조회(ResourceLoader <<interface>> )`
        * 파일, 클래스패스, 외부 등에서 리소스를 추상화하여 편리하게 조회할 수 있게함


* #### 정리
  > * ApplicationContext는 BeanFactory의 기능을 `상속`받는다.
  > * ApplicationContext는 `빈 관리기능 + 편리한 부가 기능`을 제공한다.
  > * BeanFactory를 직접 사용할 일은 거의 없다. 주로 부가기능이 포함된 `ApplicationContext를 사용`한다.
  > * BeanFactory나 ApplicationContext를 `스프링 컨테이너`라 한다. (우리는 ApplicationContext만 사용한다고 보면된다.)

<br>
<br>
<br>

### < --------------------------- 다양한 설정 형식 지원 - 자바 코드, XML --------------------------- >
* #### 스프링 컨테이너는 다양한 형식의 설정 정보를 받아들일 수 있게 `유연하게 설계`되어 있다.
  > * `자바코드`, `XML`, `Groovy`, `임의로 설정`도 가능

* #### ApplicationContext << interface >>를 구현한 것들을 보면
  > * `AnnotationConfigApplicationContext(자바코드를 설정정보로 사용)`
  > * `GenericXmlApplicationContext(XML문서를 설정정보로 사용)`
  > * 혹은 `임의로 구현`하여 만들 수 있음 : XxxApplicationContext

* #### 애노테이션 기반 자바 코드 설정 사용
  > * 지금까지 사용한것
  > * `new AnnotationConfigApplicationContext(AppConfig.class)`
  > * `AnnotationConfigApplicationContex`t 클래스를 사용하면서 `자바 코드`로된 설정 정보를 넘기면 된다.

* #### XML 기반 설정 사용
  > * 최근 스프링 부트의 사용으로 XML기반의 설정은 잘 사용하지 않음,    
      많은 레거시 프로젝트 들이 XML로 되어 있고  또 XML을 사용하면 컴파일 없이 빈 설정 정보를 변경할 수 있는 장점도 있다.
  > * `GenericXmlApplicationContext`를 사용하면서 xml 설정 파일을 넘기면 된다.

* #### 자바 코드가 아닌 파일은 `resources`아래에 둔다 xml도 마찬가지 (appConfig.xml)
  > * 이렇게 되면 `classPath`에서 자동으로 appConfig.xml을 읽어온다. 따로 import없이

* #### xml 기반의 appConfig.xml 스프링 설정 정보와 자바 코드로 된 AppConfig.java 설정 정보를 비교해보면 거의 비슷하다는 것을 알 수 있다.
* #### xml 기반으로 설정하는 것은 최근에 잘 사용하지 않으므로 이정도로 마무리 하고, 필요하면 `스프링 공식 레퍼런스` 문서를 확인하자

* #### 여기서 배우고자 하는건 스프링은 자바 코드 뿐만아니라 다양한 방법으로 설정 파일을 만드는것을 지원해준다는 것이다.
  > * 스프링이 얼마나 유연하게 설정들을 할 수 있는지 알 수 있음

<br>
<br>
<br>

### < --------------------------- 스프링 빈 설정 메타 정보 - BeanDefinition --------------------------- >
* #### 스프링이 xml, 자바코드, 임의설정과 같이 다양한 설정 형식을 지원할 수 있는 이유?
  > * 중심에` BeanDefinition이라는 추상화`가 있다. (`빈 정보에 대한 것 자체를 추상화 시킴`)

* #### 이는 곧 `역할`과 `구현`을 개념적으로 나눈 것이다.
  > * `XML`을 읽어서 BeanDefinition을 만들면 된다.
  > * `자바 코드`를 읽어서 BeanDefinition을 만들면 된다.
  > * 스프링 컨테이너 입장에선 자바 코드인지, XML인지 몰라도 된다. `오직 BeanDefinition만 알면 된다`.

* ####  BeanDefinition을 빈 설정 메타정보라고 한다.
  > * `@Bean`, `<bean>`당 각각 하나씩 `메타 정보`가 생성된다.
* #### 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다.

* #### 결국 BeanDefinition이라는 역할을 구현하고 있는것이 자바 설정파일, XML설정파일, 임의설정파일 된다.
  > * (스프링 컨테이너는 BeanDefinition을 의존하고 있다(추상화를 의존) 따라서 위와 같은 상황이 가능하다.)


**[코드 레벨로 좀 더 깊게 들어가보자]**
* #### AnnotationConfigApplicationContext는 AnnotatedBeanDefinitionReader를 의존하는데 이를 사용해서 AppConfig.class를 읽고, BeanDefinition를 생성한다 마치 메타데이터 처럼 읽는다. 그리고 빈의 메타데이터를 담는다.

* #### GenericXmlApplicationContext도 마찬가지로 내부에 XmlBeanDefinitionReader 를 의존하고, 이를 사용해서 appConfig.xml 설정 정보를 읽고 BeanDefinition 을 생성한다

* #### 새로운 형식의 설정 정보가 추가되면, XxxBeanDefinitionReader를 만들어서 BeanDefinition을 생성하면 된다.
  > * 임의의 형식을 만들 수 있음 (JSON 등)


**[정리]**
* #### BeanDefinition을 직접 생성해서 스프링 컨테이너에 등록할 수 도 있다.(하지만 BeanDefinition을 직접 정의하거나 사용할 일은 거의 없다)
* #### 스프링이 다양한 형태의 설정 정보를 BeanDefinition으로 추상화해서 사용하는 것 정도만 이해하자.
* #### 가끔 스프링 코드, 스프링 관련 오픈 소스의 코드에서 BeanDefinition이 보이는데 이때 이러한 메커니즘을 떠올리면 된다.
  > (BeanDefiniton을 직접 프로그래밍 하는 경우도 있다.)

* #### 스프링이 빈을 등록하는 방식은 크게 봤을때 2가지가 존재(어노테이션, xml, 임의 설정의 상위 방식)
    1. 직접 스프링 빈을 등록하는 방법 : `XML Config`
    2. 우회하여 Factory Method를 이용하여 스프링 빈을 등록하는 방법 : `Java Config`
       <br><br>

* #### 추가로 Annotation이 아닌 GenericXmlApplicationContext로 만들어서 BeanDefinition을 출력해보면 Annotation 방식과는 다른점을 알 수있다.
  > * Bean에 대한 클래스가 다 드러남(Java Config는 NULL)
  > * FactoryBean, Method가 Null값 : xml은 직접 스프링 빈을 등록하므로   
      (Java Config는 factoryBeanName:appConfig, factoryMethodName=... 으로 존재)

<br>
<br>
<br>

### < --------------------------- 웹 애플리케이션과 싱글톤 --------------------------- >
* #### 스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생했다.
* #### 대부분의 스프링 애플리케이션은 웹 애플리케이션이다. 물론 웹이 아닌 애플리케이션 개발도 얼마든지 개발할 수 있다.
* #### 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다.

* #### 클라이언트 A,B,C가 순서대로 memberService를 요청한다고 DI컨테이너(AppConfig)는 총 3개의 MemberServiceImpl 객체를 반환 해준다.
  > * 이렇게 되면 어떤 문제가 발생할까? 웹애플리케이션은 고객이 계속 요청을 하는데 요청때마다 객체를 만들어야 하는것이 문제가 된다.

* #### 실제로 Spring이 없는 순수한 DI 컨테이너 테스트를 통해 확인해보자 (SingletonTest.java)
  > * 테스트 결과로 알 수 있는 것은 우리가 만들었던 스프링 없는 순수한 DI 컨테이너인 AppConfig는 요청을 할 때마다 객체를 새로 생성한다.
  > * 고객 트래픽이 초당 100이 나오면 초당 100개의 객체가 생성되고 소멸된다. --> 메모리 낭비 극심
  > * 해결 방안은 해당 객체가 딱 `1개만 생성`되고, `공유`하도록 설계하면 된다. --> `싱글톤 패턴`

<br>
<br>
<br>

###< --------------------------- 싱글톤 패턴 --------------------------- >
* #### 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴이다.
* #### 그래서 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 한다.
  > * `private 생성자`를 사용해서 외부에서 임의로 `new 키워드`를 사용하지 못하도록 막아야 한다.

* #### Singleton pattern 예제 코드 분석 `[test/hello/core/singleton/SingletonService.java]`
  > * `static 영역`에 객체 instance를 하나 생성해서 올려둠. >> 실행시 JVM 메모리에
  > * 객체 인스턴스가 필요하면 오직 `getInstance() 메소드`를 통해서만 조회할 수 있다.   
      (여기서 메서드를 호출하면 항상 같은 인스턴스 반환)
  > * 오직 1개의 객체 인스턴스만 존재해야 하므로, 생성자를 `private`으로 두어
      외부에서 new키워드로 객체 인스턴스가 생성되는 것을 `막는다`.

* #### Singleton pattern Test 예제 코드 분석 `[test/hello/colr/singleton/SingletonServiceTest.java]`
  > * `private`으로 new 키워드를 막아두었다.
  > * 호출할 때 마다 `같은` 객체 인스턴스를 반환하는 것을 알 수 있다.   
      (현재 구현한 싱글톤 패턴은 객체를 미리 생성해두는 가장 단순하고 안전한 방식)

* #### 싱글톤 패턴을 적용하면 이미 만들어진 객체를 공유하여 효율적으로 사용하지만 수많은 문제점을 가진다.
  > * 싱글톤 패턴을 구현하는 `코드 자체가 많이 들어감`
  > * 의존관계상 클라이언트가 `구체 클래스에 의존`한다.(`구체클래스.getInstance()`) --> 즉 `DIP`를 위반함   
      (하지만 `Config파일을 거치게 되면` DIP를 지킬 수 있다.)
  > * 클라이언트가 구체 클래스에 의존해서 `OCP 원칙`을 `위반`할 가능성이 높음
  > * `테스트` 하기 어렵다.   
      (객체를 `지정`해서 가져오고, 인스턴스를 `미리 생성`하므로)
  > * 내부 속성을 변경 및 초기화 하기 어렵다.
  > * `private 생성자`를 사용하므로 자식 클래스를 만들기 어렵다.
  > * 결과적으로 `유연성`이 떨어짐
  > * `안티패턴`으로 불리기도 한다.   
      (많이 사용되는 패턴이지만 비효율적이거나 비생산적인 패턴을 의미한다)

* #### 스프링 프레임워크는 이런 문제점을 전부 해결함 즉 싱글톤이 가진 `단점`을 `제거`하고, 객체를 싱글톤으로 관리해준다.
  > * 스프링 컨테이너는 `싱글톤 컨테이너`라고도 불림 싱글톤 컨테이너의 역할을 알아보자

<br>
<br>
<br>

### < --------------------------- 싱글톤 컨테이너(스프링 컨테이너) --------------------------- >
* #### 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하며, 객체 인스턴스를 싱글톤(1개만 생성)으로 관리한다.
* #### 지금까지 학습한 스프링 빈이 바로 싱글톤으로 관리되는 빈이다.

**[ 싱글톤 컨테이너 ]**
* #### 스프링 컨테이너는 싱글턴 패턴을 `적용하지 않아도`, 객체 인스턴스를 싱글톤으로 관리한다.
  > * 이전에 설명한 컨테이너 생성 과정을 자세히 보면 컨테이너는 객체를 하나만 생성해서 관리함(50p 참조)

* #### 스프링 컨테이너는 싱글톤 컨테이너 `역할`을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 `싱글톤 레지스트리`라 한다.

* #### 스프링 컨테이너의 이런 기능 덕분에 싱글턴 패턴의 `모든 단점을 해결`하면서 객체를 싱글톤으로 유지할 수 있다.
  > * 싱글톤 패턴을 위한 `지저분한 코드`가 들어가지 않아도 된다.
  > * `DIP`, `OCP`, `테스트`,` private 생성자`로부터 자유롭게 싱글톤을 사용할 수 있다.

* #### 스프링 컨테이너를 사용하는 테스트 코드 예제
  > * `MemberService` 타입 객체를 2번 `getBean()해도 두 참조값이 같음`, 즉 객체를 한번만 생성하고 `재사용` 하는것을 알 수 있다.
  > * 그렇다고 해서 MemberServiceImpl 클래스를 살펴보면 싱글톤 패턴과 관련된 코드가 `하나도 존재하지 않음`

* #### 싱글톤 컨테이너 적용 후
  > * 스프링 컨테이너 덕분에 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 `공유`해서 효율적으로 재사용 할 수 있다.

  **[참고]**
  > * 스프링의 기본 빈 등록 방식은 싱글톤이지만, 싱글톤 방식만 지원하는 것은 아니다. 요청할 때 마다 새로운 객체를 생성해서 반환하는 기능도 제공한다.
      자세한 내용은 후의 빈 스코프에서 설명
  > * 특별한 기능 이용시 사용 : 요청할 때 마다 새로 꺼내거나, HttpRequest life Cycle에 맞춰 빈 라이프 사이클을 맞추거나, 고객이 들어올때 만들고 나갈때 죽이는 사이트
      혹은 HttpSession과 같은 라이프 사이클을 맞추거나 할 때 사용된다.

<br>
<br>
<br>

### < --------------------------- 싱글톤 방식의 주의점 --------------------------- >
* #### 싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 인스턴스를 공유함 따라서 싱글톤 객체는 상태를 `유지(stateful)`하게 설계하면 안된다.

* #### `무상태(stateless)로 설계`해야 한다!
  > * 특정 클라이언트에 `의존적인 필드`가 있으면 안된다. (`특정 클라이언트를 필요로 하는 필드가 있으면 안된다`)
  > * 특정 클라이언트가 `값을 변경할 수 있는 필드`가 있으면 안된다!
  > * 가급적 `읽기만 가능`해야 한다.
  > * 필드 대신에 `자바에서 공유되지 않는`, `지역변수`, `파라미터`, `ThreadLocal`등을 사용해야 한다.

* #### 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다. (물론 싱글톤 빈에)

* #### SingletonStateServiceTest (영한님은 StatefulServiceTest)에 `stateful`, `stateless`한 테스트를 2개 만들고 테스트하자 (코드 참조)

**[StatefulService]**
> * 우선 StatefulService는 특정 클라이언트에 의존적이고 값을 변경할 수 있는 필드인 `price`가 존재한다.
> * 이는 특정 메소드가 실행되었을때 공유 필드인 int price에 값이 `저장`되는데 이를 `stateful`하다고 말 할 수 있다.
> * 이를 해결하기 위해 `stateless`하게 변경해야 한다.

**[StatelessService]**
> * StatelessService는 주문을 했을때 공유 필드에 값을 저장하는 것이 아닌 사용자가 주문한 값을 `바로 반환`해준다.
> * 따라서 요청이 들어올때마다 즉시 즉시 값을 반환하므로 클라이언트는 `자신이 주문한 값`을 바로 확인할 수 있다.
> * `공유 필드에 저장되지 않았으므로` stateful하지 않게 된다.

**[정리]**
* #### 단순한 설명을 위해 실제 쓰레드는 사용하지 않음

* #### ThreadA가 사용자 A코드를 호출하고 ThreadB가 사용자B 코드를 호출할 때 StatefulService의 price필드는 공유되는 필드가 되며, 특정 클라이언트가 값을 변경한다.

* #### 사용자A의 주문금액은 10000원 이지만, 20000원이라는 결과가 나온다.

* #### `공유 필드는 정말정말 조심해야한다`. 스프링 빈은 항상 무상태(stateless)로 설계하자 (실무에서는 이런경우가 종종 발생한다. 이로인해 정말 해결하기 어려운 큰 문제들이 터진다. 잘 알고 있자)

<br>
<br>
<br>

### < --------------------------- @Configuration과 싱글톤 --------------------------- >
* #### 지금까지 싱글톤은 객체를 하나만 생성해서 공유해서 사용하는것으로 알고있다 하지만!!
  >AppConfig를 보면 memberService, orderService 빈을 만드는 코드는 동일한 memberRepository 메소드를 호출하며 2개의 new MemoryMemberReposiory()를 호출한다.   
  결과적으로 2개의 객체가 생성되면서 싱글톤이 깨지는 것 처럼 보인다. 스프링 컨테이너는 이 문제를 어떻게 해결할까?   
  이럴 경우에는 과연 Spring은 어떤 방식으로 싱글톤을 유지할까? --> 이렇게 고민이 될때는 테스트 코드를 이용한다.

* #### configurationTest 결과
  > * 실제로 MemberServiceImpl과 OrderServiceImpl에 모두 getMemberRepository를 임의로 만들어
  > * 객체가 같은지 비교하면 `같은 객체`임을 확인할 수 있다.
  > * 즉, memberRepository 인스턴스는 모두 `같은 인스턴스가 공유되어 사용`된다.
  > * 하지만 AppConfig의 자바 코드는 각 3번의 new MemoryMemberRepository를 호출해서 각각 다른 인스턴스가 생성되어야 하는데?
  > * 실험을 통해 알아보자

* #### AppConfig에 호출 코드 남기기
  > * 스프링 컨테이너가 스프링 빈을 생성할 때 memberRepository()는 총 `3번이 실행될 것으로 예상`됨
    1. 스프링 빈에 등록하기 위해 @Bean이 붙어있는 memberRepository() 호출
    2. memberService() 로직에서 memberRepository() 호출
    3. orderService() 로직에서 memberRepository() 호출

  > * 실제 출력 결과 : 모두 1번씩 호출된다. 왜?
    1. call AppConfig.memberService
    2. call AppConfig.memberRepository
    3. call AppConfig.orderService

<br>
<br>
<br>

### < --------------------------- @Configuration과 바이트코드 조작의 마법 --------------------------- >
* #### 스프링 컨테이너는 싱글톤 레지스트리다. (스프링이 직접  싱글턴 객체를 만들고 관리하는 기능을 제공하는 것을 의미한다.)
* #### 따라서 스프링 빈이 싱글톤이 되도록 보장해주어야 함.
* #### 하지만 스프링이 자바 코드까지 어떻게 하기는 어려움 --> 자바 코드를 보면 분명 3번 호출되어야 하는 것이 맞다.
* #### 따라서 스프링은 클래스의 바이트코드를 조작하는 라이브러리를 사용
* #### `모든 비밀은 @Configuration을 적용한 AppConfig에 있다.`

* #### ConfigurationDeep Test
  > * AppConfig또한 AnnotationConfigApplicationContext에 파라미터로 넘긴 값이므로 `스프링 빈으로 등록`된다.
  > * AppConfig를 getBean해 bean.getClass()로 클래스정보를 출력하면 class hello.core.AppConfig$$EnhancerBySpring`CGLIB`$$bd479d70 형태로 출력된다.
  > * 예상 출력은 다음과 같다. : class hello.core.AppConfig 하지만, `xxxCGLIB`가 붙으며 복잡해진 클래스 정보가 출력된다.
  > * 이는 `CGLIB`라는 `바이트코드 조작 라이브러리`를 이용해 `AppConfig를 상속받은 임의의 클래스를 스프링 빈으로 등록`했기 때문

  > * 임의의 다른 클래스가 아래와같이 CGLIB의 기술로 싱글톤이 보장되도록 해준다.
```java
@Bean
public MemberRepository memberRepository() {
        if (memoryMemberRepository가 이미 스프링 컨테이너에 등록되어 있으면?) {
            return 스프링 컨테이너에서 찾아서 반환;
        } else { //스프링 컨테이너에 없으면
            [기존 로직을 호출해서 MemoryMemberRepository를 생성하고 스프링 컨테이너에 등록]
            return 반환
        }
}

```

> * 즉 @Bean이 붙은 메소드마다 스프링 빈이 이미 존재하면 존재하는 빈을 반환, 없으면 생성해서 스프링 빈으로 등록하고 반환한다.
> * 이 덕분에 싱글톤이 보장된다.

> * 참고로 AppConfig@CGLIB는 `AppConfig의 자식 타입`이므로 AppConfig타입으로 조회할 수 있다.


* #### @Configuration없이 @Bean만 적용하면?
  > * 출력 결과를 통해서 AppConfig가 CGLIB 기술 없이 `순수한 AppConfig로 스프링 빈에 등록`된 것을 확인할 수 있다.
  > * 또한 MemberRepository가 초기 예상대로 총 `3번 호출`된다.
  > * 인스턴스도 각각 다른 MemoryMemberRepository 인스턴스를 가지므로 `싱글톤이 지켜지지 않는다`.   
      (왜냐하면 각각 실행되는 memberRepository()는 일반적인 `new로 객체가 생성되는것과 동일`하므로 스프링 컨테이너에 등록되지 않기 때문이다.)   
      (따라서 각 `Service에 주입된 저장소들은 스프링 빈이 아니라 직접 new하여 구현체를 의존하는것과 동일한 상황`이 된다.)   
      (만약 @Configuration을 없이 사용하고 싶다면 `@Autowired`를 사용하면 됨)


**[ 정리 ]**
* #### @Bean만 사용해도 스프링 빈으로 등록되지만, 싱글톤을 보장하지 않는다.
  > * memberRepository()처럼 의존관계 주입이 필요해서 메소드를 직접 호출할 때 싱글톤을 보장하지 않는다.
* #### 스프링 설정 정보는 항상 @Configuration을 사용하자.

<br>
<br>
<br>

### < --------------------------- 컴포넌트 스캔과 의존관계 자동 주입 시작하기 --------------------------- >
* #### @Bean, XML로 등록해야할 스프링 빈이 많아질 수 록 일일이 등록하기 힘들어짐 --> 누락하는 문제 발생 가능성 높아짐
* #### 따라서 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다.
* #### 또한 의존관계도 자동으로 주입하는 @Autowired라는 기능도 제공한다.

* #### 기존의 AppConfig를 유지하기 위해 `AutoAppConfig`를 새로 생성한다.
  > * 내부에는 @Bean으로 등록한 클래스는 하나도 없고 단지 `@Configuration`과 `@ComponentScan`만 붙여준다.
  > * 기존에 만들어져 있고 `@Configuration`이 붙은 설정 정보도 자동으로 등록된다.
  > * 따라서 `excludeFilters`를 이용해 `어노테이션 설정정보는 컴포넌트 스캔 대상에서 제외`한다. (이를 하지 않으면 빈이 중복될 수 있다.)

* #### 컴포넌트 스캔은 이름 그대로 @Component 어노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다.
  > * `@Configuration`의 소스코드도 `@Component`가 붙어있으므로 스캔의 대상이 될 수 있어서 `제외`했다.

* #### @Component 붙여주기
  > * 기존의 AppConfig에 Bean으로 등록한 클래스들에 `@Component`를 붙여준다.
  > * 과거에는 @Bean으로 직접 설정정보도 작성했지만 의존관계도 같이 명시해줬다.
  > * 하지만 지금은 설정 정보 자체가 없으므로 `의존관계도 클래스안에서 해결`해야 한다.

* #### Autowired의 역할
  > * ComponentScan을 하며 @Component객체를 생성할때 `알맞은 의존관계를 자동으로 주입`해준다.
  > * 여기선 MemberServiceImpl, OrderServiceImpl의 `생성자`에 @Autowired를 붙여준다.
  > * 생성자에서 `여러 의존관계`도 한번에 주입받을 수 있다.
  > * 실제로 테스트를 하여 로그를 확인하면 컴포넌트 스캔이 잘 동작함을 알 수 있음 (AutoAppConfigTest)

* #### 컴포넌트 스캔과 자동 의존관계 주입의 동작
  **[@ComponentScan]**
  > * `@ComponentScan`은 `@Component`가 붙은 모든 클래스를 스프링 빈으로 등록한다.
  > * 이때 스프링 빈의 `기본 이름`은 클래스명을 사용하되 맨 앞글자만 소문자를 사용한다.
  > * `빈 이름 기본 전략` : MemberServiceImpl 클래스 -> memberServiceImpl
  > * 혹은 빈이름을 직접 지정하고 싶다면
  > * `@Component("memberService2")`와 같은 방식으로 지정이 가능하다.

  **[@Autowired 의존관계 자동 주입]**
  > * `생성자`에 @Autowired를 지정하면, 스프링 컨테이너가 `자동`으로 해당 스프링 빈을 찾아서 주입함
  > * 이때 기본 조회 전략은 타입이 같은 빈을 찾아서 주입한다. (따라서 `같은 타입의 빈이 2개이상 존재하면 충돌` 오류발생)
  > * `getBean(MemberRepository.class)와 동일`하다고 이해하면 된다.

  > * `생성자에 파라미터가 많아도 자동으로 주입`함

<br>
<br>
<br>

### < --------------------------- 탐색 위치와 기본 스캔 대상 --------------------------- >
* #### 모든 자바 클래스를 컴포넌트 스캔하면 시간이 오래걸리므로 필요한 위치부터 탐색하게 설정할 수 있다.
  > * @Component(이곳에 설정)
  > * `basePackages` : 탐색할 패키지의 시작위치 결정, 이 패키지를 포함해 하위 패키지 모두 탐색 `{"",""}`로 여러 시작위치를 정할 수 있다.
  > * `basePackageClasses` : 지정한 클래스의 패키지를 탐색 시작 위치로 지정
  > * 만약 지정하지 않으면 `@ComponentScan이 붙은 설정 정보 클래스의 패키지`가 시작 위치가 된다.


* #### 영한님이 권장하는 방법
  > * `패키지 위치를 지정하지 않는 방법` : 설정 정보 클래스의 위치를 프로젝트 최상단에 둔다(`스프링 부트`도 이 방법을 기본으로 제공한다)
  > * `com.hello, com.hello.service, com.hello.repository`와 같이 프로젝트 구조가 있으면 com.hello가 프로젝트 루트이므로, 이곳에 설정 정보를 둔다
  > * 이후 @ComponentScan을 달고 패키지 지정을 생략하면 이곳부터 하위 패키지까지 탐색함

  > * 또한 프로젝트 `메인 설정 정보`는 프로젝트를 대표하는 정보이므로 `시작 루트에 위치하는것이 바람직`하다.
  > * 부트 사용시 Spring Boot의 대표 시작 정보인 `@SpringBootApplication`을 프로젝트 시작 루트 위치에 두는것이 관례(그리고 설정 안에 바로 `@ComponentScan`이 들어있다.)


* #### 컴포넌트 스캔 기본 대상
  > * 컴포넌트 스캔은 @Component뿐 아니라 아래의 내용도 추가로 대상에 포함

  > * `@Component` 컴포넌트 스캔에서 사용
  > * `@Controller` 스프링 MVC 컨트롤러에서 사용
  > * `@Service` 스프링 비즈니스 로직에서 사용
  > * `@Repository` 스프링 데이터 접근 계층에서 사용
  > * `@Configuration` 스프링 설정 정보에서 사용   
      (해당 클래스들의 설정 정보를 보면 `@Component를` 포함하고 있다)

  **[참고]** : 사실 어노테이션에는 `상속관계가 없다`. 따라서 어노테이션이 특정 어노테이션을 들고 있는 것을 인식할 수 있는것은
  자바 언어가 지원하는 기능이 아닌, `스프링이 지원하는 기능`이다.


* #### 컴포넌트 스캔의 용도 뿐 아니라 다음 어노테이션이 있으면 스프링은 부가 기능을 수행한다.
  > * `@Controller` 스프링 `MVC 컨트롤러`로 인식
  > * `@Repository` 스프링 `데이터 접근 계층`으로 인식, 데이터 계층의 예외를 스프링 예외로 변환   
      (데이터 계층의 예외를 스프링의 `추상화된 예외로 변경`해줌 : 특정DB의 예외가 터지면 서비스 계층까지 올라옴    
      --> DB를 변경하면 예외 자체가 `변경`됨   
      --> Repository계층의 A디비에서 B디비로 변경되어 `다른 예외`가 올라오면 서비스 계층, 다른계층의 코드가 흔들림    
      --> 이런것들을 방지하기위해 스프링이 예외를 추상화해 반환함)

  > * `@Configuration` 스프링 설정 정보로 인식하고, 스프링 빈이 `싱글톤을 유지하도록 추가 처리`한다.
      > *` @Service` 특별한 처리를 하지 않음, 대신 개발자들이 `핵심 비즈니스 로직`이 여기에 있다는 비즈니스 계층을 인식하는데 도움이 된다.

  **[참고] :** useDefaultFilters 옵션은 기본으로 켜져있는데, 옵션을 끄면 기본 스캔 대상들이 제외된다.


* #### 헷갈릴 만한 사항 정리
  > * `ApplicationContext`가 바로 `스프링 자체`, ApplicationContext를 이용해 `특정 클래스 정보를 받아야 @ComponentScan이 가능`해짐   
      @ComponentScan의 결과로 스프링빈을 스프링 컨테이너에 등록해야하는데, ApplicationContext가 없으면 등록할 `스프링 컨테이너 자체가 존재하지 않아짐`   
      쉽게 이야기해 ApplicationContext가 본인의 스프링 컨테이너에 등록할 빈을 찾기위해 `@ComponentScan을 실행`한다고 이해하면 된다.

  > * 현재 core 프로젝트에 스프링 부트의 어플리케이션인 CoreApplication 내부에 `@SpringBootApplication`이 `프로젝트에 미치는 영향`은 없을까?
  > * 단순히 코드만 존재하고 사용하지 않아옴, CoreApplication을 동작하기 위해선 해당 클래스의 `main()을 호출`하거나 또는 테스트에서 `@SpringBootTest를 이용`해
      부트와 통합하는 테스트를 진행해야 함
  > * CoreApplication을 사용하면 부트가 내부에서 생성하는 ApplicationContext를 사용한다. `우리는 직접 스프링 코어인 ApplicationContext를 생성해 사용`했으므로
      영향을 받는 부분은 없다.

  > * `exclude`로 제외한 `@Configuration`이 있다. AutoAppconfig또한 마찬가지로 @Configuration 붙어있는데 exclude 안당하고 어떻게 돌아갈까?
  > * `new Annotation....(AutoAppConfig.class);`에 넣어주기 때문

  > * `@SpringBootAnnotation`은 `@ComponentScan`이 내부 코드에 들어가 있으므로 최상단에 위치해야함 그렇다면 CoreApplication은 어떻게 빈 등록이 될까?
      내부에 `run메소드`로 `CoreApplication.class`를 넘겨주는데 부트가 이를가지고 `자동으로 해당 클래스를 빈으로 등록`


* #### Spring core vs Spring Boot 사용
  **[Spring core]**
  > * new AnnotationConfigApplicationContext(AutoAppConfig.class);
    1. ApplicationContext(스프링 컨테이너) 생성
    2. AutoAppConfig를 스프링 빈으로 등록
    3. AutoAppConfig에 @ComponentScan을 찾고 @Component(@Controller, @Repository, @Service, @Configuration 포함)이 붙은 클래스를 스프링 컨테이너 빈으로 등록


**[Spring Boot]**
* 상황 1-1. @SpringBotApplication이 붙어있는 class의 `메인함수에서 실행`
* 상황 1-2. @SpringBootTest `테스트 실행` -> @SpringBootApplication 어노테이션을 찾아감

2. 스프링부트 내부에서 `자동으로` ApplicationContext(스프링 컨테이너)를 생성

3. @SpringBootApplication에는 `@ComponentScan이 포함`되어 있음.   
   -> @Component(및 다른 스캔되는 어노테이션)이 달려있는 클래스를 스프링 컨테이너 빈으로 등록   
   (@Configuration도 @Component가 내부적으로 포함되어 있으므로 달려있는 설정 클래스도 빈으로 컨테이너에 `등록`, 이 때 만약 @Bean이 있으면 이 또한 컨테이너에 빈으로 `등록`된다.)

<br>
<br>
<br>

### < --------------------------- 필터 --------------------------- >

* #### `includeFilters` : 컴포넌트 스캔 대상을 추가로 지정한다.
* #### `excludeFilters` : 컴포넌트 스캔에서 제외할 대상을 지정한다.

**[TEST]**
* #### 사용자 임의의 어노테이션 만들기
    * > Annotation 파일을 만들고 기본적으로 3가지의 어노테이션을 붙여야 커스텀 어노테이션이 된다.
        * `@Target(ElementType.TYPE)` : 해당 어노테이션이 사용되는 위치를 결정함(여기서는 TYPE을 이용)
            * ElementType.TYPE은 클래스 / 인터페이스 / 열거 타입(enum)을 뜻한다.
        * `@Retention(RetentinoPolicy.RUNTIME)` : Reflection을 사용하여 컴파일 이후에도 JVM에 의해 계속 참조가 가능함
        * `@Documented` : JavaDoc 생성 시 Document에 포함되도록 함

* #### 컴포넌트 스캔 대상에 추가하고, 제외할 어노테이션 2개를 생성한다.
    * > 각각 MyIncludeComponent, MyExcludeComponent로 생성

* #### 테스트를 위한 임의의 빈 클래스 2개 생성
    * > BeanA, BeanB생성 BeanA는 @MyIncludeComponent를, BeanB는 @MyExcludeComponent 어노테이션을 붙인다.

* #### ComponentFilterAppConfigTest
  > * 내부에 필터를 적용할 config 파일, ComponentFilterAppConfig를 static으로 선언하고,
  > * 설정 파일임을 알리기 위해 @Configuration을 붙인다.
  > * 또한 빈 생성을 위한 @ComponentScan도 붙이지만 내부에 include, excludeFilters에 커스텀 어노테이션을 알맞게 적용한다.
  > ```java
    > @Configuration    // 컴포넌트 스캔도 사용하며 동시에 @Bean으로 수동 등록도 함께 사용하는 경우가 있어서 적음(없어도 정상 동작)
    > @ComponentScan(
    >         includeFilters = Filter(type = FilterType.ANNOTATION, classes = MyIncludeComponent.class),
    >         excludeFilters = Filter(type = FilterType.ANNOTATION, classes = MyExcludeComponent.class)
    > )
    > static class ComponentFilterAppConfig {
    > }
    > ```
  > * 이후 ac.getBean("beanA", BeanA.class); 로직이 null이 아님을 증명하고
  > * ac.getBean("beanB", BeanB.class); 로직이 null임을 증명하는 테스트를 작성하게 되면
  > * 아래와 같은 사항을 검증 할 수 있다.
  >> 1. includeFilters 에 MyIncludeComponent 애노테이션을 추가해서 BeanA가 스프링 빈에 등록된다.
  >> 2. excludeFilters 에 MyExcludeComponent 애노테이션을 추가해서 BeanB는 스프링 빈에 등록되지 않는다.


* #### FilterType의 옵션 5가지
    1. `ANNOTATION` : 기본값, 어노태이션을 인식해서 동작한다.
        * ex) org.example.SomeAnnotation
    2. `ASSIGNABLE_TYPE` : 지정한 타입과 자식 타입을 인식해서 동작함   
       (어노테이션이 아닌 클래스를 직접 지정할 수 있다.)
        * ex) org.example.SomeClass
    3. `ASPECTJ` : AspectJ 패턴 사용
        * org.example..*Service+
    4. `REGEX` : 정규 표현식
        * org\.example\.Default.*
    5. `CUSTOM`: TypeFilter 이라는 인터페이스를 구현해서 처리
        * org.example.MyTypeFilter

<br><br>

* 만약 BeanA도 빼고 싶으면 다음과 같이 추가하면 된다.
```java
    @ComponentScan(
        includeFilters = {
                @Filter(type = FilterType.ANNOTATION, classes =
                        MyIncludeComponent.class),
        },
        excludeFilters = {
                @Filter(type = FilterType.ANNOTATION, classes =
                        MyExcludeComponent.class),
                @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = BeanA.class)
        }

```

**[참고]**
> @Component의 기능이면 충분하므로, includeFilters를 사용할 일은 거의 없다. excludeFilters는 여러가지 이유로   
> 간혹 사용할 때가 있지만 많지는 않음.   
> 특히 최근 스프링 부트는 컴포넌트 스캔을 기본으로 제공해주는데, 옵션을 변경하면서 사용하기 보다는   
> `스프링의 기본 설정에 최대한 맞추어 사용하는 것을 권장한다.`

<br>
<br>
<br>

### < --------------------------- 중복 등록과 충돌 --------------------------- >
* 컴포넌트 스캔에서 같은 빈 이름을 등록하면 어떻게 될까? 다음과 같이 두가지의 상황이 존재한다.
    1. 자동 빈 등록 vs 자동 빈 등록
    2. 수동 빈 등록 vs 자동 빈 등록

* #### 자동 빈 등록 vs 자동 빈 등록
    * 컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록되는데, 이름이 같은 경우 스프링은 오류를 발생시킴
        * `ConflictingBeanDefinitionException` 예외 발생

* #### 수동 빈 등록 vs 자동 빈 등록
    * 임의로 AutoAppConfig에 @Bean을 이용해 수동 등록할 빈을 생성한다. (memoryMemberRepository)
    * 이후 AutoAppConfigTest를 실행하면 Overriding bean definition for bean 'memoryMemberRepository' with a different definition: replacing
    * 메시지의 의미는 수동 빈이 자동 빈을 `오버라이딩` 했다 왜? 수동 빈 등록이 `우선권`을 가지므로
      > 개발자가 의도한 상황보다는 실무에선 여러 설정들이 꼬여서 위와같이 오버라이딩 되는 경우가 대부분이다.   
      그렇게 되면 정말 잡기 어려운 버그가 발생됨(`애매한 버그`)   
      최근 스프링 부트는 수동 빈 등록과 자동 빈 등록이 충돌나면 오류가 발생하도록 기본 값을 바꾸었다.

* #### 수동 빈 등록, 자동 빈 오류시 스프링 부트 에러
    > * Consider renaming one of the beans or enabling overriding by setting 
        `spring.main.allow-bean-definition-overriding=true`   
    > * 실제 CoreApplication을 실행해보면 볼 수 있다.

    > resources/ 아래에 `application.properties`에 spring.main.allow-bean-definition-overriding=true 설정하면
    기존의 스프링 처럼 수동 빈이 오버라이딩 된다.
    >> @SpringBootApplication은 내부에 @ComponentScan을 가지고 있음, 따라서 이곳의 필터는 아무 설정도 없으므로
    AppConfig의 bean들이 수동으로 등록되어 오버라이딩 된다.
    <br><br>
      `call AppConfig.memberRepository`   
      `call AppConfig.memberService`   
      `call AppConfig.orderService`

* #### 왜 스프링 부트는 이런 결정을 내렸을까?
  * 문제가 하도 많이 일어나서
    > 개발은 명확하지 않은것은 하면 안된다.   
    여러명의 개발자가 동시 개발하므로 애매한 상황을 만들면 안된다.
  
  * 예를들어 두 가지의 경우가 있다고 해보자
    1. 코드가 줄어들고 이뻐지는 방향, 하지만 약간 불명확한 부분이 생김
    2. 코드의 중복이 있지만 명확하고 한눈에 들어옴
    > 이럴떄는 명확한것을 선택하는것이 대부분의 경우에서 낫다. 어설픈 추상화, 우선순위가 있으면
    이런 곳에서 발생하는 버그가 정말 잡기 힘든 버그가 된다. (명확하게 하거나 빨리 오류를 발생시키거나)

<br>
<br>
<br>

### < --------------------------- 다양한 의존관계 주입 방법 --------------------------- >
* ### 의존관계 주입은 크게 4가지 방법이 있다.
  * 생성자 주입
  * 수정자 주입(setter 주입)
  * 필드 주입
  * 일반 메서드 주입
<br><br>
* ### 생성자 주입
  * 이름 그대로 생성자를 통해서 의존 관계를 주입받는 방법.
  * 지금까지 우리가 진행한 방법임
  * 특징
    * 생성자 호출시점에 딱 `1번만 호출되는 것이 보장`된다.
      * 따라서 첫 호출때 세팅하고 이후에 값을 변경하지 못하게 할 수 있다는 장점이 있다.
    * **불변(딱 1번만 호출), 필수** 의존관계에 사용   
    **[불편 의존관계]**
      * 개발에서 불변은 매우 중요 : 좋은 개발 습관은 제약이 있는것(한계점, 제약) 다 열어두면 무엇을 수정해야할지 모름
      * 어느 누구도 OrderServiceImpl내 의존객체들을 첫 호출 이후로 수정할 수 있는 방법이 없다.
    * 불변 의존관계로 설정하면 필드들은 값이 꼭 있어야 하므로 final로 선언   
    (**[필수 의존관계]** 생성자 파라미터로 인자가 반드시 들어와야 함, 따라서 인자로 들어오는 객체는 스프링 빈이어야 한다.)
        ```java
        // OrderServiceImpl's Fields
        // 2.회원조회를 위한 필드 선언
        private final MemberRepository memberRepository;
        // 3. 할인적용을 위한 필드 선언
        private final DiscountPolicy discountPolicy;
        ```
    **[중요 사항]**
    * 생성자가 딱 1개만 있으면 @Autowired를 생략해도 자동 주입 된다. 물론 스프링 빈에만 해당한다.
      * @Bean 혹은 @ComponentScan으로 등록해도 마찬가지다
<br><br>
* ### 수정자(Setter) 주입
  > Setter주입을 하기 위해 임시로 final키워드를 제거한다*.
  * setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법   
    (파라미터에 명시된 타입을 가지고 해당 타입으로 받을 수 있는 빈을 조회함)
  * 특징
    * **선택, 변경** 가능성이 있는 의존관계에 사용  
      * **[선택 가능성]**
        * 생성자 주입은 필수 값이지만, 수정자는 특정 의존성이 주입이 되지 않아도 사용할 수 있다.   
          (선택적으로 의존성 주입)
        * 선택적으로 주입하기 위해선 `@Autowired(required = false)`옵션을 주면 된다.   
      * **[변경 가능성]**
        * 중간에 인스턴스를 변경하고 싶으면 외부에서 강제로 호출할 수 있음(그럴일은 거의 없지만)
    * 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법
    <br><br>
  * 스프링 컨테이너는 크게 두가지 `Life Cycle`이 존재
    * 스프링 빈을 모두 등록
    * 의존관계를 자동으로 주입(@Autowired)
      <br><br>
  * 생성자 주입은 객체가 생성되고 빈을 등록하면서 주입도 `동시에` 이루어진다.
    * 객체를 생성할때 생성자가 실행되고 @Autowired를 발견한 스프링이 동시에 의존성도 주입하기 떄문이다.
      <br><br>
  * 반면에 수정자 주입은 `객체 생성이 먼저`되고(스프링 빈 모두 등록) 이후 `의존관계를 자동으로 주입`하는 단계로 나뉜다.
    * 수정자 주입시 주입되는 순서는 보장되지 않음(생성자 주입만 순서가 보장됨)
      <br><br>
  * 또한 이렇게 수정자를 이용하면 생성자가 필요 없어짐
  
<br><br>
  
**[참고]** : @Autowired의 기본 동작은 주입할 대상이 없으면 오류가 발생한다. 주입할 대상이 없어도 동작하게 하려면
`@Autowired(required = false)`로 지정하면된다.`(선택 가능성)`

**[참고]** : 자바빈 프로퍼티, 자바에서는 과거부터 필드의 값을 직접 변경하지 않고, setXxx, getXxx라는 메소드를 
통해서 값을 읽거나 수정하는 규칙을 만들었는데, 그것이 자바빈 프로퍼티 규약이다.

* ### 필드 주입
  * 이름 그대로 필드에 바로 주입하는 방법이다.
  * 특징
    * 코드가 간결해서 많은 개발자들을 유혹하지만 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점 존재.   
      (스프링 없이 순수한 자바코드로 테스트 할 수 없음 : 생성자, 수정자가 없으므로 필드에 값 주입 불가)
    * DI 프레임워크가 없으면 아무것도 할 수 없다. (생성자, 수정자가 없으므로 순수 자바코드로 주입 할 방법 없음)
    * 사용하지 말자!
    * 필드 주입이 사용되는 특수한 상황
      * 애플리케이션의 실제 코드와 관계 없는 테스트 코드
      * 스프링 설정을 목적으로 하는 @Configuration 같은 곳에서만 특별한 용도로 사용

<br><br>
**[참고]:** 순수한 자바 테스트 코드에는 당연히 @Autowired가 동작하지 않는다. `@SpringBootTest`처럼 스프링
컨테이너를 테스트에 통합한 경우에만 가능하다.

**[참고]:** 다음 코드와 같이 `@Bean`에서 파라미터에 의존관계는 자동 주입된다. 수동 등록시 자동 등록된 빈의
의존관계가 필요할 때 문제를 해결할 수 있다.
```java
@Bean
OrderService orderService(MemberRepository memberRepoisitory, DiscountPolicy
        discountPolicy) {
        new OrderServiceImpl(memberRepository, discountPolicy)
        }
```

* ### 일반 메소드 주입
  * 일반 메소드를 통해서 주입 받을 수 있다.
  * 특징
    * 한번에 여러 필드를 주입 받을 수 있다.
    * 일반적으로 잘 사용하지 않는다.(생성자, 수정자 주입으로 해결할 수 있으므로)
```java
@Component
public class OrderServiceImpl implements OrderService { 
    
  private MemberRepository memberRepository;
  private DiscountPolicy discountPolicy;
  
  @Autowired
  public void init(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
    this.memberRepository = memberRepository;
    this.discountPolicy = discountPolicy;
  }
}
```
**[참고]:** 당연한 이야기지만 의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 빈이어야 동작한다.
스프링 빈이 아닌 `Member`같은 클래스에서 `@Autowired` 코드를 적용해도 아무 기능도 동작하지 않는다.

<br>
<br>
<br>

### < --------------------------- 옵션 처리 --------------------------- >
* 주입할 스프링 빈이 없어도 동작해야 할 때가 있다.
* 다만 `@Autowired`만 사용하면 `required`옵션의 기본값이 `true`로 되어있어 자동 주입 대상이 없으면 오류가 발생한다.

* 자동 주입 대상을 옵션으로 처리하는 방법은 아래와 같음
  * `@Autowired(require=false)` : 자동 주입할 대상이 없으면 수정자 메소드 자체가 `호출 안됨`
  * `org.springframework.lang.@Nullable` : 자동 주입할 대상이 없으면 `null`이 입력된다.
  * `Optional<>` : `Java8`의 문법(공부하자) 자동 주입할 대상이 없으면 `Optional.empty`가 입력된다.

* 자세한 사항은 test.java.hello.core.autowired.AutowiredTest의 `AutowiredOption` 테스트를 확인해보자
  * 여기서 사용되는 Member는 `스프링 빈`이 아니다 : 따라서 스프링을 이용해 자동 주입을 하려하면 당연히도 객체가 존재하지 않는다.
  
**[참고]** : `@Nullable`, `Optional`은 스프링 전반에 걸쳐서 지원된다. 예를들어 생성자 자동 주입에서 특정 필드에만 사용해도
된다.

<br>
<br>
<br>

### < --------------------------- 생성자 주입을 선택해라! --------------------------- >
* 과거에는 수정자 주입과 필드 주입을 많이 사용했지만, 최근에는 스프링을 포함한 DI프레임워크 대부분이 생성자 주입을 권장함
이유는 아래와 같다.

**[불변의 장점]**
* 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다.   
  오히려 대부분의 의존관계는 애플리케이션 종료 전까지 변하면 안된다.(불변해야함)
* 수정자 주입을 사용하면, setXxx 메소드를 public으로 열어두어야 한다.
* 누군가 실수로 변경할 수 도 있고, 변경하면 안되는 메서드를 열어두는 것은 좋은 설계 방법이 아니다.
* 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이후에 호출되는 일이 없다. 따라서 불변하게 설계할 수 있다.


**[누락의 문제]**
* 수정자 의존관계에서 프레임워크 없이 순수한 자바 코드를 단위 테스트 하는 경우에 문제가 발생

```java
public class OrderServiceImpl implements OrderService {
  private MemberRepository memberRepository;
  private DiscountPolicy discountPolicy;
  
  @Autowired
  public void setMemberRepository(MemberRepository memberRepository) {
    this.memberRepository = memberRepository;
  }
  
  @Autowired
  public void setDiscountPolicy(DiscountPolicy discountPolicy) {
    this.discountPolicy = discountPolicy;
  }
//...
}
```
* @Autowired가 프레임워크 안에서 동작할 때는 의존관계가 없으면 오류나지만, 지금은 순수한 자바 코드로만 단위테스트를 수행
한다고 가정한다.   
아래와 같이 테스트를 수행하면 런타임 에러인 NPE(NullPointException)문제가 발생한다.
```java
@Test
void createOrder() {
  OrderServiceImpl orderService = new OrderServiceImpl();
  orderService.createOrder(1L, "itemA", 10000);
}
```
* OrderServiceImpl은 내부적으로 MemberRepository, DiscountPolicy의 의존관계를 가지는데 주입이 누락됐기 때문

> 위와 같은 문제를 생성자 주입을 이용하게 되면 제일 깔끔한 컴파일 오류가 발생한다.   
  또한 IDE에서 바로 어떤 값을 필수로 주입해야 하는지 알 수 있다.

* 아래의 테스트는 생성자 주입을 이용했을때 순수한 자바로 손쉽게 단위테스트를 작성할 수 있음을 보여준다.
```java
    @Test
    void createOrder() {
        // 테스트를 위한 더미 MemberRepository 객체를 생성한다.
        MemoryMemberRepository memberRepository = new MemoryMemberRepository();
        // 테스트를 위한 임의의 Member를 등록한다.
        memberRepository.save(new Member(1L, "name", Grade.VIP));

        // 생성자 주입을 이용해 OrderServiceImpl 객체를 생성함 여기서 new OrderServiceImp();를 이용하면 컴파일 오류 발생
        OrderServiceImpl orderService = new OrderServiceImpl(memberRepository, new FixDiscountPolicy());
        Order order = orderService.createOrder(1L, "itemA", 10000);

        // 검증
        assertThat(order.getDiscountPrice()).isEqualTo(1000);
    }
```

**[final 키워드를 사용가능]**
* 생성자 주입을 사용하면 필드에 `final`키워드를 사용할 수 있다. 그래서 생성자에 혹시라도 값이 설정되지 않게되면
  컴파일 시점에서 알려주어 막아준다.

```java
@Component
public class OrderServiceImpl implements OrderService {
  private final MemberRepository memberRepository;
  private final DiscountPolicy discountPolicy;
@Autowired
public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
  this.memberRepository = memberRepository;
  // this.discountPolicy = discountPolicy; 생략
}
//...
}
```
> 필수 필드인 discountPolicy의 값이 누락되었으므로 컴파일 오류가 발생함   
> (컴파일 오류는 가장 빠르고 좋은 오류)

**[참고]** : 수정자 주입을 포함한 나머지 주입 방식은 모두 생성자 이후에 호출되므로, 필드에 final 키워드를 사용 불가함
오직 생성자 주입 방식만 `final` 키워드를 사용할 수 있다.

**[정리]**
* 생성자 주입 방식은 프레임워크에 의존하지 않고, `순수한 자바 언어`의 특징을 잘 살리는 방법이다.
* 기본으로 생성자 주입을 사용하되, 필수 값이 아닌 경우에는 수정자 주입 방식을 `옵션`으로 부여하면 된다.(`동시 사용 가능`)
* 항상 생성자 주입을 선택하자! 그리고 가끔 옵션이 필요할 경우 수정자 주입을 선택하자. 필드 주입은 지양하는것이 좋다.

<br>
<br>
<br>

### < --------------------------- 롬복과 최신 트랜드 --------------------------- >
* 실제 개발은 대부분이 불변이고, final키워드를 필드에 많이 사용한다.
* lombok을 이용하면 생성자를 작성하고, 주입 받은 값을 대입받고 심지어 getter, setter등 간소화 할 수 있는 라이브러리가 존재한다.



* 롬복 라이브러리 사용
<br><br>
**[기존 코드]**
  ```java
  @Component
  public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;
    
    @Autowired
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
      this.memberRepository = memberRepository;
      this.discountPolicy = discountPolicy;
    }
  }
  ```
  > 여기서 @Autowired는 생성자가 1개뿐이므로 생략가능하다 또한 lombok을 이용하면 아래 코드 처럼 생성자도 생략할 수 있다.
  > @RequiredArgsConstructor

* 롬복 라이브러리가 제공하는 @RequiredArgsContructor를 사용하면 `final`이 붙은 필드를 모아서 생성자를 자동으로 만들어준다.   
  (코드에선 보이지 않지만 실제 호출 가능함)
<br><br>
**[최종 결과]**
  ```java
  @Component
  @RequiredArgsConstructor
  public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;
  }
  ```
  > 이전의 코드와 완전히 동일하며, 롬복이 자바의 애노테이션 프로세서라는 기능을 이용해서 컴파일 시점에 코드를
  > 자동으로 생성해준다. 실제 class를 열어보면 생성자 코드가 추가되어 있다.

**[정리]** : 최근에는 생성자를 딱 1개 두고, @Autowired를 생략하는 방법을 주로 이용한다. 여기에 Lombok라이브러리의
`@RequiredArgsConstructor`를 함께 사용하면 기능은 전부 제공되지만, 코드는 깔끔하게 사용가능하다.

**[롬복 라이브러리 적용 방법(Gradle)]**   
`build.gradle`에 라이브러리 및 환경 추가
```java
plugins {
  id 'org.springframework.boot' version '2.3.2.RELEASE'
  id 'io.spring.dependency-management' version '1.0.9.RELEASE'
  id 'java'
}
group = 'hello'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '11'
        
//lombok 설정 추가 시작
configurations {
  compileOnly {
    extendsFrom annotationProcessor
  }
}

//lombok 설정 추가 끝
repositories {
    mavenCentral()
}

dependencies {
implementation 'org.springframework.boot:spring-boot-starter'
  //lombok 라이브러리 추가 시작
  compileOnly 'org.projectlombok:lombok'
  annotationProcessor 'org.projectlombok:lombok'
        
  testCompileOnly 'org.projectlombok:lombok'
  testAnnotationProcessor 'org.projectlombok:lombok'
  //lombok 라이브러리 추가 끝
  
  testImplementation('org.springframework.boot:spring-boot-starter-test') {
    exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
  }
}

test {
  useJUnitPlatform()
}
```
* 롬복 라이브러리 적용하기
  1. Preferences(윈도우 File Settings) plugin lombok 검색 설치 실행 (재시작) 혹은 gradle로 의존성 추가
  2. Preferences Annotation Processors 검색 Enable annotation processing 체크 (재시작)
  3. 임의의 테스트 클래스를 만들고 @Getter, @Setter 확인

<br>
<br>
<br>

### < --------------------------- 조회할 빈이 2개이상 - 문제 --------------------------- >
* `@Autowired`는 타입(Type)으로 조회한다.
* 따라서 아래와 같은 코드와 유사하게 동작한다. (실제로는 더 많은 기능 제공)
  ```java
  ac.getBean(DiscountPolicy.class)
  ```
* 스프링 빈 조회에서도 학습 했듯이 타입으로 조회하면 선택된 빈이 2개 이상일떄 문제가 발생한다.
  * 따라서 기존에 RateDiscountPolicy만 @Component를 붙여 스캔했지만, 다른 타입인 FixDiscountPolicy도   
  @Component를 붙여서 조회할 빈이 2개가 되도록 만든다.

* 이후에 AutoAppConfigTest를 돌리게되면 NoUniqueBeanDefinitionException 예외(오류)가 발생한다. 
  ```java
  NoUniqueBeanDefinitionException: No qualifying bean of type 
  'hello.core.discount.DiscountPolicy' available: expected single matching bean
  but found 2: fixDiscountPolicy,rateDiscountPolicy
  ```
  (기대한 것은 싱글 매칭이지만 실제론 동일 타입 2개의 빈이 발견되었다는 오류)

* 의존관계 자동주입시 하위타입 즉 구체클래스를 지정할 수 도 있지만, 이는 DIP를 위배하고 유연성이 떨어짐   
 또한 이름만 다르고, 완전히 똑같은 타입의 스프링 빈이 2개 있을때 해결되지 않는다.

* 스프링 빈을 수동등록해도 되지만, 의존관계 자동주입(@Autowired)에서 해결하는 여러 방법이 존재한다.

<br>
<br>
<br>

### < --------------------------- @Autowired 필드 명, @Qualifier, @Primary --------------------------- >
* 동일한 타입의 스프링 빈이 2개 이상 조회될 떄 해결방법
  * @Autowired 필드, 파라미터 명 매칭방법
  * @Qualifier -> @Qualifier끼리 매 -> 빈 이름 매칭
  * @Primary 사용

1. **@Autowired 필드 명 매칭**
  * `@Autowired`는 타입 매칭을 시도하고, 이 떄 여러 빈이 있으면 필드이름, 파라미터 이름으로 빈 이름을 추가 매칭한다.   
    (생성자 주입시 생성자의 파라미터 이름으로 구분하게 된다.)
  * **필드 명 매칭은 먼저 타입 매칭을 시도하고, 그 결과에 여러 빈이 있을때 추가로 동작하는 기능이다.**

  * @Autowired 매칭 정리
    1. 타입 매칭
    2. 타입 매칭의 결과가 2개 이상일 때 필드명, 파라미터 명으로 빈 이름 매칭
<br><br>
2. **@Qualifier 사용**
    * `@Qualifier`는 추가 구분자를 붙여주는 방법이다. 주입 시 추가적인 방법을 제공하는 것이지 `빈 이름을 변경하는것은 아니다.`

    * 빈 등록시 @Qualifier를 붙여준다.
      ```java
      @Component
      @Qualifier("mainDiscountPolicy")
      public class RateDiscountPolicy implements DiscountPolicy {}
      ```
      ```java
      @Component
      @Qualifier("fixDiscountPolicy")
      public class FixDiscountPolicy implements DiscountPolicy {}
      ```

    * 생성자 자동 주입 예시
      ```java
      @Autowired
      public OrderServiceImpl(MemberRepository memberRepository, 
                        @Qualifier("mainDiscountPolicy") DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
      }

      ```
    * 수정자 자동 주입 예시
      ```java
      @Autowired
      public void setDiscountPolicy(@Qualifier("mainDiscountPolicy") DiscountPolicy discountPolicy) {
          this.discountPolicy = discountPolicy;
      }
      ```
      **[참고]** : `@Qualifier`로 주입할 때 `@Qualifier("mainDiscountPolicy")` 를 못찾으면
      mainDiscountPolicy라는 이름의 스프링 빈을 추가로 찾는다.    
      하지만 경험상 @Qualifier 는 @Qualifier 를 찾는 용도로만 사용하는게 명확하고 좋다.
    
    * 또한 수동으로 빈을 직접 등록할 때도 @Qualifier를 동일하게 사용할 수 있다.
      ```java
      @Bean
      @Qualifier("mainDiscountPolicy")
      public DiscountPolicy discountPolicy() {
        return new ...;
      }
      ```
      
    * **@Qualifier와 Lombok의 @RequiredArgsConstructor 같이 사용하기**
      * java/main/에 `lombok.config` 생성
      * `lombok.copyableAnnotations += org.springframework.beans.factory.annotation.Qualifier` 작성
      * 재 빌드 후 아래와 같이 @Qualifier를 이용하면 사용할 수 있다.
      ```java
      @Component
      // final이 붙은 필드를 가지고 매개인자가 있는 생성자를 자동으로 만들어준다. 또한 생성자가 1개면 @Autowired도 생략가능
      @RequiredArgsConstructor
      public class OrderServiceImpl implements OrderService {
          private final MemberRepository memberRepository;
          // 롬복의 @RequiredArgsConstructor와 @Qualifier 같이 사용하기
          @Qualifier("mainDiscountPolicy")
          private final DiscountPolicy discountPolicy;
      ```
      > Qualifier를 지우고 필드 이름을 mainDiscountPoilicy로 변경하는 것도 방법
3. @Primary 사용
    * `@Primary`는 우선순위를 정하는 방법, @Autowired 시에 여러 빈이 매칭되면 `@Primary`가 우선권을 가짐.   
      (편하긴 하지만 한계점을 가진다.)

    * rateDiscountPolicy가 우선권을 가져야 한다면 아래와 같이 이용 가능하다.
   ```java
   @Component
   @Primary
   public class RateDiscountPolicy implements DiscountPolicy {}
   
   @Component
   public class FixDiscountPolicy implements DiscountPolicy {}
   ```
   > 이렇게 되면 생성자, 수정자는 수정할 코드가 없이 @Primary가 지정된 RateDiscountPolicy의 객체를 자동으로
   > 주입받을 수 있다.

    * 여기까지 보면 @Primary 와 @Qualifier 중에 어떤 것을 사용하면 좋을지 고민이 될 것이다.   
      @Qualifier 의 단점은 주입 받을 때 다음과 같이 `모든 코드에` @Qualifier 를 붙여주어야 한다는 점이다.   
      반면에 @Primary 를 사용하면 이렇게 @Qualifier 를 `붙일 필요가 없다`.
<br><br>
    * **@Primary, @Qualifier 활용**
      > 코드에서 자주 사용하는 메인 데이터베이스의 커넥션을 획득하는 스프링 빈이 있고,   
       코드에서 특별한 기능으로 가끔 사용하는 서브 데이터베이스의 커넥션을 획득하는 스프링 빈이 있다고 생각해보자.   
       메인 데이터베이스의 커넥션을 획득하는 스프링 빈은 @Primary 를 적용해서 조회하는 곳에서   
       @Qualifier 지정 없이 편리하게 조회하고, 서브 데이터베이스 커넥션 빈을 획득할 때는   
       @Qualifier 를 지정해서 명시적으로 획득 하는 방식으로 사용하면 코드를 깔끔하게 유지할 수 있다.   
       물론 이때 메인 데이터베이스의 스프링 빈을 등록할 때 @Qualifier 를 지정해주는 것은 상관없다.

      * 즉 공통적으로 많이 사용되는 부분은 @Primary를 이용해 Default로 이용하면 편리하고,   
      많이 사용되지 않는 서브 데이터베이스와 같은것들은 사용할때만 @Qualifier로 특정지어서 사용할 수 있다.   
      다만 메인 데이터베이스의 스프링 빈을 등록할때 @Qualifier를 같이 지정해도 상관은 없다.
<br><br>
      * **@Primary와 @Qualifier의 우선순위**
        * `@Primary`는 기본값 처럼 동작하고 `@Qualifier`는 좀 더 섬세하기 동작한다.   
          이런경우 스프링은 자동보다 수동이, 넓은 범위의 선택권 보다는 좁은 범위의 선택권이 우선 순위가 높다.   
          따라서 여기서도 `@Qualifier`가 우선순위가 높다.

      * 롬복에서는 우선 주입을 원하는 구체 클래스에 @Primary를 붙이고 사용하면 된다.

<br>
<br>
<br>

### < --------------------------- Annotation 직접 만들기 --------------------------- >
* `@Qualifier("mainDiscountPolicy)` 이렇게 문자를 적으면 컴파일시 타입 체크가 안된다.   
  따라서 다음과 같은 애노테이션을 만들어서 문제를 해결 할 수 있다.
  ```java
  @Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE})
  @Retention(RetentionPolicy.RUNTIME)
  @Documented
  @Qualifier("mainDiscountPolicy")
    public @interface MainDiscountPolicy {
  }
  ```
  ```java
  //생성자 자동 주입
  @Autowired
  public OrderServiceImpl(MemberRepository memberRepository,
  @MainDiscountPolicy DiscountPolicy discountPolicy) {
    this.memberRepository = memberRepository;
    this.discountPolicy = discountPolicy;
  }
  //수정자 자동 주입
  @Autowired
  public void setDiscountPolicy(@MainDiscountPolicy DiscountPolicy
  discountPolicy) {
    this.discountPolicy = discountPolicy;
  }  
  ```

  
* 미리 정의 해놓은 @MainDiscountPolicy를 이용하면 내부적으로 @Qualifier("mainDiscountPolicy)가 있으므로 동일하게 사용 가능하다.
* 또한 여러곳에서 사용할 때 오류 확률을 줄여주고, 추가로 이름 변경이 필요할 때 한곳에서 변경하면 해결된다는 장점도 가진다.

**[정리]** : 애노테이션은 상속이라는 개념이 없다. 이렇게 여러 애노테이션을 모아서 사용하는 기능은 스프링이 제공해주는 기능이다.   
@Qualifier 뿐만 아니라 다른 애노테이션들도 함꼐 조합해 사용 가능하다.   
또한 @Autowired도 재 정의 할 수 있지만, 스프링이 제공하는 기능을 뚜렷한 목적없이 무분별하게 재정의 하는 행위는   
유지보수에 더욱 혼란만 가중 시킬 수 있으니 유의하자.


**[알아두기]**    
1. @Qualifier 자체에   @Target, @Retention, @Documented 어노테이션이 있으니 생략해도 괜찮지 않을까?
  > 자바 애노테이션은 언어적으로 내부의 애노테이션이 포함되어도 그 부분이 적용되지 않음.   
    하지만, 스프링이 일부 포함된 애노테이션을 추가로 읽어서 가능하게 도와주는 것이다.
    자바 애노테이션은 자바 언어가 컴파일 되는 시점에 적용되는 부분이 있고, 스프링을 사용하며 적용하는 부분이 존재.   
    여기서 위의 애노테이션들은 자바 언어가 컴파일 할 때 사용하는 애노테이션이므로 내부에 포함해도(@Qualifier안에)
    적용이 되지 않는다.
2. @RequiredArgsConstructor와 커스텀 애노테이션(@MainDiscountPolicy) 같이 이용하기
  > 이전에 @Qualifier와 @RequiredArgsConstructor를 같이 이용하기 위해서 lombok.config에 설정을 추가했다.   
    @MainDiscountPolicy는 새로운 어노테이션을 만든것이므로 같이 이용하기 위해선   
    lombok.copyableannotations 설정을 추가해야한다.   
    `lombok.copyableannotations += hello.core.annotation.MainDiscountPolicy`
3. 커스텀 애노테이션의 권상 사항
   > 애노테이션을 만들면 코드로 추적할 수 있다는 장점이 있다. 하지만 대부분의 문제들은 커스텀 애노테이션 없이   
   @Qualifier, @Primary등 만 사용해도 문제를 해결 할 수 있다.   
   커스텀 애노테이션이 많으면 그것 자체가 부담이 될 수 있으므로 정말 중요하다고 판단되는 곳에 아주 일부에 한해서   
   부분적으로 적용하는 것을 권장한다.

<br>
<br>
<br>

### < --------------------------- 조회한 빈이 모두 필요할 때, List, Map --------------------------- >
* 의도적으로 해당 타입의 스프링 빈이 전부 필요한 경우도 존재
  * 할인 서비스를 제공할 때, 클라이언트(고객)가 할인의 종류(Rate, Fix)를 선택할 수 있다고 가정
  * 스프링을 사용하면 소위 Strategy pattern을 간단하게 구현할 수 있다.
```java
    static class DiscountService {
        private final Map<String, DiscountPolicy> policyMap;
        private final List<DiscountPolicy> policies;

        @Autowired  // 컬렉션 객체들도 자동주입이 가능하다. 일반적으로 Map은 key값으로 빈의 이름을, value로 객체를 삽입한다.
        public DiscountService(Map<String, DiscountPolicy> policyMap, List<DiscountPolicy> policies) {
            this.policyMap = policyMap;
            this.policies = policies;
            System.out.println("policyMap = " + policyMap);
            System.out.println("policies = " + policies);
        }

        // Member객체와 가격, 정책코드를 넘겨주고 Map에서 알맞은 정책 코드를 이용해 실제 할인율을 넘겨주는 로직
        public int discount(Member member, int price, String discountCode) {
            DiscountPolicy discountPolicy = policyMap.get(discountCode);

            System.out.println("discountCode = " + discountCode);
            System.out.println("discountPolicy = " + discountPolicy);

            return discountPolicy.discount(member, price);
        }
    }
```
> 할인정책서비스를 구현 Map을 이용해 모든 정책을 담아놓고 필요한 정책을 받아와서 실제 할인률을 계산하는 discount 메소드를 가짐
```java
public class AllBeanTest {
    @Test
    @DisplayName("해당 타입의 스프링 빈이 다 필요한 경우 : 클라리언트가 할인의 종류를 선택(fix, rate")
    void findAllBean() {
        // DiscountPolicy의 스프링 빈을 이용하기 위해 AutoAppConfig도 스프링 빈으로 등록
        ApplicationContext ac = new AnnotationConfigApplicationContext(AutoAppConfig.class, DiscountService.class);
        DiscountService discountService = ac.getBean(DiscountService.class);
        Member member = new Member(1L, "userA", Grade.VIP);
        // 임의의 멤버, 가격과 정책코드를 넘겨 실제 할인가를 받아옴
        int discountPrice = discountService.discount(member, 10000, "fixDiscountPolicy");

        // fix정책은 무조건 1000원 할인임을 검증
        assertThat(discountPrice).isEqualTo(1000);
        assertThat(discountService).isInstanceOf(DiscountService.class);

        // rate정책은 10%할인율이 적용됨을 검증
        discountPrice = discountService.discount(member, 20000, "rateDiscountPolicy");
        assertThat(discountPrice).isEqualTo(2000);
    }
}
```
> 고객이 할인 정책을 직접 선택해서 실제 할인률을 받아와 검증하는 테스트

* **[로직 분석]**
  * DiscountService는 `Map`으로 `모든 DiscountPolicy`를 주입 받음(fixDiscountPolicy, rateDiscountPolicy)
  * `discount()` 메서드는 discountCode로 "fix, rateDiscountPolicy"중 하나가 넘어오면 Map에서 알맞은 `스프링 빈`을
  찾아서 실행한다.
<br><br>
* **[주입 분석]**
  * `Map<String, DiscountPolicy>` Map의 키에 스프링 빈의 이름을 넣어주면 값으로 `DiscountPolicy`값으로 조회한 모든
  스프링 빈을 담아준다.
  * `List<DiscountPolicy>`는 DiscountPolicy타입으로 조회환 모든 스프링 빈을 담음.
  * 해당하는 타입의 스프링 빈이 없다면, `빈 컬렉션`이나 `Map`을 주입한다.
<br><br>

* **[참고 - 스프링 컨테이너를 생성하면서 스프링 빈 등록하기]**
  * 스프링 컨테이너는 생성자에 클래스 정보를 받음, 여기에 클래스 정보를 넘기면 해당 클래스가 스프링 빈으로 자동 등록된다.
  * `new AnntationConfigApplicationContext(AutoAppConfig.class, DiscountService.class);`
    * 위 코드는 2가지로 이해할 수 있다.
      1. new AnnotationConfigApplicationContext();를 통해 스프링 컨테이너를 생성
      2. AutoAppConfig.class, DiscountService.class를 파라미터로 넘기면서 해당 클래스를 자동으로 스프링 빈으로 등록
  <br><br>
  * 정리하게 되면 스프링 컨테이너를 자동생성과 동시에, 해당 컨테이너에 AutoAppConfig, DiscountService를 스프링 빈으로
  자동 등록한다.
  * 또한 내부에 ComponentScan이나 Configuration을 만나면 스캔을하며 빈을 자동 등록하거나 @Bean을 이용해 수동 빈 등록도
  진행하게 된다.

<br>
<br>
<br>

### < --------------------------- 자동, 수동의 올바른 실무 운영 기준 --------------------------- >
* pdf 파일 참조

* 간단정리   
  * 편리한 자동 기능을 기본으로 사용하자   
  * 직접 등록하는 기술 지원 객체는 수동 등록
    * 데이터베이스 커넥션, 트랜잭션 설정, 공통 로그 처리 같은 부분에서 주로 사용. 공통으로 사용하는 외부 라이브러리를 연동할 때도 사용
  * 다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민해보자   

<br>
<br>
<br>

### < --------------------------- 빈 생명주기 콜백 시작 --------------------------- >
* 스프링 빈이 생성되거나, 죽기 일보직전에 스프링이 스프링 빈안에 있는 메소드를 호출해줌 
  * 빈이 생성되고 나서 무엇인가 초기화 할 때 호출하거나, 빈이 소멸직전에 안전하게 종료하기 위한 메소드를 호출하는 등의 역할
  * 약 3가지 정도의 방식이 존재(각 방식별로 특징이 있다.)
  <br><br>
* 데이터베이스 커넥션 풀이나, 네트워크 소켓과 같이 애플리케이션 시작 지점에 필요한 연결을 미리하고,   
  애플리케이션 종료 시점에 연결을 모두 종료하는 작업을 진행하기 위해 객체의 초기화와 종료 작업이 필요함.
  * 연결을 미리 하는 이유는 초기 딜레이 감소, 미리 연결을 준비해놓으며 조금이라도 빠른 연결 가능케함
  * 종료를 미리 하는 이유는 한번에 서버가 꺼지는 것 보다 조금 더 안전하게 종료하기 위함
<br><br>
* 스프링을 통해 초기화, 종료 작업을 어떻기 진행하는지 알아보자
  * 간단한 외부 네트워크 사전 연결 객체 생성. (실제 네트워크 아니므로 단순 문자열 출력)


* `BeanLifeCycleTest` 결과
  * 실행하면 다음과 같이 이상한 결과가 나옴
  ```
  생성자 호출, url = null
  connect: null
  call: null message = 초기화 연결 메시지
  ```
  > 생성자 부분을 보면 url정보 없이 connect가 호출됨   
  > 이는 당연한 결과 : 객체 생성 단계는 url이 없고 생성 이후 외부에서 수정자를 통해 url을 주입했기 때문이다.
  > 즉 setUrl()을 호출해야 url이 존재하게 됨

* 스프링 빈은 다음과 같은 라이프 사이클을 가진다.
  * **객체 생성 -> 의존관계 주입** (다만 예외적으로 생성자 주입은 예외: 객체를 만들때 스프링 빈이 같이 들어와야함)
<br><br>
* 스프링 빈은 객체를 생성하고, 의존관계 주입이 끝난 다음에 필요한 데이터를 사용할 수 있는 준비가 완료됨
* 따라서 초기화 작업은 의존관계 주입이 모두 완료되고 난 다음에 호출해야 한다.   
  > 초기화 작업은 객체를 생성하는 작업이 아님!!   
  객체 안에 필요값이 다 연결되어있고, `외부랑 연결하여 처음 일을 시작하는 단계`를 말한다.
* 개발자는 의존관계 주입 완료시점을 어떻게 알까?
<br><br>

* `스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해 초기화 시점을 알려주는 다양한 기능`을 제공한다.   
  또한 `스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백`을 준다. 따라서 안전하게 종료 작업을 진행 할 수 있음   
  > (위의 소멸 콜백은 스프링 컨테이너 즉 일반적 싱글톤과 같은 경우고, 다른 scope의 경우 다른 소멸 콜백을 받음)

<br><br>
* **스프링 빈의 이벤트 라이프 사이클**
  * **스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료**   
    (생성자 주입 같은 경우는 스프링 빈 생성 단계에서 의존관계 주입이 어느정도 발생한다.)
    * **초기화 콜백** : 빈이 생성되고, 빈의 의존관계가 주입이 완료된 후 호출
    * **소멸전 콜백** : 빈이 소멸되기 직전에 호출
    > 따라서 스프링은 다양한 방식으로 생명주기 콜백을 지원한다.

<br><br>

* 그렇다면 최대한 생성자에서 모든작업을 해버리는것이 낫지 않을까?
  > **참고 : 객체의 생성과 초기화를 분리하자.**   
  > 생성자는 필수 정보(파라미터)를 받아 메모리에 할당해 객체(필요값만 세팅)를 생성하는 책임 가짐!!   
  > 하지만 초기화는 이렇게 생성된 값을 활용해 외부 커넥션 연결 등 `무거운 동작` 수행   
  > 
  > 생성자 안에서 객체 생성과 무거운 초기화 작업을 동시에 하기 보다는   
  > 객체 생성과 초기화 부분을 명확하게 나누는것이 `유지보수 관점`에서 좋다.      
  > (초기화 작업이 내부 값들만 변경하는 정도로 단순한 수준일 경우는 생성자에서 한번에 처리하는게 나을 수 도 있다.)   
  > (생성자는 객체 내부 값들을 세팅하는 정도로만 사용)
  
  > **참고: ** 싱글톤 빈들은 스프링 컨테이너가 종료될 때 싱글톤 빈들도 함께 종료됨.   
  > 따라서 스프링 컨테이너가 종료되기 직전에 소멸전 콜백이 발생함.   
  > 싱글톤 처럼 컨테이너의 시작과 종료까지 생존하는 빈도 있지만, 생명주기가 짧은 빈도 있다.   
  > 생명주기가 짧은 빈은 컨테이너와 무관하게 해당 빈이 종료되기 직전에 소멸전 콜백이 발생한다.   
  > 자세한 내용은 스코프에서!!

* 객체를 생성하는 단계, 초기화 하는 단계를 분리할때의 장점
  * 객체를 생성해놨지만 외부 커넥션 등 어떠한 최초의 행위가 올때까지 기다릴 수 있음(객체는 생성한 상태로)
<br><br>

* 그러면 스프링은 의존관계 주입이 끝나고 초기화 해도 된다 혹은 스프링이 사라지기 직전 소멸전 콜백을 알려줄까?   
  * **스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 지원한다.**
    * 인터페이스(InitializingBean, DisposableBean) : 인터페이스 통해 지원
    * 설정 정보에 초기화 메서드, 종료 메서드 지정 : 빈 등록시 어떤것이 초기화 인지 지정 가능
    * @PostConstruct, @PreDestory 애노테이션 지원 : 특정 메소드에 달아놓으면 됨

<br>
<br>
<br>

### < --------------------------- 인터페이스 InitializingBean, DisposableBean --------------------------- >
* 인터페이스로 초기화와 소멸전 콜백을 받는 방법을 바로 알아보자
  * NetworkClient 클래스에 InitializingBean, DisposableBean 인터페이스를 상속받으면 구현 메소드로    
    afterPropertiesSer(), destroy()를 구현한다. 이는 각각 초기화 콜백, 소멸전 콜백의 동작을 한다.

  * 실제 출력 결과도 초기화 콜백이 의존관계 주입 완료후에 호출되며, 스프링 컨테이너 종료가 호출되자   
    소멸전 콜백이 호출 된 것도 알 수 있다.
<br><br>
* **초기화, 소멸 인터페이스 단점**
  * 요즘 들어 잘 사용하지 않는다 (초창기에 사용)
    * 스프링 전용 인터페이스임, 해당 코드들이 스프링 전용 인터페이스에 의존한다.
    * 초기화, 소멸 메서드의 이름을 변경할 수 없다.
    * 내가 코드를 고칠 수 없는 외부 라이브러리에 적용할 수 없다.
    > **참고**: 인터페이스를 사용하는 초기화, 종료 방법은 스프링 초창기에 나온 방법, 현재는 다음의 더 나은   
    > 방법들이 있어서 거의 사용하지 않는다.

<br>
<br>
<br>

### < --------------------------- 빈 등록 초기화, 소멸 메서드 지정 --------------------------- >
* 빈을 등록하는 시점에 초기화인지, 소멸인지 지정해주는 방법이 있다.
  * 설정 정보에 @Bean(initMethod = "init", destroyMethod = "close")처럼 초기화, 소멸 메소드를 지정할 수 있다.

**설정 정보 사용 특징**   
* 메서드 이름을 자유롭게 줄 수 있다.
* 스프링 빈이 스프링 코드에 의존하지 않는다.
  * (NetorkClient 클래스 내부적으로 스프링에 대해 전혀 의존하지 않는다.)
* 코드가 아니라 설정정보를 사용하므로 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메소드를 적용할 수 있다.


**종료 메서드 추론** : @Bean의 destroyMethod 속성에는 특별한 기능이 있다.
* 라이브러리는 대부분 `close`, `shutdown`이라는 이름의 종료 메소드를 사용함
* @Bean의 destroyMethod는 기본값이 (inferred)[추론]으로 등록 되어있음
* 추론 기능은 close, shutdown 이름의 메소드를 자동으로 호출해 준다. 즉, 종료 메소드를 추론해서 호출한다.
* 따라서 직접 스프링 빈으로 등록하면 종료 메소드를 따로 적어주지 않아도 잘 동작함
* 추론 기능을 사용하고 싶지 않다면 destroyMethod="" 이렇게 빈 공백을 지정한다.

<br>
<br>
<br>

### < --------------------------- 애노테이션 @PostConstruct, @PreDestroy--------------------------- >
* 3가지의 방법 중 어노테이션을 이용하는 방법을 이용하면 됨(스프링도 권고하고 있다.)

* 초기화 콜백, 소멸전 콜백 메소드에 각각 @PoastConstruct, @PreDesroy를 붙여주면 끝
  * 가장 편리하게 초기화와 종료를 실행할 수 있다.

**@PostConstruct, @PreDestroy 애노테이션의 특징**
* 최신 스프링에서 가장 권장하는 방법
* 애노테이션 하나만 붙이면 되므로 매우 편리
* javax.annotation.* 패키지에 포함된다. 이는 스프링에 종속적인 기술이 아니라 JSR-250라는 자바 표준이다.   
  따라서 스프링이 아닌 다른 컨테이너에서도 동작한다.
* 컴포넌트 스캔과 잘 어울림.
  * 어차피 컴포넌트 스캔의 대상이 되어도 초기화 콜백, 소멸전 콜백 어노테이션을 넣어야 하므로 잘 어울림
* **유일한 단점!** 외부 라이브러리에 적용하지 못한다는 것이다.   
  (외부 라이브러리를 초기화, 종료 해야 하면 @Bean의 기능을 사용하자.)
  > 외부 라이브러리에 사용하지 못하는 이유 : 어노테이션은 코드에 직접 붙여야 하는데 .class는 수정할 수 없음   
  > 하지만 @Bean 방식은 설정 정보를 사용하므로 라이브러리 내부의 메소드를 지정하여 사용할 수 있으므로 사용 가능함

<br><br>
**정리**
* **@PostConstruct, @PreDestroy 애노테이션을 사용하자**
* 코드를 고칠 수 없는 외부 라이브러리를 초기화, 종료해야 하면 @Bean의 `initMethod`, `destroyMethod`를 사용하자.

<br>
<br>
<br>

### < --------------------------- 빈 스코프란?--------------------------- >
* 지금까지 스프링 빈은 싱글톤 스코프로 생성되었다.
  * 이는 스프링 빈이 스프링 컨테이너의 시작과 함께 생성되고, 스프링 컨테이너가 종료될 때 까지 유지됨
  * 스코프는 빈이 존재할 수 있는 범위를 말한다.
<br><br>
* **스프링은 다양한 스코프를 지원해줌**
  * **싱글톤** : 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
  * **프로토타입** : 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계주입(초기화 콜백포함)까지만 관여하고   
    더는 관리하지 않는 매우 짧은 범위의 스코프(클라이언트에게 반환해주고 관리하지 않음)
  <br><br>
  * **웹 관련 스코프**
    * **request** : http 웹 요청이 들어오고 response로 빠져 나갈때 까지 유지되는 스코프이다.
      * 정확히는 고객요청이 들어오고 최초에 스프링 컨테이너 호출할때 생성되고 빠져나갈때 destroy됨
    * **session** : 웹 세션이 생성되고 종료될 때까지 유지되는 스코프
    * **application** : 웹의 Servlet Context와 같은 범위로 유지되는 스코프

<br><br>
**컴포넌트 스캔 자동 등록**   
```java
@Scope("prototype")
@Component
public class HelloBean {}
```
**수동 등록**
```java
@Scope("prototype")
@Bean
PrototypeBean HelloBean() {
 return new HelloBean();
}
```

<br>
<br>
<br>

### < --------------------------- 프로토타입 스코프 --------------------------- >
* 싱글톤 스코프의 빈을 조회하면 스프링 컨테이너는 항상 `같은 인스턴스`의 스프링 빈을 반환한다.
* 반면에 프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 `새로운 인스턴스`를 생성해서 반환한다.
<br><br>
* **싱글톤 빈 요청**   
  1. 싱글톤 스코프의 빈을 스프링 컨테이너에 요청한다.
  2. 스프링 컨테이너는 본인이 관리하는 스프링 빈을 반환.
  3. 같은 요청이 스프링 컨테이너에 와도 동일한 객체 인스턴스의 스프링 빈을 반환함.
<br><br>
* **프로토타입 빈 요청**   
  1. 프로토타입 소코프의 빈을 스프링 컨테이너에 요청
  2. 스프링 컨테이너는 조회하기 직전의 시점에 빈을 생성, 필요 의존관계 주입
  3. 스프링 컨테이너는 생성한 프로토타입 빈을 클라이언트에 반환
  4. 이후 같은 요청이 들어오면 항상 새로운 프로토타입 빈을 생성해 반환
<br><br>

**[정리]** : 핵심은 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리함   
이후 클라리언트에 빈을 반환하여 생성된 프로토타입 빈을 스프링컨테이너가 관리하지 않게됨   
프로토타입 빈 관리 책임은 빈을 받은 클라이언트에 있다.   
`@PreDestroy`같은 종료 메소드도 호출되지 않는다
<br><br>

* hello.core.scope.SingletonTest.java, PrototypeTest.java를 확인해보자
  * 싱글톤 빈은 스프링 컨테이너 생성 시점에 초기화 메서드 실행, 프로토타입 스코프 빈은 스프링 컨테이너에서 빈을 조회시 생성
    초기화 메서드도 실행
  * 조회한 횟수만큼 새로운 스프링 빈 생성해 반환받음(초기화도 2번)
  * 싱글톤 빈은 스프링 컨테이너가 종료될 때 종료 메서드 실행(스프링 컨테이너가 관리하므로)   
    프로토타입 빈은 스프링 컨테이너가 생성, 의존관계 주입, 초기화 까지 관여 후 더는 관리하지 않음   
    (따라서 스프링 컨테이너가 종료될때 `@PreDestroy`같은 종료메서드 실행 안됨)
<br><br>

* **프로토타입 빈의 특징 정리**
  * 스프링 컨테이너에 요청할 때마다 새로 생성
  * 스프링 컨테이너는 프로토타입 빈의 생성, 의존관계 주입, 초기화까지만 관여
  * 종료 메서드 호출 X
  * 프로토타입빈은 빈을 조회한 클라이언트가 관리, 종료 메서드 호출도 클라이언트가 직접 해야함

<br>
<br>
<br>

### < --------------------------- 프로토타입 스코프 - 싱글톤 빈과 함꼐 사용시 문제점 --------------------------- >
* 스프링 컨테이너에 프로토타입 스코프의 빈을 요청하면 항상 새로운 객체 인스턴스를 생성해서 반환한다.   
  하지만, 싱글톤 빈과 함꼐 사용할 때는 의도한 대로 잘 동학하지 않으므로 주의해야함.

<br><br>
* 스프링 컨테이너에 프로토타입 빈 직접 요청 예시1 hello.core.scope.SingletonWithPrototypeTest1의 prototypeFind()
  1. 클라이언트A -> 스프링 컨테이너에 프로토타입 빈 요청
  2. 스프링 컨테이너는 프로토타입 빈 새로 생성후 반환(x01) -> 해당 빈의 count 필드 값은 0
  3. 클라이언트는 조회한 프로토타입 빈에 addCount() 호출하여 count 필드를 +1 증가
  4. 결과적으로 프로토타입 빈(x01)의 count값은 1이 된다.
> 위와 같은 작업은 여러번 반복해도 항상 새로운 프로토타입 빈이 생성되므로 각 클라이언트마다 count를 관리할 수 있다.

<br><br>
* 싱글톤 빈에서 프로토타입 빈 사용 hello.core.scope.SingletonWithPrototypeTest1의 singletonClientUserPrototype()
  * 이번에는 `clientBean`이라는 싱글톤 빈이 의존관계 주입을 통해서 프로토타입 빈을 주입받아 사용하는 예를 보자
  * `clientBean`은 싱글톤, 따라서 스프링 컨테이너와 같이 생성되고 의존관계 주입 발생
  1. `clientBean`은 의존관계 자동주입으로 프로토타입 빈을 요청
  2. 스프링 컨테이너는 프로토타입 빈을 생성해 `clientBean`에 반환
  3. `clientBean` 내부 필드에 프로토타입 빈의 참조값을 보관함
> 만약 다른 클라이언트가 스프링 컨테이너에 `clientBean`을 요청하게 되면 싱글톤이므로 기존의 클라이언트와   
> 동일한 `clientBean`이 반환된다.   
> 즉, `clientBean`이 내부에 가지고 있는 프로토타입 빈은 과거에 주입이 끝난 빈이다.   
> 주입 시점에 스프링컨테이너에 요청해 새로 생성된 것이지, 새로운 클라이언트가 사용할 때마다 새로 생성되지 않음   
> 즉 클라이언트들은 count라는 필드를 공유필드와 같이 사용하게 되는것이다.

<br>

* 스프링은 일반적으로 싱글톤 빈을 사용한다.(주로 싱글톤빈이 프로토타입빈 이용하는 양상)   
  이는 생성 시점에만 의존관계를 주입받는다.   
  떄문에 프로토타입 빈이 새로 생성되지만, 싱글톤 빈과 함꼐 유지되는것이 문제가 된다.

* 하지만 우리가 원하는것은 프로토타입 빈을 주입 시점에 생성되고 유지하는것이 아닌   
  사용할 때마다 새로 생성하는 것이다.
> ApplicationContext를 @Autowired로 주입받아서 logic()내에서 호출때마나 getBean(PrototypeBean.class)를   
> 아래 코드와 같이 이용하는 방법도 있지만, 이는 코드가 상당히 지저분해짐
```java
class ClientBean { 
    private final PrototypeBean prototypeBean;
    
    @Autowired
    ApplicationContext applicationContext;
    
    public int logic() {
        // 프로토타입 스코프인 빈에 대해서는 getBean시 내부적으로 빈을 새로 생성하고 그 빈을 반환하게 된다.
        PrototypeBean prototypeBean = applicationContext.getBean(PrototypeBean.class);
        prototypeBean.addCount();
        return prototypeBean.getCount();
    }
}
/**
 * @Autowired는 스프링 빈도 찾아주지만, 
 * 위와같은 ApplicationContext 같은 것도 편리하게 찾을 수 있는 부가 기능도 함께 제공합니다.
 * */
```
<br>

> **참고** : 여러 빈에서 프로토타입 빈을 주입받으면, 주입 받는 시점에 각각 새로운 프로토타입 빈이 생성된다.   
> clientA, clientB가 각각 의존관계 주입을 받으면 각각 다른 인스턴스의 프로토타입 빈을 주입 받음   
> 하지만 사용할 때마다 새로 생성되는 것이 아닌 `주입 받는 시점`에서만 적용된다.

<br>
<br>
<br>

### < --------------------------- 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 Provider로 문제 해결 --------------------------- >
* 싱글톤 빈과 프로토타입 빈을 사용할 때, 어떻게 하면 사용할 때 마다 항상 새로운 프로토타입 빈을 생성할 수 있을까?

* 스프링 컨테이너에 요청
  * 가장 간단한 방법, 싱글톤 빈이 프로토타입을 사용할 때마다 스프링 컨테이너에 새로 요청함   

  ```java
  class ClientBean { 
      private final PrototypeBean prototypeBean;
      
      @Autowired
      ApplicationContext applicationContext;
      
      public int logic() {
          // 프로토타입 스코프인 빈에 대해서는 getBean시 내부적으로 빈을 새로 생성하고 그 빈을 반환하게 된다.
          PrototypeBean prototypeBean = applicationContext.getBean(PrototypeBean.class);
          prototypeBean.addCount();
          return prototypeBean.getCount();
      }
  }
  /**
   * @Autowired는 스프링 빈도 찾아주지만, 
   * 위와같은 ApplicationContext 같은 것도 편리하게 찾을 수 있는 부가 기능도 함께 제공합니다.
   * */
  ```
  * ac.getBean()을 통해 항상 새로운 프로토타입 빈이 생성된다.
  * 이와같이 의존관계를 주입(DI)받는게 아니라 직접 필요한 의존관계를 조회하는것을 `Dependency Lookup`이라함(DL)
  * 다만 스프링의 ApplicationContext전체를 주입받으면 스프링 컨테이너에 종속적이게 된다. (단위테스트의 어려움 존재)
  * 우리가 필요한것은 지정한 빈을 컨테이너에서 대신 찾아주는 **DL**정도의 기능만 제공하는것이 필요
<br><br>
* ObjectFactory, ObjectProvider
  * DL 서비스를 제공하는 스프링의 기능
  * `ObjectFactory`는 단순 조회만 가능하지만 여기에 편의 기능을 더 추가한것이 `ObjectProvider`임
  ```java
  @Autowired
  private ObjectProvider<PrototypeBean> prototypeBeanProvider;
  
    public int logic() {
      PrototypeBean prototypeBean = prototypeBeanProvider.getObject();
      prototypeBean.addCount();
      int count = prototypeBean.getCount();
      return count;
    }
    // 클라이언트가 getObject()를 호출하면 그때서야 스프링 컨테이너에서 프로토타입 빈을 찾아서 반환(새로 생성)
    // ApplicationContext한테 직접 찾는것이 아닌 Provider가 찾아주는 기능만 제공해줌(스프링의 기능을 전부 사용하는것이 아닌 줄여서 사용)
    // 따라서 필요할 때마다 스프링 컨테이너에 요청하는 기능을 사용할 수 있다.
    // (꼭 프로토타입 빈을 찾는 전용으로 사용하는것이 아닌 스프링 컨테이너를 통해서 DL을(의존관계 조회) 도와주는것 즉,
    // 핵심컨셉은 스프링 컨테이너에 직접 조회하는것이 아닌 대신 조회해주는 대리자의 느낌으로 생각)
  ```
  * prototypeBeanProvider.getObject()를 통해 항상 새로운 프로토타입 빈이 생성됨
  * ObjectProvider의 getObject()는 내부에서 스프링 컨테이너를 통해 해당 빈을 찾아 반환(**DL**)
  * 스프링 제공 기능이지만, 기능이 단순함 --> 단위테스트 및 mock코드를 만들기 훨씬 용이
  * 딱 필요한 DL정도의 기능만 제공
  <br><br>
* **ObjectFactory, ObjectProvider 특징**
  * ObjectFactory : 기능 단순, 별도의 라이브러리 필요없음, 스프링에 의존함
  * ObjectProvider : ObjectFactory상속, 옵션, 스트림 처리등 편의기능 다수, 별도의 라이브러리 필요없음, 스프링에 의존함
<br><br>

* 스프링에 의존하지 않는 JSR-330 Provider
  * `javax.inject.Provider`라는 JSR-330 자바 표준을 사용하는 방법도 존재
  * 별도의 라이브러리를 추가해줘야함 (javax.inject:javax.inject:1)
  ```java
    @Scope("singleton")
    static class ClientBean {

        // 따로 빈을 등록하지 않아도 스프링이 자동으로 만들어서 주입해준다.
        private Provider<PrototypeBean> prototypeBeanProvider;

        @Autowired
        public ClientBean(Provider<PrototypeBean> prototypeBeanProvider) {
            this.prototypeBeanProvider = prototypeBeanProvider;
        }

        public int logic() {
            PrototypeBean prototypeBean = prototypeBeanProvider.get();
            prototypeBean.addCount();
            int count = prototypeBean.getCount();
            return count;
        }
    }
  ```
  * `prototypeBeanProvider.get()`을 통해 항상 새로운 프로토타입 빈이 생성됨(조회를 할 때 생성)
  * `get()`을 호출하면 내부에선 스프링 컨테이너를 통해 해당 빈을 찾고, 반환(**DL**)
  * **자바 표준**이고, 기능이 단순, 따라서 단위테스트, mock코드를 만들기 훨씬 용이
  * 필요한 DL정도의 기능만 제공한다.
  <br><br>
* **JSR-330 Provider 특징**
  * get() 메서드 하나로 기능 매우 단순
  * 별도의 라이브러리가 필요함
  * 자바 표준임, 따라서 스프링이 아닌 다른 컨테이너에서도 사용 가능하다.
  <br><br>
* **최종 정리**
  * 프로토타입 빈을 언제 사용할까?
    * 매번 사용할 때마다 의존관계 주입이 완료된 새로운 객체 필요시   
      (하지만 실무에선 싱글톤 빈으로 대부분의 문제해결이 가능하므로 사용하는 일이 드물다.)
  * `ObjectProvider`, `JSR330 Provider`등은 프로토타입 뿐만 아니라 DL이 필요한 경우는 언제든지 사용가능
    * javax.inject.Provider를 살펴보면 아래와 같은 사용 메뉴얼이 존재한다.
    ```java
    /**
     * 1. retrieving multiple instances.
     * 2. lazy or optional retrieval of an instance.
     * 3. breaking circular dependencies.
     * 4. abstracting scope so you can look up an instance in a smaller scope from an instance in a containing scope.
     */
    ```
  * 프로토타입 빈을 찾는 전용으로 사용하는것이 아닌 스프링 컨테이너를 통해서 DL을(의존관계 조회) 도와주는것       
    핵심컨셉은 스프링 컨테이너에 직접 조회하는것이 아닌 대신 조회해주는 대리자의 느낌으로 생각 

> **참고** : 스프링 제공 메서드에 `@LookUp`사용하는 방법도 있지만, 생략   
> **실무에서의 자바표준과 스프링 제공 기능 사용에 대한 고민**   
> ObjectProvider는 DL을 위한 편의 기능을 많이 제공해주며 스프링 외에 별도의 의존관계 추가가 없으므로 편리   
> 만약 스프링 컨테이너가 아닌 다른 컨테이너에서도 사용해야하면 JSR-330 Provider를 사용
> 
> 스프링을 사용하다보면 다른 기능들도 자바 표준, 스프링이 제공하는 기능이 서로 곂칠때가 존재   
> 대부분이 스프링이 더 다양하고 편리한 기능을 제공 해준다.
> (예외로 JPA는 자바 표준을 더 권장함, 반대로 @PostConstruct, @PreDestroy는 표준이지만 스프링은 표준을 사용하길 권장함)

<br>
<br>
<br>

### < --------------------------- 웹 스코프 --------------------------- >
* 싱글톤은 스프링 컨테이너의 시작과 끝까지 함께하는 매우 긴 스코프이고,   
  프로토타입은 생성과 의존관계 주입, 그리고 초기화까지만 진행하는 특별한 스코프다.
<br><br>
* 웹 스코프에 대해 알아보자
* **웹 스코프의 특징**
  * 웹 스코프는 웹 환경에서만 동작한다.
  * 웹 스코프는 프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리한다. 따라서 종료 메서드가 호출된다.
<br><br>
* **웹 스코프의 종류**
  * **request**: HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP요청마다 별도의 빈 인스턴스가 생성, 관리됨
  * **session**: HTTP Session과 동일한 생명주기를 가지는 스코프
  * **application**: 서블릿 컨텍스트(`ServletContext`)와 동일한 생명주기를 가지는 스코프
  * **websocket**: 웹 소켓과 동일한 생명주기를 가지는 스코프
<br><br>
* **HTTP request 요청 당 각각 할당되는 reequest 스코프**
  * 클라이언트 A, B가 HTTP request 요청을 함
  * A, B 클라이언트 요청은 다른 HTTP request 요청이므로 `각각 다른 인스턴스`가 할당된다.    
    (각각 다른 스프링 빈이 생성이 되며 사용됨)
  * 만약 클라이언트 A가 서비스를 호출하면 서비스에서도 A전용 인스턴스가 사용된다.
  * 클라이언트 B가 서비스를 호출하면 서비스는 B 전용 인스턴스가 사용된다.
  > 즉 서로 다른 HTTP request 요청이 들어왔을때 request scope는 HTTP request 요청에 맞춰서 각각 인스턴스를 할당한다.   
  > 라이프 사이클은 HTTP request의 요청이 들어오고 나갈 때 까지는 `같은 인스턴스`가 관리된다.
  > 이후 특정 요청의 응답을 하게되면 destroy 된다.

<br>
<br>
<br>

### < --------------------------- request 스코프 예제 만들기 --------------------------- >
#### [웹 환경 추가]
* 웹 스코프는 웹 환경에서만 동작하므로 web 라이브러리 추가해야함
  * **build.gradle** : implementation 'org.springframework.boot:spring-boot-starter-web'
* 이후 `hello.core.CoreApplication`을 실행하면 웹 애플리케이션이 실행된다.
> **참고:** `spring-boot-starter-web`라이브러리를 추가하면 스프링 부트는 내장 톰켓 서버를 활용해   
> WAS와 스프링을 함께 실행한다.   
> 
> **참고:** 스프링 부트는 웹 라이브러리가 없으면 AnnotationConfigApplicationContext를 기반으로   
> 애플리케이션을 구동하지만, 웹 라이브러리가 추가되면 AnnotationConfigServletWebServerApplicationContext를   
> 기반으로 애플리케이션을 구동한다.(웹 라이브러리가 추가되면 웹과 관련된 추가 설정과 환경들이 필요하므로)

* 8080포트를 다른곳에서 사용중이면 application.preperties에 server.port=9090으로 변경
<br><br>

#### [request 스코프 예제 개발]
* 동시에 여러 HTTP 요청이 오면 정확히 어떤 요청이 남긴 로그인지 구분하기 어려움   
  이럴때 사용하기 좋은것이 바로 request scope다.
* 아래와 같이 로그가 남도록 request 스코프를 활용해보자
  ```
  [d06b992f...] request scope bean create
  [d06b992f...][http://localhost:8080/log-demo] controller test
  [d06b992f...][http://localhost:8080/log-demo] service id = testId
  [d06b992f...] request scope bean close
  ```
  * 기대하는 공통 포멧 : [UUID][requestURL]{message}
  * UUID를 사용해서 HTTP 요청을 구분하자
  * requestURL정보도 추가로 넣어 어떤 URL을 요청해 남은 로그인지 확인하기
<br><br>

**MyLogger.java**   
* 로그를 출력하기 위한 `MyLogger` 클래스
* `@Scope(value = "request")`를 사용해 request scope로 지정함, 따라서 myLogger빈은 HTTP 요청 당 하나씩 생성되고   
  HTTP 요청이 끝나는 시점에 소멸된다.
* 빈이 생성되는 시점에 자동으로 `@PostConstruct`초기화 메서드를 사용해 uuid를 랜덤생성해 저장함   
  myLogger빈은 HTTP 요청당 하나씩 생성되므로, 저장한 uuid를 통해 다른 HTTP 요청과 구분할 수 있는 id가 된다.
* myLogger 빈이 소멸되는 시점에 `@PreDestroy`를 사용해 종료메시지를 남긴다.
* `requestURL`은 빈이 생성되는 시점에는 알 수 없으므로, 외부에서 setter로 입력 받는다.
<br><br>

**LogDemoController.java**
* Logger가 잘 작동하는지 확인하는 테스트용 컨트롤러
* `HttpServletRequest`를 통해 요청 URL을 받아옴 (requestURL : http://localhost:8080/log-demo)
* requestURL을 myLogger빈에 저장한다. HTTP요청당 각각 구분되므로 다른 HTTP요청 떄문에 myLogger에 저장된 값이
  섞이지 않음
* 컨트롤러에서 controller test 라는 로그를 남긴다.

> **참고:** requestURL을 MyLogger에 저장하는 방법은 컨트롤러에서 처리하는것 보다 공통처리가 가능한   
> `스프링 인터셉터`, `서블릿 필터` 같은 곳을 활용하는것이 바람직함
<br><br>

**LogDemoService.java**   
* 비즈니스 로직이 있는 서비스 계층도 로그를 출력
* 만약 request scope가 아닌 파라미터로 모든 정보를 서비스 계층에 넘긴다면 코드가 지저분해짐   
  더 나아가 requestURL같은 웹과 관련된 정보가 `웹과 관련 없는 서비스 계층`까지 넘어가게 된다.   
  웹과 관련된 부분은 `컨트롤러`까지만 사용하는것이 바람직하다.   
  `서비스 계층은 웹 기술에 종속되지 않고`, 가급적 순수하게 유지하는 것이 유지보수 관점에서 바람직하다.
<br><br>

**기대되는 출력이 아닌 애플리케이션 실행 시점에서의 오류 발생**   
```
Error creating bean with name 'myLogger': Scope 'request' is not active for the 
current thread; consider defining a scoped proxy for this bean if you intend to 
refer to it from a singleton;
```

> LogDemoController는 스프링 컨테이너가 생성될때 myLogger빈을 의존관계 자동주입을 통해 주입 해야한다.   
> 하지만 myLogger 빈이 존재하지 않아서 주입을 할 수 가 없다. 왜?   
> MyLogger는 `request scope`이다. 즉 생`명주기가 고객의 요청(HTTP request)이 들어오고 응답하는 부분`까지이고   
> 그 사이에 스프링 컨테이너에게 myLogger를 달라고 해야한다.   
> 하지만 현재는 스프링 컨테이너가 생성되는 시점은 HTTP request 요청 자제가 없으므로 myLogger빈도 존재하지 않는다.   
> 따라서 위의 오류가 발생한다 (request scope가 활성화 되지 않았다는 오류)

**정리:** 스프링 애플리케이션을 실행하는 시점에 싱글톤 빈은 생성해서 주입이 가능하지만,   
request scope 빈은 아직 생성되지 않는다. 따라서 실제 고객의 요청이 와야 생성할 수 있다.   
스프링 컨테이너에게 myLogger빈을 달라는 단계를 의존단계 주입 단계가 아니라   
**실제 고객의 요청이 왔을때로 지연**시켜야 한다. (`Provider`를 이용해 문제를 해결할 수 있다.)

<br>
<br>
<br>

### < --------------------------- 스코프와 Provider --------------------------- >
* 첫 번째 해결방안 : Provider 사용
  * ObjectProvider를 사용해보자.
  
* 기존에 MyLogger를 직접 의존관계를 주입받는 것은 스프링 컨테이너 생성당시에는 request의 요청이 없으므로   
  request scope의 객체가 생성되지 않아 주입받을 수 없다.
* 따라서 ObjectProvider를 이용해 실제 request 요청이 들어왔을때 getObject()해오는 방법으로 해결할 수 있다.
<br><br>

* MyLogger를 직접 주입받는 코드에서 ObjectProvider로 조회하는 방법으로 코드를 변경하고 나면
  * `ObjectProvider` 덕분에 `ObjectProvider.getObject()`를 호출하는 시점까지 **request scope 빈의 조회를 통해   
  스프링 컨테이너에게 요청하는것을 지연**할 수 있다.   
  (이렇게 되면 request scope이므로 요청시 생성된다. 즉, 빈의 생성도 덩달아 지연된다.)
  * `ObjectProvider.getObject()`를 호출하는 시점에는 HTTP 요청이 진행주으 따라서 request scope 빈의 생성이   
    정상 처리됨.
  * `ObjectProvider.getObject()`를 `LogDemoController`, `LogDemoService`에서 각각 한번씩 **따로 호출해도   
    같은 HTTP 요청이면 같은 스프링 빈이 반환됨**
  * localhost창을 여러번 호출해도 **서로 다른 요청은 각각 요청에 맞게 구분되어 로그가 찍히는것을 볼 수 있다**.   
    (Thread를 이용해 service 로그를 찍기전 1초 sleep을 시켜도 로그는 섞이지만 각각의 request 호출 로그들은   
    올바른 순서대로 찍히는것을 볼 수 있다.)

    
> 하지만 이전시간에 오류났던 코드처럼 사용할 수 있는 방법이 있다. (코드양을 줄이기 위해)   
  **프록시를 사용하면 됨** 

<br>
<br>
<br>

### < --------------------------- 스코프와 프록시 --------------------------- >
* 프록시 방식을 사용해보자
```java
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class MyLogger {
}
```
* `proxyMode = ScopedProxyMode.TARGET_CLASS`가 추가됐다.
  * 적용 대상이 클래스가 아닌 인터페이스면 `INTERFACES`를 고르고
  * 클래스라면 `TARGET_CLASS`로 추가하면 된다.
* 위와 같이 프록시를 추가하면 `MyLogger`의 가짜 프록시 클래스를 만들어두고,   
  HTTP request와 상관 없이 가짜 프록시 클래스를 다른 빈에 미리 주입해 둘 수 있다.
* 이후 기존에 Provider를 사용하던 코드들을 일반적인 MyLogger를 의존관계 주입받듯이 원래대로 변경하면 된다.
  * 정상적으로 동작함 어떻게 이렇게 될까?
<br><br>

#### **웹 스코프와 프록시 동작 원리**   
* 실제 주입된 myLogger를 콘솔에 찍어보면
  ```java
  System.out.println("myLogger = " + myLogger.getClass());
  ```
  **결과**   
  `myLogger = class hello.core.common.MyLogger$$EnhancerBySpringCGLIB$$b68b726d`
<br><br>
  **[CGLIB라는 라이브러로 내 클래스(MyLogger)를 상속 받은 가짜 프록시 객체를 만들어서 주입한다.]**
* `@Scopr`의 `proxyMode = ScopedProxyMode.TARGET_CLASS`를 설정하면 스프링 컨테이너는 CGLIB라는 바이트 코드를   
  조작하는 라이브러리를 사용해서 MyLogger를 상속받은 가짜 프록시 객체를 생성한다.
* 결과를 확인해보면 우리가 등록한 순수한 MyLogger 클래스가 아닌 `MyLogger$$EnhancerBySpringCGLIB`라는 클래스로   
  만들어진 객체가 대신 등록됨을 알 수 있다.
* 또한 스프링 컨테이너에 "`myLogger`"라는 이름으로 진짜 대신 가짜를 등록한다.
* ac.getBean("myLogger", MyLogger.class);를 하면 진짜가 아닌 가짜 프록시 객체가 조회된다.
* 따라서 의존관계도 가짜 프록시 객체가 주입된다.

<br><br>
  **[가짜 프록시 객체는 요청이 오면 그 때 내부에서 진짜 빈을 요청하는 위임 로직이 들어있다.]**   
* 가짜 프록시 객체는 내부에 진짜 myLogger빈을 찾는 방법을 알고 있다.
* 클라이언트가 `myLogger.logic()`을 호출하면 가짜 프록시 객체의 메서드를 호출한 것이다.
* 가짜 프록시 객체는 request 스코프의 진짜 `myLogger.logic()`을 호출한다.
* 가짜 프록시 객체는 원본 클래스를 상속 받아 만들어짐 따라서 객체를 사용하는 클라이언트 입장에선   
  원본인지 아닌지도 모르게, 동일하게 사용가능하다. (**다형성**)

<br><br>
  **[동작정리]**   
* `CGLIB`라는 라이브러리로 내 클래스를 상속 받은 가짜 프록시 객체를 만들어서 주입한다.
* 가짜 프록시 객체는 실제 요청이 오면 그때 내부에서 실제 빈을 요청하는 `위임 로직`이 들어있다.
* 가짜 프록시 객체는 실제 request scope와 관계가 없다. 그냥 `가짜이고`, 내부에 단순한 `위임 로직`만 있고,   
  싱글톤 처럼 동작한다.
  > 실제로 싱글톤 처럼 프록시 객체는 1개만 생성됨.

<br><br>
**[특징정리]**  
* 프록시 객체 덕분에 클라이언트는 마치 싱글톤 빈을 사용하듯 편리하게 request scope를 사용할 수 있다.
* 핵심!! Provider든 프록시든 **핵심 아이디어는 진짜 객체 조회를 꼭 필요한 시점까지 지연처리 한다는 점이다.**
* 단지 Annotation 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있다. 이것이 바로 다형성과 DI컨테이너가   
  가진 가장 큰 강점이다.
* 꼭 웹 스코프가 아니어도 프록시는 사용할 수 있다.
  > Spring AOP도 위와같은 원리로 동작한다고 알아두자!! 다만 중요한점은 클라이언트 코드를 전혀 변경할 일이 없다.

<br><br>
**[주의점]**
* 마치 싱글톤을 사용하는것 같지만 다르게 동작하기 때문에 주의해서 사용해야함.
  > 싱글톤 빈처럼 사용되는것이 장점이지만, 뒤에서 실제 동작하는 방식은 스코프(Request, Singleton, Prototype)등   
  > 에 따라 달라지기 때문에 싱글톤 처럼 사용시 문제가 발생할 수 있다.   
  > 
  > 여러문제 중 예를 들어 싱글톤을 사용하는 이유 중 하나는 멀티스레드 환경에서 객체 재사용성을 높이기 위함임   
  > 만약 엄청나게 많은 요청이 오고, 싱글톤 처럼 보이는 프록시 객체를 호출한 경우를 보자   
  > 프록시 객체가 실제로 뒤에서 호출한 것이 `Prototype Scope` 빈이라면 수 많은 빈이 생성된다.   
  > 이는 서버에 불필요한 부하를 주는것 같은 오류가 있다.
* 특별한 Scope는 꼭 필요한 곳에만 최소화해서 사용하자, 무분별한 사용은 유지보수 및 테스트에 어렵다.

























